FrooxEngine.LogiX.Actions.DecrementFloatNode:#############################################################################
{
The <color=#00FF00>--</color> node reduces the referenced <b>Target</b> value by one when it receives an impulse at <b>Decrement</b>.
Usage

The <b>OnDone</b> output fires an impulse when the <b>Target</b> value has been decremented. 
An impulse will not fire if there is no valid <b>Target</b>. This impulse continues the impulse chain which arrived at <b>Decrement<b>.

This node differs from the -1 node under Operators since it only makes changes when it receives an impulse. 
This makes it useful for decrementing a target value (e.g. one stored in a variable node or component e.g. a ValueField) 
in a way which is saved and synchronized across all users. 
If the aim is to decrement a value locally as part of a LogiX calculation the -1 node is likely the better choice. 
}

FrooxEngine.LogiX.Actions.IncrementFloatNode:#############################################################################
{
The <color=#00FF00>++</color> node increases the referenced Target value by one when it receives an impulse at Increment.
Usage

The OnDone output fires an impulse when the Target value has been incremented. 
An impulse will not fire if there is no valid Target. This impulse continues the impulse chain which arrived at Increment.


This node differs from the +1 node under Operators since it only makes changes when it receives an impulse. 
This makes it useful for incrementing a target value (e.g. one stored in a variable node or component e.g. a ValueField) 
in a way which is saved and synchronized across all users. 
If the aim is to increment a value locally as part of a LogiX calculation the +1 node is likely the better choice. 
}


FrooxEngine.LogiX.Actions.DriveValueNode`1[T]:############################################################################
{
The <color=#00FF00><b>Drive</b></color> node will start driving the referenced DriveTarget with the input Source value when an impulse is received at StartDrive. 
The drive can be stopped by an impulse received at StopDrive.

Usage:

The Source input has a 'dummy' datatype when the node is spawned from the node browser. However, the node will overload to the correct value type when a suitable wire is connected.


The OnStartDrive output fires an impulse whenever an impulse arrives at the StartDrive input. This continues the impulse chain which arrived at StartDrive.


The OnStopDrive output fires an impulse whenever an impulse arrives at the StopDrive input. This continues the impulse chain which arrived at StopDrive.


The OnHook fires an impulse whenever the DriveTarget is driven with the Source value and another source (e.g. a Write node or ButtonValueSet component) 
attempts (but is not able) to overwrite the value.


The IsDriving output is True while the DriveTarget is driven with the Source value, otherwise False.


The HookedValue output provides the value which another source attempted to set the DriveTarget to when an impulse is fired from OnHook. 
The value is only available for the duration of the impulse chain started from OnHook.


Note that, when an impulse is received at StartDrive the drive target will become driven by the Source value regardless of whether it was 
already driven by some other source i.e. control of the target value is overridden. 
}


FrooxEngine.LogiX.Actions.DrivePlaybackNode:############################################################################
{

The <color=#00FF00><b>Drive Playback node</b></color> can be used to directly control the rate of playback of the DriveTarget. 
Since this is a drive, it is possible to localise the speed of playback, or even whether the clip is played at all, for differnt users. 

Inputs

When an impulse is received at StartDrive, the node will start driving the playback state of the DriveTarget. 
This gives exclusive control over the playback state to the Drive Playback node. Control will be taken over if the DriveTarget was previously driven by another source.


When an impulse is received at StopDrive, the node will stop driving the playback state of the DriveTarget. Playback will continue in the same state as it was just before driving stopped.


The ForceResync input will force the normalised position of the DriveTarget to the NormalizedPosition input value when an impulse is received.


The NormalizedPosition input controls the rate/state of playback. Default is 0.


The MaximumPositionError value is the maximum number of seconds that the DriveTarget playback position can deviate from the absolute playback position corresponding to 
NormalizedPosition input. The normalized playback position will be reset to the NormalizedPosition if the absolute playback position error is greater than MaximumPositionError. 
Default is 0.


The Speed input scales the rate of playback relative to the rate of change of the NormalizedPosition input, i.e. rate of normalized position change in the DriveTarget 
is equal to rate of change of NormalizedPosition multiplied by the Speed. If this has a value of 1, the default, the rate of change of DriveTarget playback normalized 
position is equal to the rate of change of NormalizedPosition. At higher, lower, or negative values the DriveTarget normalized playback position will start to deviate 
from the NormalizedPosition, resulting in altered playback speed, until the absolute playback position error is greater than the MaximumPositionError.


The Play input controls whether the DriveTarget playback position changes if NormalizedPosition is changing. Default is False.


The Loop input controls whether playback will restart from the beginning if the DriveTarget's normalized position is greater than or equal to 1. Default is False.
Outputs

The OnStartDrive output fires an impulse when an impulse is received at StartDrive. This continues the impulse chain which arrived at StartDrive.


The OnStopDrive output fires an impulse when an impulse is received at StopDrive. This continues the impulse chain which arrived at StopDrive.


The IsDriving output is True if the DriveTarget's playback is being driven by the Drive Playback node, otherwise False. 

}


FrooxEngine.LogiX.Animation.Tweening.TweenValueNode`1[T]:###########################################################################
{

The <color=#00FF00><b>Tween</b></color> node is used to interpolate the value of Target starting at From, and ending at To over Duration seconds when an impulse is received at Tween.
Usage

When an impulse is received at Tween a [Tween (Component)|Tween]] component is created which drives the referenced Target value over the duration.

The To value determines the final value reached at the end of the Duration.


The From value determines the initial value at the start of the Duration.


The Duration input determines how long the transition from From to To takes in seconds. Default is 1.


The CurvePreset determines the shape of the interpolated values. Default is Smooth.


The OnStarted output fires an impulse when tweening of the Target begins as a result of an impulse received at Tween. An impulse will not be fired if there is no valid Target. 
This impulse continues the impulse chain which arrived at Tween.


The OnDone output fires an impulse when tweening of the Target has finished. This does not continue the impulse chain which arrived at Tween.


Note that only one tween operation for the Target can be active at any time. Currently target value changes work via sequential writes to the value which may not appear smooth 
depending on framerates and network latency. Similar, potentially smoother, effects can be achieved with e.g. the various Lerp nodes under Category:LogiX:Math 


}


FrooxEngine.LogiX.Actions.WriteValueNode`1[T]:####################################################################################
{

The <color=#00FF00><b>Write</b></color> node overwrites the referenced Target value with the input Value when an impulse is received at Write.
Usage

When spawned from the node browser, the Value input has a dummy datatype. This will overload to match the input data type when a valid input is connected. 
The input type and that of the referenced Target must match.


The OnDone output fires an impulse when the Target value has been successfully overwritten after an impulse was received at Write or the Target value 
is driven by a system which allows an attempted written variable to be hooked (e.g. Drive node, ValueCopy component, etc.). This impulse continues the 
impulse chain which arrived at Write.


The OnFail output fires an impulse when the Target value could not be set, e.g. if the Target value is driven from another source which does not allow 
hooking of the written value, or if there is no valid Target. This impulse continues the impulse chain which arrived at Write.


Changing the value of a Variable node, Component field etc. via a Write node results in a datamodel change which will then be synchronised to other 
users in the session. Note that changes are only synchronised at the end of every update so, if multiple writes to the same target are performed by a 
single client within an update, only the final value will be sent. Additionally, no changes will be broadcast if the value is reset to the value it held 
at the beginning of an update. Due to this synchronisation process, it is inadvisable to write to a value very regularly (e.g. every update) unless absolutely 
necessary. It is generally better to use the Drive system instead for continuously changing values to avoid unnecessary network traffic. Source.

Generally, with a Write/Write Latch node, one can only write to component or slot fields which are value-typed (e.g. bools, ints, strings, floats), 
whereas reference-typed fields (e.g. slot, user, IAssetProvider<AudioClip> etc.) require Write Ref. However, it is possible to write to reference-typed 
LogiX variable nodes using a Write/Write Latch node where it isn't possible to do so with Write Ref. It is also possible to write to reference-typed fields 
using Write/Write Latch if the input SetValue and ResetValue are RefIDs, rather than reference datatypes - it is generally not recommended to work with raw RefIDs though. 

}

FrooxEngine.LogiX.WriteLatch`1[T]:##################################################################################################
{

The <color=#00FF00><b>Write Latch</b></color> node node overwrites the referenced Target value with the input SetValue or ResetValue when an impulse is received at Set or Reset respectively.
Usage

When spawned from the node browser, the SetValue and ResetValue inputs have a dummy datatype. This will overload to match the input data type when a valid input is connected. 
The type of these two inputs and that of the referenced Target must match.


The OnSet output fires an impulse after an impulse is received at Set. This occurs regardless of whether there is a valid Target or whether any Target was actually written to. 
This continues the impulse chain which arrived at Set.


The OnReset output fires an impulse after an impulse is received at Reset. This occurs regardless of whether there is a valid Target or whether any Target was actually 
written to. This continues the impulse chain which arrived at Reset.


Changing the value of a Variable node, Component field etc. via a Write Latch node results in a datamodel change which will then be synchronised to other users in the session. 
Note that changes are only synchronised at the end of every update so, if multiple writes to the same target are performed by a single client within an update, only the final value 
will be sent. Additionally, no changes will be broadcast if the value is reset to the value it held at the beginning of an update. Due to this synchronisation process, 
it is inadvisable to write to a value very regularly (e.g. every update) unless absolutely necessary. It is generally better to use the Drive system instead for continuously 
changing values to avoid unnecessary network traffic. Source.

Generally, with a Write/Write Latch node, one can only write to component or slot fields which are value-typed (e.g. bools, ints, strings, floats), whereas reference-typed fields 
(e.g. slot, user, IAssetProvider<AudioClip> etc.) require Write Ref. However, it is possible to write to reference-typed LogiX variable nodes using a Write/Write Latch node where 
it isn't possible to do so with Write Ref. It is also possible to write to reference-typed fields using Write/Write Latch if the input SetValue and ResetValue are RefIDs, 
rather than reference datatypes - it is generally not recommended to work with raw RefIDs though.
Examples

These two images illustrate comparable LogiX setups using either one Write Latch node or two Write nodes. Note that the presence of the OnFail impulse output and different 
behaviour of OnDone and OnFail compared with OnSet and OnReset means that the two setups are not exactly identical. 

}


FrooxEngine.LogiX.Actions.WriteReferenceNode`1[T]:#####################################################################################
{

The <color=#00FF00><b>Write Ref</b></color> node overwrites the Reference with a reference to the input Target when an impulse is received at Write.
Usage

When spawned from the node browser, the Target input has a general IWorldElement datatype. It is recommended to overload the node to the 
required datatype by first connecting the Reference output to the target field before connecting an input to Target. This is because any reference type 
can be cast to IWorldElement which is not, generally, the datatype of the intendend target field.


The OnDone output fires an impulse when the Reference target value has been successfully overwritten after an impulse was received at Write or 
the Reference target value is driven by a system which allows an attempted written variable to be hooked (e.g. ReferenceCopy component, etc.). 
This impulse continues the impulse chain which arrived at Write.


The OnFail output fires an impulse when the Reference target value could not be set, e.g. if the Reference target value is driven from another source 
which does not allow hooking of the written value, or if there is no valid Reference target. This impulse continues the impulse chain which arrived at Write.


Changing the value of a Component field etc. via a Write Ref node results in a datamodel change which will then be synchronised to other users in the session. 
Note that changes are only synchronised at the end of every update so, if multiple writes to the same target are performed by a single client within an update, 
only the final value will be sent. Additionally, no changes will be broadcast if the value is reset to the value it held at the beginning of an update. 
Due to this synchronisation process, to avoid unnecessary network traffic it is inadvisable to write to a target very regularly (e.g. every update) unless absolutely necessary . Source.

Generally one should write to component or slot fields which are reference-typed (e.g. slot, user, IAssetProvider<AudioClip> etc.) 
using Write Ref. However, it is not possible to write to reference-typed LogiX variable nodes using a Write Ref node whereas it is 
possible to do so with Write/Write Latch. It is also possible to write to reference-typed fields using Write/Write Latch if the inputs are RefIDs, 
rather than reference datatypes. However, it is generally not recommended to work with raw RefIDs though - better to use Write Ref with the correct datatypes. 

}


FrooxEngine.LogiX.Actions.WriteRefLatch`1[T]:##########################################################################################
{

The <color=#00FF00><b>Write Ref Latch</b></color> node node overwrites the target reference with the input SetReference or ResetReference 
when an impulse is received at Set or Reset respectively.
Usage

When spawned from the node browser, the SetReference and ResetReference have a IWorldElement datatype. This will overload to match the input reference 
type when a valid input is connected. The type of these two inputs and that of the referenced Target must match.


The OnSet output fires an impulse after an impulse is received at Set. This occurs regardless of whether there is a valid Target or whether any 
Target was actually written to. This continues the impulse chain which arrived at Set.


The OnReset output fires an impulse after an impulse is received at Reset. This occurs regardless of whether there is a valid Target or 
whether any Target was actually written to. This continues the impulse chain which arrived at Reset. 

}

































FrooxEngine.LogiX.Assets.AttachAsset`1
FrooxEngine.LogiX.Assets.SampleAnimationTrack`1



FrooxEngine.LogiX.Assets.AttachAudioClip:###############################################################
{
The  <color=#00FF00>Attach Audio Clip</color> node creates an AudioClipProvider component on the Target slot and fills the component's URL field with the input URL.
Usage

If the GetExisting input is True this will not produce components which are exact duplicates of existing ones currently under the slot (i.e. the existing component's URL field is identical to the node's URL input).


The newly attached StaticAudioClip component is available from the AttachedProvider output for the duration of the impulse chain started by OnAttached. 
}


FrooxEngine.LogiX.Assets.AttachMesh:####################################################################
{
The <color=#00FF00>Attach Mesh</color> node creates a StaticMesh component under the Target slot and fills the component's URL field with the input URL.
Usage

If the GetExisting input is True this will not produce components which are exact duplicates of existing ones currently under the slot (i.e. the existing component's URL field is identical to the node's URL input).


The newly attached StaticMesh component is available from the AttachedProvider output for the duration of the impulse chain started by OnAttached. 
}



FrooxEngine.LogiX.Assets.AttachSprite:##################################################################
{
The <color=#00FF00>Attach Sprite</color> node creates a StaticTexture2D component on the Target slot and fills the component's URL field with the input URL. A SpriteProvider component is also created whose Texture field is filled with a reference to the newly created StaticTexture2D component.
Usage

If the GetExisting input is True this will not produce components which are exact duplicates of existing ones currently under the slot (i.e. the existing component's URL field is identical to the node's URL input). The input URL should be for a 2D image asset.


The newly attached SpriteProvider component is available from the AttachedProvider output for the duration of the impulse chain started by OnAttached. 
}




FrooxEngine.LogiX.Assets.AttachTexture2D:###############################################################
{
The <color=#00FF00>Attach Texture2D</color> node creates a StaticTexture2D component under the Target slot and fills the component's URL field with the input URL.
Usage

If the GetExisting input is True this will not produce components which are exact duplicates of existing ones currently under the slot (i.e. the existing component's URL field is identical to the node's URL input).


The newly attached StaticTexture2D component is available from the AttachedProvider output for the duration of the impulse chain started by OnAttached. 
}



FrooxEngine.LogiX.Assets.BakeMeshes:###################################################################
{
The <color=#00FF00>Bake Meshes</color> node creates a new single mesh as a combination of all meshes under the Root input slot's hierarchy. Specific behaviour depends significantly on the input values, see Usage.
Usage

When an impulse is received at Bake, and with all default bool inputs, this node creates a new slot whose name is the name of the original Root input slot with " - Baked" appended. This slot contains MeshRenderer, Grabbable, and MeshCollider components. The MeshRenderer and MeshCollider components' Mesh field is filled with a reference to the newly baked mesh. This is a combination of all meshes previously referenced by enabled MeshRenderer/SkinnedMeshRenderer components under any active slots under the input Root slot's hierarchy. The MeshRenderer component contains references to the materials previously present on the individual meshes; if these are subsequently changed, the changes only affect the part of the baked mesh which was originally affected by the changed material.


If the IncludeInactive input is True (False by default) the baked mesh will also include any meshes on inactive slots under the input Root slot's hierarchy. Inactive meshes will be visible in the final baked mesh.


If the Undoable input is True (False by default), the baking event can be undone using the Undo button on the radial context menu.


If the DestroyOriginal input is False (True by default) the original Root input slot (and all of its children) is not destroyed after baking.


It is recommended to take care with the Undoable and DestroyOriginal options, by default this node will destroy the Root slot, along with its children, in an event which cannot be undone!. It is also important to consider the number of triangles which the eventual baked mesh will contain - MeshColliders for high-poly meshes can impose a significant performance cost. 
}


FrooxEngine.LogiX.Assets.FindAnimationTrackIndex:#######################################################
{
The <color=#00FF00>Find Animation Track Index</color> node finds the index of an animation track based on the input node and property names. 
}




FrooxEngine.LogiX.Assets.FormatLocaleString:############################################################
{
The <color=#00FF00>Format Locale String</color> node displays a given key's localized text according to the provided locale.
}



FrooxEngine.LogiX.Assets.GetTexture2D_Pixel:############################################################
{
The <color=#00FF00>Get Texture 2D Pixel</color> node returns the color of a pixel by locating it on the input 2D texture according to the specified position. This node is distinct from from the Sample Texture2D UV node as it accepts an int2 instead of an float2; this ensures the sampling remains constrained to individual pixels rather than being interpolated across pixels.
Usage

Texture is the texture you want to sample a pixel from. Position is the 2D coordinate (starting from the bottom left of the texture) of the pixel you want to return the color value of.

}



FrooxEngine.LogiX.Assets.GetTexture3D_Pixel:###########################################################
{
The <color=#00FF00>Get Texture 3D Pixel</color> node returns the color of a pixel by locating it on the input 3D texture according to the specified position. This node is distinct from from the Sample Texture3D UVW node as it accepts an int3 instead of an float3; this ensures the sampling remains constrained to individual pixels rather than being interpolated across pixels.
Usage

Texture is the texture you want to sample a pixel from. Position is the 3D coordinate (starting from the bottom left of the texture) of the pixel you want to return the color value of.

}



FrooxEngine.LogiX.Assets.LocaleMessageCount:###########################################################
{
The <color=#00FF00>Locale Message Count</color> node outputs the number of messages for the input locale.

Usage

Locale is the locale you want to get the message count of. Count is the message count of the locale. 
}




FrooxEngine.LogiX.Assets.SampleTexture2D_UV:###########################################################
{
The <color=#00FF00>Sample Texture2D UV</color> node samples the color of a pixel by locating it on the input 2D texture according to the specified position in UV space. This node is distinct from from the Get Texture 2D Pixel node as it accepts a float2 instead of an int2; this lets the sampling be interpolated across pixels rather than being constrained to individual pixels.
Usage

Texture is the texture you want to sample a pixel from. Position is the coordinate of the point you want to sample in UV space, where the components of the input float2 range from 0.0 to 1.0. WrapMode defines whether the texture should wrap around UV space.

}



FrooxEngine.LogiX.Assets.SampleTexture3D_UVW:##########################################################
{
The <color=#00FF00>Sample Texture3D UVW</color> node samples the color of a pixel by locating it on the input 3D texture according to the specified position in UVW space. This node is distinct from from the Get Texture 3D Pixel node as it accepts a float3 instead of an int3; this lets the sampling be interpolated across pixels rather than being constrained to individual pixels.
Usage

Texture is the texture you want to sample a pixel from. Position is the coordinate of the point you want to sample in UVW space, where the components of the input float3 range from 0.0 to 1.0.

}



FrooxEngine.LogiX.Assets.Texture2D_Format:#############################################################
{
The <color=#00FF00>Texture 2D Format</color> node provides specific information about the input texture.

Usage

Texture is the input texture you want to use. Size is the texture's width and height. Format is the formatting type of the texture. MipMapCount is the number of mip maps the texture is using. 
}



FrooxEngine.LogiX.Assets.Texture3D_Format:#############################################################
{
The <color=#00FF00>Texture 3D Format</color> node provides specific information about the input 3D texture.

Usage

Texture is the input texture you want to use. Size is the size of the texture. Format is the formatting type of the texture.
}














FrooxEngine.LogiX.Audio.AudioClipInput:#################################################################
{
The <color=#00FF00>Audio Clip</color> node stores a reference to a an audio file for use with Play One Shot (LogiX node) and Play One Shot & Wait (LogiX node).

Usage

The easiest way to store a reference to an audio clip with this node is to grab an audio player orb and release while the laser is hovering over the Audio Clip Input node - essentially "drag and drop". If the node has a reference stored it will display the clip name on the node's visual. 

}


FrooxEngine.LogiX.Audio.PlayOneShot:####################################################################
{
The <color=#00FF00>Play One Shot</color> node plays the input Clip once when an impulse is received at Play. The manner in which the clip is played is highly configurable.

Usage
Inputs

The Clip input determines which clip will be played. The easiest method to specify this is to use an Audio Clip Input node.


The Volume controls the base volume with which the clip is played. Default is 1, i.e. full volume.


The Speed controls the speed with which the clip is played. Default is 1, i.e. standard playback speed.


The Spatialize input determines whether the audio source is spatialized within the world (i.e it sounds like it originates from a specific point) or non-spatialized. Note that this value can be overridden if the SpatialBlend is specified. Default is True.


The SpatialBlend input can be used to set an intermediate spatialization value. A value of 0 results in completely non-spatialized playback, a value of 1 results in fully spatialized playback, and values between these extremes result in the playback being partially spatialized. Note that this value, if specified, will override any Spatialize input. Default is 1.


The Point sets the origin point from which any spatialized audio will originate. This is interpreted as [X;Y;Z] coordinates in the local coordinate space of the Root input slot. Default is [0;0;0].


The Root input sets the slot relative to whose local coordinate space the Point value is interpreted. Default is the Play One Shot node's slot.


The Priority input sets the priority level of the spawned audio output. In the event too many audio outputs are present in a world, this is used to select which outputs are silenced. Higher priority outputs (i.e. priority number is lower) take precedence over ones with lower priority. Default is 128 (medium priority, lowest possible value is 256).


The Doppler input determines the strength of the simulated Doppler effect. Default is 1 (i.e. Doppler effect is applied), set this to 0 to disable.


The MinDistance input determines the distance (in metres) from the sound source at which volume rolloff begins. This only takes effect if the Rolloff value is Linear. Note that this input value is scaled depending on the DistanceSpace input - if that is set to Global then the MinDistance value is interpreted in global coordinate space, if set to Local it is interpeted in local coordinate space which may then be affected by the scale of the audio output. Default is 1.


The MaxDistance input determines the distance (in metres) from the sound source at which volume rolloff ends and the sound becomes inaudible. This only takes effect if the Rolloff value is Linear. Note that this input value is scaled depending on the DistanceSpace input - if that is set to Global then the MinDistance value is interpreted in global coordinate space, if set to Local it is interpeted in local coordinate space which may then be affected by the scale of the audio output. Default is 500.


The Rolloff input determines the volume rolloff mode used for the audio output. This must be set to Linear for MinDistance and MaxDistance to take effect. Default is Logarithmic.


The Group input determines what volume group the played audio is categorized under. Default is Sound Effects.


The DistanceSpace input determines whether scale and distance values are interpreted relative to global coordinates or local coordinates. Default is Global.


The MinScale input determines the MinScale field value on the spawned AudioOutput.


The MaxScale input determines the MaxScale field value on the spawned AudioOutput.


The ParentUnderRoot input determines whether the spawned "OneShotAudio" slot is parented directly under the input Root slot. If set to False, the "OneShotAudio" slot will be parented under the world root slot. Default is True.


The LocalOnly input determines whether the played audio will only be audible for the local user who owns the impulse arriving at Play. Default is False.
Outputs

The OnStartedPlaying output fires an impulse when the one shot audio has started playing as a result of an impulse at Play. This fires as long as a valid Clip input is present and continues the impulse chain which arrived at Play.
Notes

When an impulse is received at Run, and a valid Clip is available, a new non-persistent slot is spawned called "OneShotAudio" with AudioOutput, AudioClipPlayer, and StoppedPlayableCleaner components. This slot is automatically deleted when playback ends.

Play One Shot is an excellent playback option for audio which should play to completion after some trigger. This is because it prevents cluttering the limited audio buffer unless the relevant sound effect is actually playing. Play One Shot may not be ideal for situations where triggers occur extremely rapidly (e.g. in the case of an automatic weapon) due to the network traffic required to spawn and delete slots and components. In situations like those, consider using a persistent AudioOutput and AudioClipPlayer and using nodes under Category:LogiX:Playback instead. 

}


FrooxEngine.LogiX.Audio.PlayOneShotAndWait:############################################################
{
The <color=#00FF00>Play One Shot & Wait</color> node plays the input Clip when an impulse is received at Play. The difference from Play One Shot (LogiX node) is the additional OnFinishedPlaying impulse output. 

Usage
Inputs

The Clip input determines which clip will be played. The easiest method to specify this is to use an Audio Clip Input node.


The Volume controls the base volume with which the clip is played. Default is 1, i.e. full volume.


The Speed controls the speed with which the clip is played. Default is 1, i.e. standard playback speed.


The Spatialize input determines whether the audio source is spatialized within the world (i.e it sounds like it originates from a specific point) or non-spatialized. Note that this value can be overridden if the SpatialBlend is specified. Default is True.


The SpatialBlend input can be used to set an intermediate spatialization value. A value of 0 results in completely non-spatialized playback, a value of 1 results in fully spatialized playback, and values between these extremes result in the playback being partially spatialized. Note that this value, if specified, will override any Spatialize input. Default is 1.


The Point sets the origin point from which any spatialized audio will originate. This is interpreted as [X;Y;Z] coordinates in the local coordinate space of the Root input slot. Default is [0;0;0].


The Root input sets the slot relative to whose local coordinate space the Point value is interpreted. Default is the Play One Shot node's slot.


The Priority input sets the priority level of the spawned audio output. In the event too many audio outputs are present in a world, this is used to select which outputs are silenced. Higher priority outputs (i.e. priority number is lower) take precedence over ones with lower priority. Default is 128 (medium priority, lowest possible value is 256).

The Doppler input determines the strength of the simulated Doppler effect. Default is 1 (i.e. Doppler effect is applied), set this to 0 to disable.


The MinDistance input determines the distance (in metres) from the sound source at which volume rolloff begins. This only takes effect if the Rolloff value is Linear. Note that this input value is scaled depending on the DistanceSpace input - if that is set to Global then the MinDistance value is interpreted in global coordinate space, if set to Local it is interpeted in local coordinate space which may then be affected by the scale of the audio output. Default is 1.


The MaxDistance input determines the distance (in metres) from the sound source at which volume rolloff ends and the sound becomes inaudible. This only takes effect if the Rolloff value is Linear. Note that this input value is scaled depending on the DistanceSpace input - if that is set to Global then the MinDistance value is interpreted in global coordinate space, if set to Local it is interpeted in local coordinate space which may then be affected by the scale of the audio output. Default is 500.


The Rolloff input determines the volume rolloff mode used for the audio output. This must be set to Linear for MinDistance and MaxDistance to take effect. Default is Logarithmic.


The Group input determines what volume group the played audio is categorized under. Default is Sound Effects.


The DistanceSpace input determines whether scale and distance values are interpreted relative to global coordinates or local coordinates. Default is Global.


The MinScale input determines the MinScale field value on the spawned AudioOutput.


The MaxScale input determines the MaxScale field value on the spawned AudioOutput.


The ParentUnderRoot input determines whether the spawned "OneShotAudio" slot is parented directly under the input Root slot. If set to False, the "OneShotAudio" slot will be parented under the world root slot. Default is True.


The LocalOnly input determines whether the played audio will only be audible for the local user who owns the impulse arriving at Play. Default is False.
Outputs

The OnStartedPlaying output fires an impulse when the one shot audio has started playing as a result of an impulse at Play. This fires as long as a valid Clip input is present and continues the impulse chain which arrived at Play.


The OnfinishedPlaying output fires an impulse when the one shot audio has finished playing. This does not continue the impulse chain which arrived at Play.
Notes

When an impulse is received at Run, and a valid Clip is available, a new non-persistent slot is spawned called "OneShotAudio" with AudioOutput, AudioClipPlayer, and StoppedPlayableCleaner components. This slot is automatically deleted when playback ends.

Play One Shot is an excellent playback option for audio which should play to completion after some trigger. This is because it prevents cluttering the limited audio buffer unless the relevant sound effect is actually playing. Play One Shot may not be ideal for situations where triggers occur extremely rapidly (e.g. in the case of an automatic weapon) due to the network traffic required to spawn and delete slots and components. In situations like those, consider using a persistent AudioOutput and AudioClipPlayer and using nodes under Category:LogiX:Playback instead. 
}


Avatar Folder Root:

FrooxEngine.LogiX.Avatar.BodyNodeSlot:##################################################################
{
The <color=#00FF00>Body Node Slot</color> node outputs the NodeSlot slot corresponding to the input Node on the avatar of the Source user.
Usage

The Source input defaults to the local user - meaning that the NodeSlot output would be different on each user's client.


In the case of the default Node input, or if there is no corresponding slot for the input on the Source user's avatar, the NodeSlot output is null. 
}


FrooxEngine.LogiX.Avatar.DefaultUserScale:##############################################################
{
The <color=#00FF00>Default User Scale</color> node gets the input user's default scale. 
}



FrooxEngine.LogiX.Avatar.EquipAvatar:###################################################################
{
The <color=#00FF00>Equip Avatar</color> node equips the avatar given by the AvatarRoot input for the input User when an impulse is received. 

Usage

This node equips the avatar for the user without moving the user - this behavior is akin to equipping an avatar from the inventory directly instead of equipping an avatar spawned into the world. If DestroyOld is True the user's previously equipped avatar is destroyed once the new avatar is equipped. 
}


FrooxEngine.LogiX.Avatar.FingerPose:####################################################################
{
The <color=#00FF00>Finger Pose</color> node.

Usage

Allows you to pull the transform without the scale of the fingers. 
}


FrooxEngine.LogiX.Avatar.NearestUserHand:###############################################################
{
The color=#00FF00>Nearest User Hand</color> node.


Usage

Allows you to get the nearest hand slot and which hand it is to the references slot and if there is nothing in the references slot it uses itself as the references. 
}

FrooxEngine.LogiX.Avatar.NearestUserHead:###############################################################
{
The <color=#00FF00>Nearest User Head</color> node.


Usage

Allows you to get the nearest head slot on an occupied avatar to the center of the referenced slot. If there is nothing in the reference slot the node will use itself as the reference. Operates very similar to Nearest User Hand (LogiX node) except for finding a head instead of hand.
}


FrooxEngine.LogiX.Avatar.UserFingerPoseSource:##########################################################
{
The <color=#00FF00>User Finger Pose Source</color> node.

Usage

Allows you to get the IFingerPoseSource from a user. 

}


######/Anchors############

FrooxEngine.LogiX.Avatar.AnchorEvents:##################################################################
{
The <color=#00FF00>Anchor Events</color> node fires an impulse from OnAnchored when a user enters the referenced input AvatarAnchor and fires an impulse from OnReleased when a user exits the anchor.


Usage

A reference to the user either entering or exiting the anchor is available for the duration of the impulse chain triggered from OnAnchored or OnReleased. 
}



FrooxEngine.LogiX.Avatar.AnchorLocomotionData:#########################################################
{
The <color=#00FF00>Anchor Locomotion Data</color> node.


Usage

LocomotionUpdate is an impulse that fires every time one of the values is updated. It also returns the user inputs on the anchor. 
}


FrooxEngine.LogiX.Avatar.AnchorUser:###################################################################
{
The <color=#00FF00>Anchor User node</color> anchors the input User at the input Anchor when an impulse is received at DoAnchor. 

Usage

Allows you to put a user on an Anchor. 
}




FrooxEngine.LogiX.Avatar.AnchoredUser:#################################################################
{
The <color=#00FF00>Anchored User</color> node outputs a reference to the user anchored at the referenced input Anchor.

Usage

Default output if a user is not anchored at Anchor is null. 
}


FrooxEngine.LogiX.Avatar.GetUserAnchor:################################################################
{
The <color=#00FF00>Get User Anchor</color> node outputs a reference to the anchor at which the input User is anchored.

Usage

Default output if the User is not anchored is null. 
}


FrooxEngine.LogiX.Avatar.IsUserAnchored:###############################################################
{
The <color=#00FF00>Is User Anchored</color> node outputs a boolean value depending on whether the input User is anchored.


Usage

Allows you to check if a user is in an Anchored. 
}



FrooxEngine.LogiX.Avatar.ReleaseUser:##################################################################
{
The <color=#00FF00>Release User</color> node releases a user from the referenced Anchor when an impulse is received at DoRelease.

Usage

An impulse will not be fired from OnReleased unless a user was released as a result of an impulse at DoRelease. 
}



#########/BodyNode#################

FrooxEngine.LogiX.Utility.BodyNodeChirality:###########################################################
{
The <color=#00FF00>Chirality</color> node outputs the chirality value (Left/Right) of the input Node.
Usage

For body nodes which do not have a chirality (e.g. Hips) the output is -1. 
}



FrooxEngine.LogiX.Utility.ComposeFinger:###############################################################
{
The <color=#00FF00>Compose Finger</color> node output the BodyNode corresponding to the input Finger, Segment, and Chirality values.

Usage

Default values for Finger, Segment, and Chirality are Thumb, Metacarpal, and Left respectively. Therefore the default output value is LeftThumb_Metacarpal. 
}


FrooxEngine.LogiX.Utility.FingerNodeIndex:#############################################################
{
The <color=#00FF00>Finger Node Index</color> node outputs the integer value corresponding to the input Node regardless of it's chirality.
Usage

Node to int mappings are:

    Thumb_Metacarpal - 0
    Thumb_Proximal - 1
    Thumb_Distal - 2
    Thumb_Tip - 3
    IndexFinger_Metacarpal - 4
    IndexFinger_Proximal - 5
    IndexFinger_Intermediate - 6
    IndexFinger_Distal -7
    IndexFinger_Tip - 8
    MiddleFinger_Metacarpal - 9
    MiddleFinger_Proximal - 10
    MiddleFinger_Intermediate - 11
    MiddleFinger_Distal - 12
    MiddleFinger_Tip - 13
    RingFinger_Metacarpal - 14
    RingFinger_Proximal - 15
    RingFinger_Intermediate - 16
    RingFinger_Distal - 17
    RingFinger_Tip - 18
    Pinky_Metacarpal - 19
    Pinky_Proximal - 20
    Pinky_Intermediate - 21
    Pinky_Distal - 22
    Pinky_Tip - 23

To convert these int values into their BodyNode Enum equivalents, add 19 for Left side or 48 for right side. 
}


FrooxEngine.LogiX.Utility.GetFingerSegmentType:########################################################
{
The <color=#00FF00>Finger Segment</color> node outputs the finger segment name for the given Node.
Usage

Possible output values, if the input Node is a finger, are: Metacarpal, Proximal, Intermediate, Distal, or Tip.

The value is -1 for all Node values which are not fingers.

}



FrooxEngine.LogiX.Utility.GetFingerType:###############################################################
{
The <color=#00FF00>Finger Type</color> node outputs the finger type value for the input Node.
Usage

Possible output values, if the input Node is a finger, are: Thumb, Index, Middle, Ring, or Pinky.

The value is -1 for all Node values which are not fingers. 
}


FrooxEngine.LogiX.Utility.GetBodyNodeSide:#############################################################
{
The <color=#00FF00>Get Side</color> node outputs the BodyNode value corresponding to the input Node with the specified Side.
Usage

For any input Node which has a chirality, this outputs either that Node value or the corresponding one with the opposite chirality depending on the input Side. If the input Node has no chirality the output is NONE.

For example, with the input Node LeftController and Side Left the output will be LeftController. However, with the input Node LeftController and Side Right the output will be RightController 
}




FrooxEngine.LogiX.Utility.IsBodyNodeEye:###############################################################
{
The <color=#00FF00>Is Eye</color> node outputs True if the input Node is either LeftEye or RightEye, otherwise False. 
}



FrooxEngine.LogiX.Utility.GetBodyNodeOtherSide:########################################################
{
The <color=#00FF00>Other Side</color> node outputs the BodyNode corresponding to the Node with opposite chirality.

Usage

For example, if Node is LeftController, the output is RightController. For input Node values without a chirality the output is NONE. 
}


FrooxEngine.LogiX.Utility.RelativeBodyNode:############################################################
{
The <color=#00FF00>Relative Body Node</color> node outputs the Root BodyNode unless the Node is an Eye, Palm, or Finger node.

Usage

If the input Node is an Eye the output is Head. If it is either a Palm or Finger the output is the Hand of the same chirality. If the input is NONE, so is the output. 
}







FrooxEngine.LogiX.Color.ColorHue:################################################################
{
Generates a color using hue from a float value ranging from 0 to 1. (0 is 0 degrees 1 is 360 degrees)

If the provided value is above 1 or below 0 it will be looped similarly to how the repeat node works.
}


FrooxEngine.LogiX.Color.HSV_ToColor:################################################################
FrooxEngine.LogiX.Color.HSL_ToColor
{
Converts 3 float values into a color using either the HSV or HSL format, inputs should be ranging from 0 to 1.

If you would like to learn more about the HSV and HSL formats you can look it up online.
}

FrooxEngine.LogiX.Color.ColorSetRed:################################################################
FrooxEngine.LogiX.Color.ColorSetGreen
FrooxEngine.LogiX.Color.ColorSetBlue
FrooxEngine.LogiX.Color.ColorSetAlpha
FrooxEngine.LogiX.Color.ColorSetHue
FrooxEngine.LogiX.Color.ColorSetSaturation
FrooxEngine.LogiX.Color.ColorSetValue
{
Sets a certain channel of a color to the provided value.
}

FrooxEngine.LogiX.Color.ColorMulRed:################################################################
FrooxEngine.LogiX.Color.ColorMulGreen
FrooxEngine.LogiX.Color.ColorMulBlue
FrooxEngine.LogiX.Color.ColorMulRGB
FrooxEngine.LogiX.Color.ColorMulAlpha
FrooxEngine.LogiX.Color.ColorMulHue
FrooxEngine.LogiX.Color.ColorMulSaturation
FrooxEngine.LogiX.Color.ColorMulValue
{
Multiplies a certain channel of a color by the provided value.
}

FrooxEngine.LogiX.Color.ColorAddRed:################################################################
FrooxEngine.LogiX.Color.ColorAddGreen
FrooxEngine.LogiX.Color.ColorAddBlue
FrooxEngine.LogiX.Color.ColorAddRedHDR
FrooxEngine.LogiX.Color.ColorAddGreenHDR
FrooxEngine.LogiX.Color.ColorAddBlueHDR
FrooxEngine.LogiX.Color.ColorAddAlpha
FrooxEngine.LogiX.Color.ColorAddHue
FrooxEngine.LogiX.Color.ColorAddSaturation
FrooxEngine.LogiX.Color.ColorAddValue
FrooxEngine.LogiX.Color.ColorAddValueHDR
{
Adds the provided value to a certain channel of the color.

HDR Variants of these nodes do nothing, except for Add Value which will clamp the RGB values between 0 and 1 while the HDR variant ignores this restriction.
}

FrooxEngine.LogiX.Color.ColorLuminance:################################################################
{
Calculates the luminance of a color.

This is done by multiplying the red channel by 0.2126, the green channel by 0.7152 and the blue channel by 0.0722 and adding the 3 resulting values together.
}
FrooxEngine.LogiX.Color.ColorAlphaBlend:################################################################
// TODO Add better descirption here
{
Determines how 2 colors would be combined in an alpha blend environment.
}
FrooxEngine.LogiX.Color.ColorAdditiveBlend:################################################################
{
Determines how 2 colors would be combined in an additive environment.

This is done by adding the RGBA values together, then limiting the alpha channel to not exceed 1, this limitation is not applied in the negative direction.
}
FrooxEngine.LogiX.Color.ColorMultiplicativeBlend:################################################################
{
Determines how 2 colors would be combined in a multiplicative environment.

This is done by multiplying each channel together.
}
FrooxEngine.LogiX.Color.ColorSoftAdditiveBlend:################################################################
{
Determines how 2 colors would be combined in a soft additive environment.

Assuming that the first input is labelled A and the 2nd one B the formula for this operation goes as follows:
((1 - B.rgb) * A.rgb) + B.rgb
The alpha channel is simply added together, but limited to not exceed 1.
}
FrooxEngine.LogiX.Color.BlackBodyColor:################################################################
{
Determines what color a blackbody would be under a certain amount of temperature (in Kelvin).
}

FrooxEngine.LogiX.Color.ColorToHSL:################################################################
{
The <color=#00FF00>To HSL</color> takes an input color C and decomposes it into the 
corresponding H (hue), S (saturation) and L (lightness) values.

Usage

HSL format is an alternative way to specify colors in the RBG colorspace - see HSL and HSV.


Note that the default input is [0,0,0,0] which gives default output of H = NaN, S = 0 and V = 0. Values of [0,0,0,*] or [1,1,1,*] give NaN as the H output which has the potential to cause unexpected behavior with downstream calculations etc. 
}



FrooxEngine.LogiX.Color.ColorToHSV:################################################################
{
The <color=#00FF00>To HSV</color> takes an input color C and decomposes it into the 
corresponding H (hue), S (saturation) and V (value) values.

Usage

HSV format is an alternative way to specify colors in the RBG colorspace - see HSL and HSV.


Note that the default input is [0,0,0,0] which gives default output of H = NaN, S = 0 and L = 0. 
Values of [0,0,0,*] or [1,1,1,*] give NaN as the H output which has the potential to cause unexpected behavior with downstream calculations etc. 
}



FrooxEngine.LogiX.Color.ColorFromHexCode:##########################################################
{
The <color=#00FF00>Color From Hex Code</color> node outputs a color corresponding to the input HexCode.
Usage

Hexadecimal color codes are commonly used to specify RGB(A) colors in text format, particularly for 
usage on webpages and rich text.


The input HexCode string can include, but does not require, a leading #. If there are only 3 hex values 
(i.e. only RGB is specified) the output alpha value is 1.


The Parsed output indicates whether the HexCode can be successfully parsed to a color.


The default output color is [0,0,0,0] which corresponds to completely transparent black. 
This is output whenever the input cannot be parsed as a valid HexCode. 
}


FrooxEngine.LogiX.Color.ColorToHexCode:##############################################################
{
The <color=#00FF00>Color To Hex Code</color> node outputs a hexadecimal code corresponding to the input RGB(A) Color.
Usage

Default Color output is #000000 which corresponds to black.


If IncludeAlpha is True (False by default) a trailing fourth pair of hexadecimal values is added which encodes the alpha input value.


If ShortForm is True (false by Default) the output corresponding to each of R, G and B (and alpha if IncludeAlpha is True) is scaled and rounded so as to be represented as a single hexadecimal digit.


The Prefix input is prepended to the output string (# by default). 
}


FrooxEngine.LogiX.Color.InvertColor:################################################################
{
The <color=#00FF00>Invert</color> node inverts the RGB channels of the input color.
}


Math.Time.DatetimeMillisecondNode
Math.Time.DatetimeSecondNode
Math.Time.DatetimeMinuteNode
Math.Time.DatetimeHourNode
Math.Time.DatetimeDayNode
Math.Time.DatetimeMonthNode
Math.Time.DatetimeYearNode
Math.Time.DatetimeTicksNode
Math.Time.DatetimeDayOfWeekNode
Math.Time.DatetimeDayOfYearNode
{
Extracts a specific unit (such as days or seconds) from a DateTime.
}
Math.Time.TimespanTicksNode
Math.Time.TimespanMillisecondsNode
Math.Time.TimespanSecondsNode
Math.Time.TimespanMinutesNode
Math.Time.TimespanHoursNode
Math.Time.TimespanDaysNode
Math.Time.TimespanTotalMillisecondsNode
Math.Time.TimespanTotalSecondsNode
Math.Time.TimespanTotalMinutesNode
Math.Time.TimespanTotalHoursNode
Math.Time.TimespanTotalDaysNode
{
Extracts a specific unit (such as days or seconds) from a TimeSpan.
}
Math.Time.ConstructDateTime
{
Creates a DateTime from a bunch of inputs such as days or seconds.
Also allows changing the "Kind" which can be either "Unspecified", "Utc" or "Local", this will change how the DateTime is displayed to other users.
}
Math.Time.DatetimeKindNode
{
Gets the kind of a DateTime.
The kind can be either "Unspecified", "Utc" or "Local", this will change how the DateTime is displayed to other users.
}
Math.Time.SetDatetimeKindNode
{
Changes the kind of a DateTime.
The kind can be either "Unspecified", "Utc" or "Local", this will change how the DateTime is displayed to other users.
}
Math.Time.FromUnixSeconds
Math.Time.FromUnixMilliseconds
{
Converts unix (mili)seconds into a DateTime.

Unix time is time since January 1st 1970.
}
Math.Time.ToUnixSeconds
Math.Time.ToUnixMilliseconds
{
Converts a DateTime into unix (mili)seconds.

Unix time is time since January 1st 1970.
}
Math.Time.ToUniversalTime
{
Converts a DateTime to use the Utc kind, which means each user will see it the same way.
}
Math.Time.ToLocalTime
{
Converts a DateTim to use the Local kind, which means each user will see it in their own timezone.
}


Math.Time.LocalTimeOffset
Math.Time.UserTimeOffset
{
Provides the time zone offset of a certain user.
}
Math.Time.UserTime
{
Provides the time for a certain user, for example if it's 8 AM in the plugged in user's timezone it will say 8 AM for everyone else too.
}

FrooxEngine.LogiX.ProgramFlow.OnActivatedNode:##################################################################################################################################
{

The <color=#00FF00>On Activated</color> node fires an impulse when the node becomes active.
Usage

This node fires an impulse whenever the slot which contains the OnActivatedNode component becomes active in the world. 
As such, if the containing slot is itself active, but is globally inactive due to an inactive parent, the node will fire when the inactive parent becomes active. 
If, however, the slot containing the OnActivatedNode component is itself inactive the node will ignore all activation events for parent slots until it itself becomes active again. 
This impulse fires for all users unless the OnlyHost input is True. 

}


FrooxEngine.LogiX.ProgramFlow.OnDeactivatedNode:##################################################################################################################################
{

The <color=#00FF00>On Deactivated</color> node fires an impulse when the node becomes inactive.
Usage

This node fires an impulse whenever the slot which contains the OnDectivatedNode component becomes inactive in the world. 
As such, even if the containing slot is itself active, but is globally inactivated due to an parent becoming inactivated, the node will fire. 
If the slot containing the OnDectivatedNode component is itself inactive the node will ignore all deactivation events for parent slots until it itself becomes active again. 
This impulse fires for all users unless the OnlyHost input is True.
}


FrooxEngine.LogiX.ProgramFlow.OnDestroyNode:##################################################################################################################################
{

The <color=#00FF00>On Destroy</color> node fires an impulse as the node is destroyed.
Usage

The impulse from this node fires as it is destroyed, therefore any values or references held under the destroyed hierarchy are not available to nodes 
activated by this impulse chain since they no longer exist. This impulse fires for all users unless the OnlyHost input is True. 

}


FrooxEngine.LogiX.ProgramFlow.OnDestroyingNode:##################################################################################################################################
{

The <color=#00FF00>On Destroying</color> nodefires an impulse just before the node is destroyed.
Usage

The impulse from this node fires just before it is destroyed, therefore any values or references held under the hierarchy about to be destroyed are 
still available to nodes activated by this impulse chain. The impulse fires for the user who triggered the destroy event. 

}


FrooxEngine.LogiX.ProgramFlow.OnDuplicateNode:##################################################################################################################################
{

The <color=#00FF00>On Duplicate</color> node fires an impulse after it is created in a duplication event.
Usage

When an On Duplicate node is duplicated, only the newly created node fires an impulse. This includes duplication via the radial context menu, 
duplicate button in the slot inspector panel, and the Duplicate Slot LogiX node. The impulse fires for the user who triggered the duplication event. 

}


FrooxEngine.LogiX.ProgramFlow.OnLoadedNode:##################################################################################################################################
{

The <color=#00FF00>On Loaded</color> node fires an impulse whenever the node is loaded from a saved instance. The impulse fires once for the relevant user 
(i.e. one who spawned the object etc).
Usage

Events which trigger this node include

    Spawning from the inventory
    Loading as part of a world opening
    Re-loading due to an undo / redo action etc

Note that this node does not check whether assets in its hierarchy have fully loaded.
Examples

The impulse from this node can be used to reliably save the user who spawns it's parent object from their inventory if the Loaded impulse chain writes the local user to a variable. 
Alternatively, use the Allocating User node.


}



FrooxEngine.LogiX.ProgramFlow.OnPasteNode:##################################################################################################################################

{

The <color=#00FF00>On Paste</color> node fires an impulse whenever the node is Pasted.
Usage

In the context of this node, 'pasting' is when an object is transferred from one world session to another. The impulse is fired for the user who pastes the object. 

}


FrooxEngine.LogiX.ProgramFlow.OnSavingNode:##################################################################################################################################
{

The <color=#00FF00>On Saving</color> node fire an impulse when it is saved.
Usage

Saving events include saving the node as part of an object to a user's inventory or saving the current world state. The impulse fires for the user who triggered the save event. 

}



FrooxEngine.LogiX.ProgramFlow.OnStartNode:##################################################################################################################################
{

The <color=#00FF00>On Start</color> node fires an impulse whenever the node is initialized. This happens locally for each user, 
unless the Only Host input is set to True, in which case it will only fire for the Host User.
Usage

Events which trigger this node include

    Spawning from the inventory
    On world start
    A new user joining the world
    On duplication
    Re-loading due to an undo / redo action etc

}



FrooxEngine.LogiX.ProgramFlow.BooleanToggle:##################################################################################################################################

{

The <color=#00FF00>Boolean Latch</color> node stores a Boolean value which can be set, reset or toggled by input impulses.
Usage

The Set impulse input changes the stored bool value to True when an impulse is received.


The Reset impulse input changes the stored bool value to False when an impulse is received.


The Toggle impulse input toggles the stored bool value when an impulse is received.


The OnSet output fires an impulse whenever the stored bool is set to True as a result of an impulse received at Set or Toggle. An impulse will be fired if an impulse 
is received at Set regardless of whether the stored value was actually changed.


The OnReset output fires an impulse whenever the stored bool is set to False as a result of an impulse received at Reset or Toggle. An impulse will be fired 
if an impulse is received at Reset regardless of whether the stored value was actually changed.


The * output provides the value of the stored bool. 

}


FrooxEngine.LogiX.ProgramFlow.DelayNode:##################################################################################################################################
{

The <color=#00FF00>Delay</color> node is used to fire an impulse from Impulse after Delay seconds have elapsed following an impulse received at Trigger.
Usage

The Delay input sets the number of seconds which must elapse before the delayed impulse is fired from Impulse. The default value is 0 which results in a delay of 1 frame update.


The OnTrigger output fires an impulse immediately after an impulse is received at Trigger. This continues the impulse chain which arrived at Trigger.


The delayed impulses do not continue the impulse chain which arrived at Trigger and any temporary values present will have been lost - if a temporary value must be stored 
until the delayed impulse is fired use Delay With Value. Each impulse which arrives at Trigger sets up a separate delayed impulse and multiple can be queued at once with 
different delay durations. If a user focuses a different world while they have delayed impulses queued, the delayed impulses will fire as normal. However, if a user with 
delayed impulses leave the world entirely, their delayed impulses will never fire.
Examples

}



FrooxEngine.LogiX.ProgramFlow.DelayWithValueNode`1[T]:##################################################################################################################################

{

The <color=#00FF00>Delay with value</color> node is used to fire an impulse from Impulse after Delay seconds have elapsed following an impulse received at Trigger. 
Additionally a value can be stored over the delay.
Usage

The Delay input sets the number of seconds which must elapse before the delayed impulse is fired from Impulse. The default value is 0 which results in a delay of 1 frame update.


The Value input value at the moment an impulse is received at Trigger is stored. When the node is spawned from the node browser this accepts a 'dummy' datatype, 
however the node will overload to accept any specific input datatype when a wire is connected.


The OnTrigger output fires an impulse immediately after an impulse is received at Trigger. This continues the impulse chain which arrived at Trigger. 
If a user focuses a different world while they have delayed impulses queued, the delayed impulses will fire as normal. However, if a user with delayed 
impulses leave the world entirely, their delayed impulses will never fire.


The DelayedValue output provides the value at the Value input when the delayed impulse was queued. This is only available for the duration of the impulse chain started by Impulse.


The delayed impulses do not continue the impulse chain which arrived at Trigger and any temporary values, other than that the single stored value will be lost. 
Each impulse which arrives at Trigger sets up a separate delayed impulse with corresponding stored value and multiple can be queued at once with different delay 
durations and stored values.

}

FrooxEngine.LogiX.ProgramFlow.DynamicImpulseReceiver:##################################################################################################################################

{

The <color=#00FF00>Dynamic Impulse Receiver</color> node fires an impulse whenever a Dynamic Impulse Trigger is triggered and the receiver node is present under the 
trigger's TargetHierarchy. This will only occur if the Tag string inputs of the trigger and receiver are identical.
Usage

Note that the tag system for dynamic impulse triggers / receivers is completely unrelated to slot tag properties. This node will only respond to Dynamic 
Impulse Triggers - it ignores dynamic impulses from Dynamic Impulse Trigger With Value`1 nodes. 


}


FrooxEngine.LogiX.ProgramFlow.DynamicImpulseReceiverWithValue`1[System.Boolean]:##################################################################################################################################
{

The <color=#00FF00>Dynamic Impulse Receiver With Value`1</color> node fires an impulse whenever a Dynamic Impulse Trigger With Value`1 is triggered and the receiver node is present 
under the trigger's TargetHierarchy. This will only occur if the Tag string inputs of the trigger and receiver are identical. The Value output by the receiver node is equal to 
the Value input of the trigger node at the moment it was triggered.
Usage

Note that the tag system for dynamic impulse triggers / receivers is completely unrelated to slot tag properties. This node will only respond to Dynamic Impulse Trigger With Value`1 
nodes with identical Value datatypes - it ignores dynamic impulses from Dynamic Impulse Trigger nodes or Dynamic Impulse Trigger With Value`1 nodes with different Value datatypes. 
The output Value is only equal to the Value input from the trigger for the duration of the impulse chain started from the receiver Impulse output.

When spawning this node from the node browswer there is a selection of possible datatypes for this node. See this tutorial by ProbablePrime for how to create receiver nodes 
for other data types.

}



FrooxEngine.LogiX.ProgramFlow.DynamicImpulseTrigger:##################################################################################################################################

{

The <color=#00FF00>Dynamic Impulse Trigger</color> node sends a dynamic impulse when impulse is received at Run which triggers any Dynamic Impulse Receiver nodes present under
 the input TargetHierarchy 
whose Tag input matches that on the Dynamic Impulse Trigger.
Usage

The ExcludeDisabled input determines whether Dynamic Impulse Receiver nodes present on inactive slots will be triggered. Default is False, meaning that all valid receivers may
 be triggered.


The OnTriggered output fires an impulse after any impulse chains triggered from Dynamic Impulse Receivers have completed. This continues the impulse chain which arrived at Run


Note that the tag system for dynamic impulse triggers / receivers is completely unrelated to slot tag properties. When an impulse is received at Run, this node starts a 
descending search for any Dynamic Impulse Receiver nodes present under the TargetHierarchy. All such receiver nodes with Tag inputs matching the trigger Tag will fire an impulse. 
Note that Dynamic Impulse Receiver With Value`1 nodes will be ignored. The hierarchy search is highly efficient, however it is best to set the input TargetHierarchy as close to 
the intended target node as possible to minimize performance costs. 

}


FrooxEngine.LogiX.ProgramFlow.DynamicImpulseTriggerWithValue`1[System.Boolean]:##################################################################################################################################
{

The <color=#00FF00>Dynamic Impulse Trigger With Value`1</color> node sends a dynamic impulse when an impulse is received at Run which triggers any Dynamic 
Impulse Receiver nodes (with the same Value datatype) present under the input TargetHierarchy whose Tag input matches that on the Dynamic Impulse Trigger With Value`1.
Usage

The ExcludeDisabled input determines whether Dynamic Impulse Receiver With Value`1 nodes present on inactive slots will be triggered. Default is False, meaning that 
all valid receivers may be triggered.


The OnTriggered output fires an impulse after any impulse chains triggered from Dynamic Impulse Receiver With Value`1 nodes have completed. This continues the impulse 
chain which arrived at Run


Note that the tag system for dynamic impulse triggers / receivers is completely unrelated to slot tag properties. When an impulse is received at Run, this node starts 
a descending search for any Dynamic Impulse Receiver With Value`1 nodes present under the TargetHierarchy whose Value datatype matches that of the trigger. 
All such receiver nodes with Tag inputs matching the trigger Tag will fire an impulse. Note that Dynamic Impulse Receiver nodes will be ignored. The hierarchy 
search is highly efficient, however it is best to set the input TargetHierarchy as close to the intended target node as possible to minimize performance costs. 

}



FrooxEngine.LogiX.ProgramFlow.FireOnChange`1[T]:##################################################################################################################################
{

The <color=#00FF00>Fire On Change</color> node fires an impulse whenever the input Value changes.
Usage

The Value input has a 'dummy' datatype when the node is spawned from the node browser. The node will overload to any given datatype if a wire of that type is connected to Value.

The second input to this node, OnlyForUser, exists to control which users fire the impulse when the Condition is met/changed. Its handling is as follows:

    If a User is specified in the OnlyForUser only fire for this user.
    If a User is not specified BUT the Node exists parented to a User then fire for the user it is parented to. This usually happens on avatars.
    Otherwise fire for all users.

Do not use Local User with this node. Use Local Fire On Change instead.

It is recommended to specify a user at OnlyForUser to ensure that the user for whom the impulse fires is predictable.

Note that this node will only fire one impulse in the event that Value changes multiple times within a single impulse chain. 
Similarly this node will not fire an impulse if the Value is changed and then reset to the previous value within a single impulse chain. 

}



FrooxEngine.LogiX.ProgramFlow.FireOnFalse:##################################################################################################################################
{

The <color=#00FF00>Fire On False</color> node node fires a single impulse whenever the input Condition becomes False.
Usage

After an impulse has been fired, the Condition must first be reset to True before any additional impulses can be fired. When the node is spawned from the node 
browser Condition is False by default, however no impulse is fired as a result.

The second input to this node, OnlyForUser, exists to control which users fire the impulse when the Condition is met/changed. Its handling is as follows:

    If a User is specified in the OnlyForUser only fire for this user.
    If a User is not specified BUT the Node exists parented to a User then fire for the user it is parented to. This usually happens on avatars.
    Otherwise fire for all users.

Do not use Local User with this node. Use Local Fire On False instead.

It is recommended to specify a user at OnlyForUser to ensure that the user for whom the impulse fires is predictable.

Note that this node will only fire one impulse in the event that Condition becomes False multiple times within a single impulse chain. Similarly this node will not 
fire an impulse if the Condition becomes False and then reset to True within a single impulse chain. 

}


FrooxEngine.LogiX.ProgramFlow.FireOnTrue:##################################################################################################################################
{

The <color=#00FF00>Fire On True</color> node fires a single impulse whenever the input Condition becomes True.
Usage

After an impulse has been fired, the Condition must first be reset to False before any additional impulses can be fired.

The second input to this node, OnlyForUser, exists to control which users fire the impulse when the Condition is met/changed. Its handling is as follows:

    If a User is specified in the OnlyForUser only fire for this user.
    If a User is not specified BUT the Node exists parented to a User then fire for the user it is parented to. This usually happens on avatars.
    Otherwise fire for all users.

Do not use Local User with this node. Use Local Fire On True instead.

It is recommended to specify a user at OnlyForUser to ensure that the user for whom the impulse fires is predictable.

Note that this node will only fire one impulse in the event that Condition becomes True multiple times within a single impulse chain. Similarly this node will not fire 
an impulse if the Condition becomes True and then reset to False within a single impulse chain.



}


FrooxEngine.LogiX.ProgramFlow.FireWhileTrue:##################################################################################################################################

{

The <color=#00FF00>Fire While True</color> node fires an impulse every frame while the input Condition is True.
Usage

The FiringUser input determines for which users impulses will fire: if a valid user value is present, impulses will only fire for that user. If no FiringUser is provided, 
or Local User is used, impulses will fire for all users. If an explicit null value provided, no impulses will fire at all.


It is recommended to specify the FiringUser to minimize redundant impulses and to keep behavior predictable.
Examples

This will continue firing until the condition is no longer True. 

}

FrooxEngine.LogiX.ProgramFlow.ForNode:##################################################################################################################################

{

The <color=#00FF00>For</color> node is used to fire impulses from the LoopIteration output a specific number of times when an impulse is received at Run.
Usage

The Count input determines how many times impulses will be fired from the LoopIteration output. Default is 0. Note that this is evaluated immediately after the LoopStart 
impulse chain has completed, just before any impulses are fired from LoopIteration.


The Reverse input controls whether the Iteration output value is incremented or decremented each LoopIteration. Default is False, meaning Iteration is incremented each iteration.


The LoopStart output fires an impulse once after an impulse is received at Run. The impulse chain will complete before any impulses are fired from LoopIteration.


The LoopIteration output fires impulses sequentially until the total number which have been fired is equal to the Count input. Each impulse chain started from LoopIteration 
completes before the following one is fired.


The LoopEnd output fires an impulse once the final impulse chain started from LoopIteration has ended.


The Iteration output value is either incremented or decremented each time a new impulse is fired from LoopIteration, depending on the value of Reverse. If Reverse is False, 
Iteration is incremented each time an impulse is fired from LoopIteration starting with the value 0, during the first iteration, and ending with Count - 1 on the final iteration. 
If Reverse is True, the Iteration value is Count - 1 on the first iteration and decremented each time down to 0 on the final iteration.


Note that all impulse chains started from this node effectively continue the one which arrived at Run, meaning that any temporary values from previous nodes are still available. 
All iterations from LoopIteration complete within a single frame update and therefore this can produce framerate hitches if an excessively demanding computation is performed.
 There is a failsafe which will put this node into an error state (node visual turns red) if a frame is delayed excessively - this helps prevent complete freezes. 

}


FrooxEngine.LogiX.ProgramFlow.IfNode:##################################################################################################################################
{

The <color=#00FF00>If</color> node fires an impulse from one of two outputs dependent on the Condition when an impulse is received at Run.
Usage

Upon receiving an impulse at Run, an impulse is fired from True if Condition is True or from False if Condition is False. The default Condition value is False. 

}


FrooxEngine.LogiX.ProgramFlow.ImpulseDemultiplexer:##################################################################################################################################
{

The <color=#00FF00>Impulse Demultiplexer</color> node fires an impulse from OnTriggered whenever an impulse is received at any Trigger input. It also indicates which input was 
triggered via the Index value.
Usage

The Index output value corresponds to the index of the input which was triggered. Neos uses zero-based indexing meaning that the top input being triggered corresponds to Index = 0. 
This value is only available for the duration of the impulse chain fired from OnTriggered. Default value is 0.


The number of Trigger inputs can be changed with the + or - buttons.

}



FrooxEngine.LogiX.ProgramFlow.ImpulseMultiplexer:##################################################################################################################################

{

The <color=#00FF00>Impulse Multiplexer</color> node fires an impulse from the output which matches the value of the input Index when an impulse is received at Trigger.
Usage

An impulse is only fired if there is a corresponding output for the Index, e.g. no impulse will be fired if the Index is -1 when an impulse is 
received at Trigger. Neos uses zero indexing, hence the topmost output will fire an impulse when Index is zero. The number of outputs can be changed with the + and - buttons. 

}



FrooxEngine.LogiX.ProgramFlow.LocalFireOnChange`1[T]:##################################################################################################################################
{

The <color=#00FF00>Local Fire On Change`1</color> node fires an impulse independently for each user whenever the input Value changes locally for them.
Usage

The Value input has a 'dummy' datatype when the node is spawned from the node browser. The node will overload to any given datatype if a wire of that type is connected to Value. 

}


FrooxEngine.LogiX.ProgramFlow.LocalFireOnFalse:##################################################################################################################################
{

The <color=#00FF00>Local Fire On False</color> node fires an impulse independently for each user whenever the input Condition locally becomes False for them.
Usage

Note that the initial default value is false, however the node does not fire an impulse when it is first created. Hence the input value 
must become True at least once before this node will fire.

There are a few mechanisms which can cause values in NeosVR to be different for different users; if there were 3 users in a session (A, B, and C) 
and the Condition became False for A and B (but not C), impulses would be fired for both A and B (but not C). If later the Condition also became False for C and 
impulse would fire only for C. 

}



FrooxEngine.LogiX.ProgramFlow.LocalFireOnTrue:##################################################################################################################################

{

The <color=#00FF00>Local Fire On True</color> node fires an impulse independently for each user whenever the input Condition locally becomes True for them.
Usage

Note that the initial default value is False.

There are a few mechanisms which can cause values in NeosVR to be different for different users; if there were 3 users in a session (A, B, and C) 
and the Condition became True for A and B (but not C), impulses would be fired for both A and B (but not C). If later the Condition also became True for C 
and impulse would fire only for C. 

}

FrooxEngine.LogiX.ProgramFlow.LocalImpulseTimeout:##################################################################################################################################
{

The <color=#00FF00>Local Impulse Timeout</color> node can be used to filter the rate of impulses passing along an impulse chain.
Usage

When an impulse is first received at Trigger, an impulse is fired from Pulse which continues the impulse chain. No further impulses will be fired from Pulse, no matter how many 
arrive at Trigger. Until either an impulse is received at Reset or a number of seconds has elapsed greater than or equal to TimeoutSeconds. The duration to wait is fixed at the 
moment that an impulse is fired from Pulse. As such, if the TimeoutSeconds value is changed after the timeout begins, no further impulses will fire from Pulse until enough seconds 
have elapsed greater than or equal to the previous value of TimeoutSeconds (or an impulse is received at Reset).

As the node name implies, timeouts and resets are local for each user. Meaning one user may fire an impulse from Pulse and initate a timeout for any impulses owned by them, 
but another user would be capable of triggering an impulse from Pulse and initating their own timeout immediately afterwards. 

}


FrooxEngine.LogiX.ProgramFlow.LocalLeakyImpulseBucket:##################################################################################################################################

{


The <color=#00FF00>Local Leaky Impulse Bucket</color> node can be used as a buffer to store multiple impulses and release them at a constant rate. This node operates 
according to the Leaky bucket algorithm.
Usage

Trigger is the impulse source for the bucket. Reset will remove all remaining impulses from the bucket. Interval is a configurable time interval which affects how often 
impulses are poured out of the bucket. MaximumCapacity is the maximum number of impulses that can be stored in the bucket. Pulse fires whenever the specified time interval 
has elapsed if there are impulses remaining. Overflow fires whenever an impulse is received through Trigger while the bucket is full. CurrentCapacity is the current number 
of impulses in the bucket. 

}


FrooxEngine.LogiX.ProgramFlow.OnePerFrame:##################################################################################################################################
{

The <color=#00FF00>One Per Frame</color> node fires an impulse from Pulse when it receives an impulse at Trigger. 
No further impulses are fired from Pulse, however many may arrive at Trigger, until the next frame update.

}


FrooxEngine.LogiX.ProgramFlow.PulseRandom:##################################################################################################################################
{

The <color=#00FF00>Pulse Random</color> node fires an impulse from one random output when an impulse is received at Trigger.
Usage

The number of outputs can be changed using the + / - buttons on the node visual. 

}


FrooxEngine.LogiX.ProgramFlow.SequenceImpulse:##################################################################################################################################
{

The <color=#00FF00>Sequence</color> node fires an impulse from each output sequentially when an impulse is received at Trigger.
Usage

Impulses are fired from outputs in numerically ascending order [0], [1] etc.. Successive output impulses are only fired when the chain initiated by the preceding one has completed. 

}


FrooxEngine.LogiX.ProgramFlow.TimerNode:##################################################################################################################################

{

The <color=#00FF00>Timer</color> node fires impulses from Pulse separated by the number of seconds specified by the Interval input.
Contents

    1 Usage
        1.1 User Handling
    2 Examples
    3 Node Menu

Usage

Each frame update, this node checks whether a number of seconds greater than or equal to the Interval input have elapsed. If they have, an impulse is fired owned by the UpdatingUser. If no UpdatingUser is provided, the default owner is the world host. If a null UpdatingUser is provided, the node will not fire at all.
User Handling

It is NOT recommended to use Local User with this node. When Local User is used, it will fire impulses for all users in the session. This is similar to the guidance for Fire On True etc. 

}



FrooxEngine.LogiX.ProgramFlow.UpdateNode:##################################################################################################################################
{

The <color=#00FF00>Update</color> node fires an impulse from Update every frame.
Usage

Impulses are fired owned by the UpdatingUser. This defaults to the world host if no UpdatingUser is provided. If a null user value is explicitly provided the node will not fire impulses.

Due to the frequency that this node fires impulses, one should be careful to ensure that impulses are filtered such that downstream LogiX is only evaluated when absolutely necessary. Unnecessary use of this node has the potential to incur significant performance penalties and there are almost always better alternatives. 

}



FrooxEngine.LogiX.ProgramFlow.UpdatesDelayNode:##################################################################################################################################
{

The <color=#00FF00>Update</color>Updates Delay</color> node is used to fire an impulse from Impulse after a number of frame updates greater than or equal to Updates have completed following an impulse received at Trigger.
Usage

The Updates input sets the number of frame updates which must complete before the delayed impulse is fired from Impulse. The default value is 1.


The OnTrigger output fires an impulse immediately after an impulse is received at Trigger. This continues the impulse chain which arrived at Trigger.


The delayed impulses do not continue the impulse chain which arrived at Trigger and any temporary values present will have been lost - if a temporary value must be stored until the delayed impulse is fired use Updates Delay With Value. Each impulse which arrives at Trigger sets up a separate delayed impulse and multiple can be queued at once with different delay durations.


}



FrooxEngine.LogiX.ProgramFlow.UpdatesDelayWithValueNode`1[T]:##################################################################################################################################
{

The <color=#00FF00>Updates Delay with value</color> node is used to fire an impulse from Impulse after a number of frame updates greater than or equal to Updates have completed following an impulse received at Trigger. Additionally a value can be stored over the delay.
Usage

The Updates input sets the number of frame updats which must complete before the delayed impulse is fired from Impulse. The default value is 1.


The Value input value at the moment an impulse is received at Trigger is stored. When the node is spawned from the node browser this accepts a 'dummy' datatype, however the node will overload to accept any specific input datatype when a wire is connected.


The OnTrigger output fires an impulse immediately after an impulse is received at Trigger. This continues the impulse chain which arrived at Trigger.


The DelayedValue output provides the value at the Value input when the delayed impulse was queued. This is only available for the duration of the impulse chain started by Impulse.


The delayed impulses do not continue the impulse chain which arrived at Trigger and any temporary values, other than that the single stored value will be lost. Each impulse which arrives at Trigger sets up a separate delayed impulse with corresponding stored value and multiple can be queued at once with different delay durations and stored values. 

}


FrooxEngine.LogiX.ProgramFlow.WhileNode:##################################################################################################################################
{

The <color=#00FF00>While</color> node is used to fire impulses from the LoopIteration output until the Condition becomes True after an impulse is received at Run.
Usage

The LoopStart output fires an impulse once after an impulse is received at Run. The impulse chain will complete before any impulses are fired from LoopIteration.


The LoopIteration output fires impulses sequentially until the Condition becomes True. Each impulse chain started from LoopIteration completes before the following one is fired.


The LoopEnd output fires an impulse once the final impulse chain started from LoopIteration has ended.


Note that all impulse chains started from this node effectively continue the one which arrived at Run, meaning that any temporary values from previous nodes are still available. All iterations from LoopIteration complete within a single frame update and therefore this can produce framerate hitches if an excessively demanding computation is performed. There is a failsafe which will put this node into an error state (node visual turns red) if a frame is delayed excessively - this helps prevent complete freezes.
Examples

The While node is useful when looping and the required number of iterations cannot be determined in advance. If similar looping behavior is required, but the number of required iterations can be fixed, use the For node instead. 


}








FrooxEngine.LogiX.Input.GeneralHeadset:#################################################################
{
'General Headset' LogiX node
Inputs
  	User 	User
Outputs
  	Float 	BatteryLevel
  	Bool 	IsBatteryCharging

The <color=#00FF00>General Headset</color> node returns generic information about the input user's current headset.

}

########Controllers########################
FrooxEngine.LogiX.Input.CosmosController:###############################################################
{
The <color=#00FF00>Cosmos Controller</color> provides more controller data than the Standard Controller (LogiX node) specifically for HTC VIVE Cosmos controllers.
Usage

The Active output indicates whether the User is using Cosmos.


The BatteryLevel output output provides the estimated remaining battery charge. The value is in the range 0 to 1 with precision to two decimal places.


The IsBatteryCharging output indicates whether the controller battery is currently charging.


The Menu output


The ButtonBY output


The ButtonAX output


The GripClick output


The Joystick output


The JoystickTouch output


The JoystickClick output


The Trigger output


The TriggerTouch output


The TriggerClick output


The Bumper output 
}



FrooxEngine.LogiX.Input.HPReverbController:#############################################################
{
The <color=#00FF00>HPReverb Controller</color> provides more controller data than the Standard Controller (LogiX node) specifically for second generation Windows Mixed Reality (WMR) controllers compatible with the HP Reverb G2 headset.
Usage

The IsActive output indicates whether the User is using 2nd generation WMR controllers.


The BatteryLevel output provides the estimated remaining battery charge. The value is in the range 0 to 1 with precision to two decimal places.


The IsBatteryCharging output is intended to indicate whether the controller is currently charging. This output cannot be used as 2nd generation WMR controllers use replacable batteries and therefore cannot be charged while in use.


The AppMenu output


The ButtonYB output


The ButtonXA output


The Grip output indicates how far the grip/grab button is pressed.


The GripTouch output


The GripClick output indicates whether the grip/grab button is fully pressed.


The Joystick output indicates the current position of the joystick. X and Y values are in the range -1 to 1. X indicates left/right location, Y indicates forward/back. The resting joystick position is [0,0].


The JoystickClick output indicates whether the joystick is pressed down.


The Trigger output indicates how far the trigger button is pressed down. This corresponds to the button labelled Primary on the graphic below. The value is in the range 0 to 1 with 1 being reached somewhat before the button is fully pressed.


The TriggerClick output is indicates whether the trigger button is pressed to the point of registering as a button click. This is reached somewhat before the button is fully pressed. 
}




FrooxEngine.LogiX.Input.IndexController:###############################################################
{
The <color=#00FF00>Index Controller</color> provides more controller data than the Standard Controller (LogiX node) specifically for Valve Index controllers.
Usage

The IsActive output indicates whether the User is using Index controllers.


The BatteryLevel output provides the estimated remaining battery charge. The value is in the range 0 to 1 with precision to two decimal places.


The IsBatteryCharging output indicates whether the controller is currently charging.


The ButtonA output


The ButtonB output


The ButtonA_Touch output


The ButtonB_Touch output


The Grip output


The GripTouch output


The GripClick output


The Joystick output


The JoystickTouch output


The JoystickClick output


The Trigger output


The TriggerTouch output


The TriggerClick output


The Touchpad output


The TouchpadTouch output


The TouchpadPress output


The TouchpadForce output 
}



FrooxEngine.LogiX.Input.StandardController:############################################################
{
The <color=#00FF00>Standard Controller</color> provides access to standard data available from all supported VR controller types.
Usage

The IsActive output indicates whether the User is using VR controllers.


The BatteryLevel output provides the estimated remaining battery charge. The value is in the range 0 to 1 with precision to two decimal places.


The IsBatteryCharging output is intended indicates whether the controller is currently charging. This is only functional with Index and Vive controllers.


The Type output indicates which type of VR controllers the User is using.


The Primary output indicates whether the primary button is pressed. This corresponds to the trigger button on most controllers and is used to activate / user the interaction lasers.


The Secondary output indicates whether the secondary button is pressed.


The Grab output indicates whether the grab/grip button is pressed.


The Menu output indicates whether the menu button is pressed.


The Strength output indicates how far the primary button is pressed down. The value is in the range 0 to 1.


The Axis on Windows Mixed Reality controllers indicates the touch location on the capacitative touchpad. The X and Y values are in the range -1 to 1. X indicates left/right location, Y indicates forward/back. 
}





FrooxEngine.LogiX.Input.TouchController:###############################################################
{
The <color=#00FF00>Touch Controller</color> provides more controller data than the Standard Controller (LogiX node) specifically for Oculus controllers.
Usage

The IsActive output indicates whether the User is using Oculus (Meta) Touch controllers.


The BatteryLevel output provides the estimated remaining battery charge. The value is in the range 0 to 1 with precision to two decimal places.


The IsBatteryCharging output indicates whether the controller is currently charging.


The Start output


The ButtonYB output


The ButtonXA output


The ButtonYB_Touch output


The ButtonXA_Touch output


The ThumbRestTouch output


The Grip output


The GripClick output


The Joystick output


The JoystickTouch output


The JoystickClick output


The Trigger output


The TriggerTouch output


The Model output


The TriggerClick output 
}



FrooxEngine.LogiX.Input.ViveController:################################################################
{
<color=#00FF00>Vive Controller</color>

Usage

The IsActive output indicates whether the User is using HTC VIVE controllers.


The BatteryLevel output provides the estimated remaining battery charge. The value is in the range 0 to 1 with precision to two decimal places.


The IsBatteryCharging output indicates whether the controller is currently charging.


The Grip output


The App output


The Trigger output


The TriggerHair output


The TriggerClick output


The Touchpad output


The TouchpadTouch output


The TouchpadClick output 
}


FrooxEngine.LogiX.Input.WindowsMR_Controller:##########################################################
{
The <color=#00FF00>Windows MR Controller</color> provides more controller data than the Standard Controller (LogiX node) specifically for first generation Windows Mixed Reality (WMR) controllers.
Usage

The IsActive output indicates whether the User is using WMR controllers.


The BatteryLevel output provides the estimated remaining battery charge. The value is in the range 0 to 1 with precision to two decimal places.


The IsBatteryCharging output is intended to indicate whether the controller is currently charging. This output cannot be used as WMR controllers use replacable batteries and therefore cannot be charged while in use.


The Grip output indicates whether the grip button is pressed. This corresponds to the button labelled Grab on the graphic below.


The App output indicates whether the app button is pressed. This corresponds to the button which opens the Dash / Context menu on the graphic below.


The Joystick output indicates the current position of the joystick. X and Y values are in the range -1 to 1. X indicates left/right location, Y indicates forward/back. The resting joystick position is [0,0].


The JoystickClick output indicates whether the joystick is pressed down.


The Trigger output indicates how far the trigger button is pressed down. This corresponds to the button labelled Primary on the graphic below. The value is in the range 0 to 1 with 1 being reached somewhat before the button is fully pressed.


The TriggerHair output is intended to indicate whether the trigger is lightly pressed. In this case it seems to be functionally equivalent to TriggerClick.


The TriggerClick output is indicates whether the trigger button is pressed to the point of registering as a button click. This is reached somewhat before the button is fully pressed.


The Touchpad output indicates the touch location on the capacitative touchpad. The X and Y values are in the range -1 to 1. X indicates left/right location, Y indicates forward/back.


The TouchpadTouch output indicates whether the capacitative touchpad is currently touched.


The TouchpadClick output indicates whether the capacitative touchpad is currently pressed. 
}



##########Haptics###############

FrooxEngine.LogiX.Input.TriggerHapticsInHierarchy:#####################################################
{
The <color=#00FF00>Trigger Haptics In Hierarchy</color> node causes all haptic feedback devices (typically controller vibration) under the input TargetHierarchy to activate. Haptics will not activate if an affected user has Controller Vibration unchecked in their settings menu. 

Usage

Haptic activation is extremely short in duration so for prolonged vibration this node needs to be repeatedly triggered. Activation intensity is modulated by the RelativeIntensity input.
}



FrooxEngine.LogiX.Input.TriggerHapticsOnController:####################################################
{
The <color=#00FF00>Trigger Haptics On Controller</color> node causes controller haptic feedback (vibration) activate on the input Controller. Haptics will not activate if an affected user has Controller Vibration unchecked in their settings menu.


Usage

Haptic activation is extremely short in duration so for prolonged vibration this node needs to be repeatedly triggered. Activation intensity is modulated by the RelativeIntensity input.
}



#########Keyboard#############
FrooxEngine.LogiX.Input.KeyHeld:#######################################################################
{
The <color=#00FF00>Key Held</color> node reports whether the input Key is being held down.
Usage

This node only reports on inputs via a user's hardware keyboard. It does not respond to key presses on the Neos software keyboard. Additionally inputs from a hardware keyboard will not be recognised by this node if a user is editing an input field.

The output of this node is local, and thus potentially different, for each user. Hence each user only sees the value relevant to their system hardware. 
}


FrooxEngine.LogiX.Input.KeyPressed:####################################################################
{
The <color=#00FF00>Key Pressed</color> node reports whether the input Key has just been pressed.
Usage

This node only reports on inputs via a user's hardware keyboard. It does not respond to key presses on the Neos software keyboard. Additionally inputs from a hardware keyboard will not be recognised by this node if a user is editing an input field.

The output of this node is local, and thus potentially different, for each user. Hence each user only sees the value relevant to their system hardware. This node only has the value True for a single frame when the indicated Key is pressed.

}



FrooxEngine.LogiX.Input.KeyReleased:###################################################################
{
The <color=#00FF00>Key Released</color> node reports whether the input Key has just been released.
Usage

This node only reports on inputs via a user's hardware keyboard. It does not respond to key presses on the Neos software keyboard. Additionally inputs from a hardware keyboard will not be recognised by this node if a user is editing an input field.

The output of this node is local, and thus potentially different, for each user. Hence each user only sees the value relevant to their system hardware. This node only has the value True for a single frame when the indicated Key is released. 
}



FrooxEngine.LogiX.Input.TypeDelta:#####################################################################
{
The <color=#00FF00>Type Delta</color> node outputs the keys which were pressed on a user's keyboard during the last frame.
Usage

This node only reports on inputs via a user's hardware keyboard. It does not respond to key presses on the Neos software keyboard. Additionally inputs from a hardware keyboard will not be recognised by this node if a user is editing an input field.

The output of this node is local, and thus potentially different, for each user. Hence each user only sees the value relevant to their system hardware. This node only has any specific output value for single frame.
}


#########Mouse######################
FrooxEngine.LogiX.Input.DesktopMousePosition:##########################################################
{
The <color=#00FF00>Desktop Mouse Position</color> node outputs the current pixel position of the mouse cursor on the user's desktop.
Examples

In the output Float2, the X value corresponds to the mouse horizontal position and Y corresponds to the mouse vertical position relative to the user's primary desktop monitor. Both values start at 0 when the cursor is at the top left corner of a user's screen. Note that, if the mouse input is being captured by Neos, the value will correspond to the middle of the Neos window.


The output of this node is local, and thus potentially different, for each user. Hence each user only sees the value relevant to their system hardware. 
}



FrooxEngine.LogiX.Input.LeftMouseButtonHeld:###########################################################
{
The <color=#00FF00>Left Mouse Button Held</color> node reports whether the user's left mouse button is pressed down.
Usage

The output of this node is local, and thus potentially different, for each user. Hence each user only sees the value relevant to their system hardware.
}


FrooxEngine.LogiX.Input.LeftMouseButtonReleased:#######################################################
{
The <color=#00FF00>Left Mouse Button Released</color> node reports whether the user's left mouse button has just been released.
Usage

The output of this node is local, and thus potentially different, for each user. Hence each user only sees the value relevant to their system hardware. This node only has the value True for a single frame when the left mouse button is released. 
}

FrooxEngine.LogiX.Input.LeftMousePressed:##############################################################
{
The <color=#00FF00>Left Mouse Pressed</color> node reports whether the user's left mouse button has just been pressed.
Usage

The output of this node is local, and thus potentially different, for each user. Hence each user only sees the value relevant to their system hardware. This node only has the value True for a single frame when the left mouse button is pressed. 
}


FrooxEngine.LogiX.Input.MiddleMouseButtonHeld:#########################################################
{
The <color=#00FF00>Middle Mouse Button Held</color> node reports whether the user's middle mouse button is pressed down.
Usage

The output of this node is local, and thus potentially different, for each user. Hence each user only sees the value relevant to their system hardware. 
}




FrooxEngine.LogiX.Input.MiddleMouseButtonReleased:#####################################################
{
The <color=#00FF00>Middle Mouse Button Released</color> node reports whether the user's middle mouse button has just been released.
Usage

The output of this node is local, and thus potentially different, for each user. Hence each user only sees the value relevant to their system hardware. This node only has the value True for a single frame when the left mouse button is released.

}


FrooxEngine.LogiX.Input.MiddleMousePressed:############################################################
{
The <color=#00FF00>Middle Mouse Pressed</color> node reports whether the user's middle mouse button has just been pressed.
Usage

The output of this node is local, and thus potentially different, for each user. Hence each user only sees the value relevant to their system hardware. This node only has the value True for a single frame when the middle mouse button is pressed. 
}


FrooxEngine.LogiX.Input.MouseMovementDelta:############################################################
{
The <color=#00FF00>Mouse Movement Delta</color> node outputs the change in the user's mouse position (in screen pixel units) during the last frame.
Usage

The output X value corresponds to horizontal movement, Y corresponds to vertical movement. Positive X values indicate a move to the right, negative values indicate movement to the left. Positive Y values indicate a move upwards, negative values indicate downward movement.

The output of this node is local, and thus potentially different, for each user. Hence each user only sees the value relevant to their system hardware. 
}


FrooxEngine.LogiX.Input.MousePosition:#################################################################
{
The <color=#00FF00>Mouse Position</color> node outputs the current pixel position of the mouse cursor relative to the Neos application window.
Usage

In the output Float2, the X value corresponds to the mouse horizontal position and Y corresponds to the mouse vertical position. Both values start at 0 when the cursor is at the bottom left corner of a user's Neos application window. Note that, if the mouse input is being captured by Neos, the value will correspond to the middle of the Neos window.


The output of this node is local, and thus potentially different, for each user. Hence each user only sees the value relevant to their system hardware. 
}



FrooxEngine.LogiX.Input.MouseScrollWheelDelta:#########################################################
{
The <color=#00FF00>Mouse Scroll Wheel Delta</color> node outputs the number of 'ticks' that the mouse scroll wheel moved through during the last frame.
Usage

The output value is a whole number float value. Positive values correspond to the mouse wheel being pushed forwards, negative values correspond to the wheel being rolled back.

The output of this node is local, and thus potentially different, for each user. Hence each user only sees the value relevant to their system hardware. 
}


FrooxEngine.LogiX.Input.RightMouseButtonHeld:##########################################################
{
The <color=#00FF00>Right Mouse Button Held</color> node reports whether the user's right mouse button is pressed down.
Usage

The output of this node is local, and thus potentially different, for each user. Hence each user only sees the value relevant to their system hardware. 
}



FrooxEngine.LogiX.Input.RightMouseButtonReleased:######################################################
{
The <color=#00FF00>Right Mouse Button Released</color> node reports whether the user's right mouse button has just been released.
Usage

The output of this node is local, and thus potentially different, for each user. Hence each user only sees the value relevant to their system hardware. This node only has the value True for a single frame when the right mouse button is released. 
}



FrooxEngine.LogiX.Input.RightMousePressed:##############################################################
{
The Right Mouse Pressed node reports whether the user's right mouse button has just been pressed.
Usage

The output of this node is local, and thus potentially different, for each user. Hence each user only sees the value relevant to their system hardware. This node only has the value True for a single frame when the right mouse button is pressed. 
}





FrooxEngine.LogiX.Network.EscapeUriDataString:#############################################################################
{
Escapes dissallowed uri characters into uri escapes which allows you to send the output string over the network without issues.
For example `Hello World!` turns into `Hello%20World%21`.
}
FrooxEngine.LogiX.Network.UnescapeUriDataString
{
Unescapes uri escape characters into their original forms which allows you to easily read output from the network.
For example `Hello%20World%21` turns into `Hello World!`.
}
FrooxEngine.LogiX.Network.IsHostAccessAllowed:#############################################################################
FrooxEngine.LogiX.Network.IsHostAccessAllowedUrl
{
Checks whether a user has allowed host access to a provided domain.

In neos by default you cannot perform web request to arbitrary domains, to do this each user has to explicitly allow each domain that you want to perform requests to.
}
FrooxEngine.LogiX.Network.RequestHostAccessBase:#############################################################################
{
this node isn't even supposed to exist. why are you here, get out, pick a normal node instead like smooth lerp or something
}
FrooxEngine.LogiX.Network.RequestHostAccessUrl:#############################################################################
{
Prompts the user with a popup asking if the user wants to allow neos to make web requests to a provided domain.

In neos by default you cannot perform web request to arbitrary domains, to do this each user has to explicitly allow each domain that you want to perform requests to.
}

FrooxEngine.LogiX.Network.WebsocketBaseNode // abstract
FrooxEngine.LogiX.Network.WebsocketConnectionEvents:######################################################
{
The <color=#00FF00>Websocket Connection Events</color> node provides impulses that indicate if a given 
Websocket Client has successfully connected, failed to connect, or was otherwise disconnected

Usage

After initiating a connection with the Websocket Connect node, this node will provide an impulse indicating 
if the connection was successful, or if it failed.

Once a Connectedimpulse is received, other WebSocket nodes can be used to communicate with the endpoint, 
such as the Websocket Text Message Sender and Websocket Text Message Receiver

A Disconnected impluse indicates that the Websocket was disconnected, or the connection was rejected by 
the user specified in Client 
}
FrooxEngine.LogiX.Network.WebsocketTextMessageReceiver:#####################################################
{
The <color=#00FF00>Websocket Text Message Receiver</color> node indicates when the Websocket endpoint 
specified by Client has received data. 
}
FrooxEngine.LogiX.Network.WebsocketConnect:##################################################################
{
The <color=#00FF00>Websocket Connect</color> node allows the User specified in HandlingUser to connect 
to a websocket endpoint, as defined by Client

Usage

This node must be used in conjunction with other WebSocket nodes to establish communication with an endpoint, 
which is defined by a Websocket Client component that is passed to the Client input.

The OnConnectStart impulse signifies that the Client has started the connection process - it does *not* mean 
that the client has successfully connected.

Connection success/fail events are provided by the Websocket Connection Events Node 
}
FrooxEngine.LogiX.Network.WebsocketTextMessageSender:#########################################################
{
The <color=#00FF00>Websocket Text Message Sender</color> node sends a string specified by Data to the 
websocket endpoint specified by Client

Usage

Once a connection has been initialized by a Websocket Connect node, and the Connected event has been 
received on a Websocket Connection Events node, this node can be used to send strings to the target endpoint.

OnSendStart indicates that the Data string has began transmitting.

OnSent indicates that the Data string has finished transmitting successfully.

OnSendError indicates that the Data string failed to transmit - either the socket is no longer connected, 
or some other error occurred during transmission.

If the send was successful, SentData contains the string that was originally given as Data - this is useful 
in cases where Data's value has changed between the Send impulse, and the OnSent impulse. 
}



FrooxEngine.LogiX.Network.RequestHostAccess:################################################################
{
The <color=#00FF00>Request Host Access</color> node informs the user that owns the Request impulse that you wish to connect to a particular host, and allows them to grant or deny access.
Usage

When given a Request impulse, the following will occur:

    If the user has previously granted access to this host, OnGranted will immediately fire
    If the user has previously denied access to this host, OnDenied will immediately fire, and any attempt to connect to this host will fail
    If the user has not previously granted or denied access, or has closed the prompt without selecting an option before, they will be presented with a prompt displaying the Host and Reason, and given the option to Allow or Reject the connection.
        If allowed, OnGranted will fire, and no further prompts will be displayed.
        If rejected, OnDenied will fire, and no further prompts will be displayed, and any attempt to connect to this host will fail
        If dismissed, no impulse will fire, and any future host access requests will result in the prompt being shown again.

Host should contain only the host portion of the URL you wish to connect to.

For example, if you wanted to perform a GET request to https://wiki.neos.com/index.php, you would provide wiki.neos.com as the Host parameter.

Reason should provide a clear and concise reason for wanting to connect to the external service - It should include an obvious title or description of the object that is attempting to establish the connection, so that the user is aware of what item in the world is prompting the connection.

The object should also have some way of indicating that it did not successfully connect to the target service, and that it will not function as intended, if at all. 
}



FrooxEngine.LogiX.Network.GET_String:#######################################################################
{
The <color=#00FF00>GET String</color> node makes an HTTP GET Request to a given URL, and upon success returns the result as a String
Usage

Before using this node, check if the user allows connections to this host using the Is Host Access Allowed node. If access is not already granted, it can be requested using the Request Host Access node

Executing a HTTP request without being granted access will result in the request failing.

    URL is the full host path to which a HTTP GET request will be sent
    OnSent indicates that the request has been sent, but has not yet received a response.
    OnResponse indicates that the remote server has responded. Any text returned by the server will be available in Content, and StatusCode will indicate any errors the remote server encountered while handling this request.
    OnError indicates that there was an error connecting to the remote server.
    Content contains any string returned by the server in the response body.
    StatusCode contains the HTTP Status Code of the response. Normally, this will be 200/OK to indicate success.
}
FrooxEngine.LogiX.Network.POST_String:#####################################################################
{
<color=#00FF00>Post String</color> logix node requires you to specify the type of data being send to the server 
}




FrooxEngine.LogiX.Operators.All_Bool2
{Basically an AND gate for Boolean Vectors... Boolean vectors a bundle of Boolean values in a single wire
 IF ALL boolean values in wire are True, then the output is True}

FrooxEngine.LogiX.Operators.Any_Bool2
{Basically an OR gate for Boolean Vectors... Boolean vectors a bundle of Boolean values in a single wire
IF ANY boolean values in the wire are True, then the output is True}

FrooxEngine.LogiX.Operators.None_Bool2
{Basically a NOR gate for Boolean Vectors... Boolean vectors a bundle of Boolean values in a single wire
If NO boolean values in the wire are True, then the output is True}

FrooxEngine.LogiX.Operators.PackNullable`1:#######################################################################################################
FrooxEngine.LogiX.Operators.UnpackNullable`1
{
<color=#00FF00>Pack</color> / <color=#00FF00>Unpack</color> nullable allow you to create and extract nullable types which are normal value types 
(such as int), with the ability of becoming null. These aren't useful in user made creations but are sometimes used in existing components 
(such as AvatarRenderSettings)
}



FrooxEngine.LogiX.Operators.Parse:##############################
{
parses a string into the respective value
}


FrooxEngine.LogiX.Operators.Sub_Float:##################################################################################################################################
{
The <color=#00FF00>-</color> node subtracts the value of input B from input A.
Usage

Note that this node takes a float datatype by default, however it can cast to handle various different numeric datatypes if an appropriate wire is connected. 
If there are more than 3 inputs the naming of inputs changes to Operands.[0], Operands.[1] ... etc. In that case, all inputs are subtracted from Operands.[0]. 
}


FrooxEngine.LogiX.Operators.NOT_Int:##################################################################################################################################
{

The <color=#00FF00>!</color> node performs the logical NOT operation on input A. 

Usage:
When spawned from the node browser, this node accepts an int datatype by default, but it is more commonly used to work with Boolean values (True/False) 
where it inverts whatever input it receives — True becomes False / False becomes True. This node will accept some numeric datatypes, in which case it performs 
the operation in a bitwise manner. 

The most common use of the node as a boolean operator simply inverts the value it receives. True becomes False, and False becomes True. 

}


FrooxEngine.LogiX.Operators.NotEquals_Float:##################################################################################################################################
{
The <color=#00FF00>!=</color> node checks whether inputs A and B are not equal, outputting True if they are not equal and False if they are equal. 

When spawned from the node browser, this node accepts float data by default. However, this node can be overloaded to accept 
a wide variety of value and reference datatypes if an appropriate wire is connected to one of the inputs. 
}


FrooxEngine.LogiX.Operators.Mod_Float:##################################################################################################################################
{

The <color=#00FF00>%</color> node divides A by B and outputs the remainder.
Usage

The top input is the number to divide, the bottom what we are dividing by. Returns the remainder of division. 

We can use the Modulo node to determine whether a number is even or odd. To do this, divide the number by 2. 0 indicates even and 1 indicates odd. 

}

FrooxEngine.LogiX.Operators.AND_Int:##################################################################################################################################
{

The <color=#00FF00>&</color> node performs the logical AND operation on inputs A and B.
Usage

When spawned from the node browser, this node accepts the int datatype by default, but it is more commonly used to work with Boolean values (True/False). 
The outputs will be True if, and only if, all inputs are True - otherwise it will output False. This node will accept some numeric datatypes, in which case 
it performs the operation in a bitwise manner. 
}


FrooxEngine.LogiX.Operators.Conditional_Float:##################################################################################################################################
{
The <color=#00FF00>?:</color> node outputs either the OnTrue or OnFalse input values depending on the value of the Condition input. 

When spawned from the node browser, this node accepts the float datatype by default. However, this node can be overloaded to use 
other value or reference types if an appropriate wire is connected. This operator is commonly referred to as the 'ternary' or 'conditional' operator. 
}


FrooxEngine.LogiX.Operators.NullCoalesce`1[T]:##################################################################################################################################
{
The <color=#00FF00>??</color> node outputs the value of the first input which is not null.
Usage

When spawned from the node browser, this node accepts the object datatype by default. However, this node can be overloaded to use various reference 
types if an appropriate wire is connected. Inputs are checked for not-null values in order: A, then B (or Operands.[0], Operands.[1], Operands.[2] ... 
etc. if more than 2 inputs are present). Output will be null if all inputs are also null. This operator can be referred to as the 'null-coalescing' operator. 
}


FrooxEngine.LogiX.Operators.XOR_Int:##################################################################################################################################
{
The <color=#00FF00>^</color> node performs the logical exclusive OR (XOR) operation on inputs A and B.
Usage

When spawned from the node browser, this node accepts the int datatype by default, but it is more commonly used to work with Boolean values (True/False).

If any inputs are toggled the output will also toggle. This node will accept some numeric datatypes, in which case it performs the operation in a bitwise manner. 
}


FrooxEngine.LogiX.Operators.OR_Int:##################################################################################################################################
{
The <color=#00FF00>|</color> node performs the logical inclusive OR operation on inputs A and B.
Usage

When spawned from the node browser, this node accepts the int datatype by default, but it is more commonly used to work with Boolean values (True/False) as shown in the image.

The output will be True if any of inputs are True — otherwise it will output False. This node will accept some numeric datatypes, in which case it performs the operation 
in a bitwise manner. 
}


FrooxEngine.LogiX.Operators.Magnitude_Float2:##################################################################################################################################
{
<color=#00FF00>Magnitude</color> (LogiX node)
Get distance by float from center(Coordinate 0.0.0) of parent object with root(√) calculate. 

Get actual distance value from center(0.0.0) point if parent object is world. 
}


FrooxEngine.LogiX.Operators.SqrMagnitude_Float2:##################################################################################################################################
{
<color=#00FF00>Magnitude Squared</color> (LogiX node)
Get distance by float from center(Coordinate 0.0.0) of parent without root(√) calculate. It's equal to Magnitude(|V|) after root calculate 
Usage

Get approximity distance value from center of parent. 
}


FrooxEngine.LogiX.Operators.Add_Float:##################################################################################################################################
{
The <color=#00FF00>+</color> node outputs the sum of all input values.
Usage

When spawned from the node browser, this node accepts the float datatype by default. However, this node can be overloaded to accept different numeric 
value types if an appropriate wire is connected to an input. This node can also be overloaded to accept the string datatype, in which case it outputs 
all inputs concatenated together. 
}


FrooxEngine.LogiX.Operators.PlusMinus_Float:##################################################################################################################################
{
The <color=#00FF00>+/-</color> node
Usage

Adds and subtracts the two floats at the same time. Top output adds the 2 floats together. Bottom output subtracts the 2 floats from each other. 
}

FrooxEngine.LogiX.Operators.Inc_Float:##################################################################################################################################
{
The <color=#00FF00>+1</color> node outputs the value of input A increased by 1.
Usage

When spawned from the node browser, this node accepts the float datatype by default. However, this node can be overloaded to accept various numeric value 
types if an appropriate wire is connected to the input. 
}

FrooxEngine.LogiX.Operators.LessThan_Float:##################################################################################################################################
{
The < node checks whether input A is less than B.
Usage

When spawned from the node browser, this node accepts the float datatype by default. 
However, this node can be overloaded to accept various numeric value types if an appropriate wire is connected to the input. 
This node outputs True if input A is less than input B, otherwise False. 
}

FrooxEngine.LogiX.Operators.ShiftLeft_Int:##################################################################################################################################
{

<color=#00FF00>Left Shift</color>
The << node outputs an integer that has had its binary value arithmetically shifted X units to the left. 
}


FrooxEngine.LogiX.Operators.Equals_Float:##################################################################################################################################s
{

The <color=#00FF00>==</color> node checks whether inputs A and B are equal, outputting True if they are equal and False if they are not equal.
Usage

When spawned from the node browser, this node accepts float data by default. However, this node can be overloaded to 
accept a wide variety of value and reference datatypes if an appropriate wire is connected to one of the inputs. 

}

FrooxEngine.LogiX.Operators.GreaterThan_Float:##################################################################################################################################s
{

<color=#00FF00>Greater Than</color>
The > node checks whether input A is greater than B.
Usage

When spawned from the node browser, this node accepts the float datatype by default. However, this node can be overloaded 
to accept various numeric value types if an appropriate wire is connected to the input. This node outputs True if input A is greater than input B, otherwise False. 

}


FrooxEngine.LogiX.Operators.ShiftRight_Int:##################################################################################################################################s
{
<color=#00FF00>Right Shift</color>

The >> node outputs an integer that has had its binary value arithmetically shifted X units to the right.
}


FrooxEngine.LogiX.Operators.Mul_Float:##################################################################################################################################s
{

The <color=#00FF00>×</color> node multiplies the input values by each other and outputs the product.
Usage

When spawned from the node browser, this node accepts the float datatype by default. However, this node can be overloaded to accept 
different numeric value types if an appropriate wire is connected to an input. If vector datatypes are connected, e.g. float3 values, 
the multiplication is calculated element-wise. For example, if inputs A and B are [1,2,3] and [4,5,6] are connected the output will be [4,10,18].

This node can be overloaded to accept some mixtures of datatypes. For example if a vector value (e.g. a float3, RGBA color value etc.) 
is connected to the A input a scalar value (e.g. float) can be connected to the B input. The output will be a vector with the same number 
of dimensions as A with all elements multiplied by B.

Another useful combination of datatypes allows strings to be repeated a defined number of times and concatenated together. To do this, 
connect the string to be repeated to input A and an integer (int) with the number of times the string should be repeated to input B. See below for an example.

Note that, if the number of inputs is increased above 2, it is no longer possible to perform operations with mixed datatypes.
Examples

Given the inputs "A" and 3 would result in the output string "AAA" 

}



FrooxEngine.LogiX.Operators.MulDeltaTime_Float:##################################################################################################################################s
{
The <color=#00FF00>×dT</color> node multiplies the input value by the duration of the previous frame update (in seconds).

}

FrooxEngine.LogiX.Operators.Div_Float:##################################################################################################################################s
{
The <color=#00FF00>÷</color> node divides the A input by the B input, and returns the result.
Usage

When spawned from the node browser, this node accepts the float datatype by default. However, this node can be overloaded to accept different numeric value 
types if an appropriate wire is connected to an input. With most datatypes connected, this node performs floating point division. Notably in this mode 0 ÷ 0 
outputs the special numeric value NaN. Any non-zero number divided by zero results in the special value Infinity. If integer (int) datatypes are connected, 
this node performs integer division and outputs the quotient of the result (if the remainder is required instead use % (LogiX node)).

If vector datatypes are connected, e.g. float3 values, the division is calculated element-wise. For example, if inputs A and B are [10,15,20] and [2,3,4] are 
connected the output will be [5,5,5].

This node can be overloaded to accept some mixtures of datatypes. For example if a vector value (e.g. a float3, RGBA color value etc.) is connected to the 
A input a scalar value (e.g. float) can be connected to the B input. The output will be a vector with the same number of dimensions as A with all elements divided by B. 

}


FrooxEngine.LogiX.Operators.DivDeltaTime_Float:##################################################################################################################################
{
The <color=#00FF00>÷dT</color> node divides the input value by the duration of the previous frame update (in seconds).
Usage

This node can be very useful for detemining changes (e.g. speeds) in units per second by normalising other instantaneous values. 
An example would be to connect the Character Linear Velocity (LogiX node) output to this node to get a result in metres per second.
}


FrooxEngine.LogiX.Operators.Approximately_Float:##################################################################################################################################
{
The <color=#00FF00>≈</color> nodechecks whether inputs A and B are approximately equal. If they are within the margin of error specified by the Epsilon input this node 
outputs True, otherwise False.
Usage

Due to the fact that decimal numbers often cannot be precisely encoded in binary it is unreliable to use the == (LogiX node) to attempt to test whether two floating point 
numbers are exactly equal. This node can be used in this situation to check whether two floating point numbers are approximately equal. Note that the output can 
sometimes be counterinuitive, again due to the inability to precisely encode decimal numbers in binary. For example, 0 and 0.5 are reported as not equal with an 
Epsilon of 0.5. However 0.4 and 0.9, where the difference is again 0.5, are reported as equal with the same Epsilon value.

This node can be overloaded to accept vector inputs at A and B (e.g. float 3). In that case equality comparisons are performed element-wise using the same Epsilon value for each.

Other nodes which can often be used in place of this node are ≤ or ≥. 

}


FrooxEngine.LogiX.Operators.SmallerOrEqual_Float:##################################################################################################################################
{

The ≤ node checks whether input A is less than or equal to B.
Usage

When spawned from the node browser, this node accepts the float datatype by default. However, 
this node can be overloaded to accept various numeric value types if an appropriate wire is connected to the input. 
This node outputs True if input A is less than or equal to input B, otherwise False. 


}


FrooxEngine.LogiX.Operators.GreaterOrEqual_Float:##################################################################################################################################
{

The ≥ node checks whether input A is greater than or equal to B.
Usage

When spawned from the node browser, this node accepts the float datatype by default. However, this node can be overloaded to accept various numeric value types 
if an appropriate wire is connected to the input. This node outputs True if input A is greater than or equal to input B, otherwise False.

}


FrooxEngine.LogiX.Operators.Angle_Float2:##################################################################################################################################

{

The <color=#00FF00>°</color> node outputs the smallest angle between A and B in degrees.
Usage

When spawned from the node browser, this node accepts the float2 datatype by default. However, this node can be overloaded to accept different numeric vector value types 
if an appropriate wire is connected to an input. Note that if an integer (int) vector is connected the output is still a float.

Default values for A and B are [0,0], resulting in a default output of 90. Output is always in the range 0 to 180 inclusive. 

}


FrooxEngine.LogiX.Operators.Dot_Float2:##################################################################################################################################

{

The <color=#00FF00>·</color> node calculates the dot (or scalar) product of input vectors A and B.
Usage

When spawned from the node browser, this node accepts the float2 datatype by default. However, this node can be overloaded to accept different numeric vector 
value types if an appropriate wire is connected to an input. Note that if an integer (int) vector is connected the output is still a float.
Examples

The vector dot product has a very useful property: if the input vectors are pointing in approximately the same direction the sign of the output is positive. 
Similarly the sign will be negative if the vectors point in approximately opposite directions. The value is zero if the vectors are exactly at right angles to each other. 

}


FrooxEngine.LogiX.Math.ZeroOne:##################################################################################################################################
{
The <color=#00FF00>0 1</color> node can be used to convert a Boolean value to a float.
Usage

For the Boolean input True the output is 1, for False the output is 0.
Examples

This is commonly used to convert a bool to a float for driving blendshapes. 

}



FrooxEngine.LogiX.Operators.Dec_Float:##################################################################################################################################
{

The <color=#00FF00>-1</color> node subtracts 1 from the value of input A.
Usage

By default this node accepts the float datatype, however it can cast to accept other numeric datatypes if an appropriate one is connected. 

}



FrooxEngine.LogiX.Operators.Reciprocal_Float:##################################################################################################################################
{

The <color=#00FF00>1/x</color> node outputs the reciprocal of X — or 1 divided by the input X.
Usage

By default this node accepts the float datatype, however it can be overloaded to accept various numeric value types if an appropriate wire is connected. 
If a vector datatype is connected (e.g. float3), the output will have the same number of dimensions with each element of the output being 1 divided by the 
corresponding element of the input. Note that for integer (int and related) datatypes this node performs integer division. This results in an invalid output 
which causes errors if the input is 0, output of 1 if the input is 1, and output of 0 for any other value. 

}

FrooxEngine.LogiX.Operators.OneMinus_Float:##################################################################################################################################
{

The <color=#00FF00>1-x</color> node outputs the value of X subtracted from 1.
Usage

By default this node accepts the float datatype, however it can be overloaded to accept various numeric value types if an appropriate wire is connected. 
If a vector datatype is connected (e.g. float3), the output will have the same number of dimensions with each element of the output being the corresponding element substracted from 1. 

}



FrooxEngine.LogiX.Operators.Inverse_Float2x2:##################################################################################################################################
{

The <color=#00FF00>A^-1</color> node outputs the inverse matrix of the input matrix A.
Usage

When spawned from the node browser, this node accepts the float2x2 datatype by default. However, this node can be overloaded to accept 
3x3 or 4x4 float matrices (as well as double type matrices) if appropriate wire is connected to an input. Note that not all input matrices are 
guaranteed to be invertible, the output will be a zero matrix in the case that it is not. 

}


FrooxEngine.LogiX.Operators.Cross_Float3:##################################################################################################################################
{

The <color=#00FF00>Cross</color> node calculates the cross (or vector) product of input 3-dimensional vectors A and B.
Usage

When spawned from the node browser, this node accepts the float3 datatype by default. 
However, this node can be overloaded to accept the double3 datatype if an appropriate wire is connected. 

}



FrooxEngine.LogiX.Operators.Determinant_Float2x2:##################################################################################################################################
{

The <color=#00FF00>Determinant</color> node calculates the determinant of the input matrix.
Usage

When spawned from the node browser, this node accepts the float2x2 datatype by default. 
However, this node can be overloaded to accept 3x3 or 4x4 float matrices (as well as double type matrices) 
if appropriate wire is connected to an input. 

}



FrooxEngine.LogiX.Operators.Distance_Float:##################################################################################################################################
{
Get distance by float between two object. 
}


FrooxEngine.LogiX.Operators.FilterInvalid_Float:##################################################################################################################################
{

The <color=#00FF00>Filter Invalid</color> node outputs the input Value unless it contains the special NaN or Infinity values, in which case it outputs the Fallback input.
Usage

When spawned from the node browser, this node accepts the float datatype by default. However, this node can be overloaded to accept float2/3/4/Q (or double typed variants) 
if an appropriate wire is connected to the input. Note that for vector input types the full Fallback value will be output if any of the input vector components is NaN/Infinity. 

}


FrooxEngine.LogiX.Operators.GetType:##################################################################################################################################
{

The <color=#00FF00>Get Type</color> node outputs the name of datatype of the input connection wire.
Usage

This node can be useful for determining what the datatype of an unfamiliar wire or connection point. Particularly useful with component index cards. 

}


FrooxEngine.LogiX.Operators.IsInfinity_Float:##################################################################################################################################
{

The <color=#00FF00>IsInfinity</color> node outputs True if the input value has the special numeric value Infinity, otherwise False.
Usage

When spawned from the node browser, this node accepts the float datatype by default. However, this node can be overloaded to accept float2/3/4/Q 
(or double typed variants) if an appropriate wire is connected to the input. Note that for vector input types the output is True if any component of the input Value is Infinity. 

}


FrooxEngine.LogiX.Operators.IsNaN_Float:##################################################################################################################################

{

The <color=#00FF00>IsNaN</color> node outputs True if the input value has the special numeric value NaN, otherwise False.
Usage

When spawned from the node browser, this node accepts the float datatype by default. However, this node can be overloaded to 
accept float2/3/4/Q (or double typed variants) if an appropriate wire is connected to the input. Note that for vector input types the 
output is True if any component of the input Value is NaN. 

}


FrooxEngine.LogiX.Operators.IsNullNode`1[T]:##################################################################################################################################
{

The <color=#00FF00>IsNull</color> node outputs True if the input reference datatype is null, otherwise False.
Usage

When spawned from the node browser, this node accepts the object datatype by default. However, this node can be overloaded to accept any reference datatype if an appropriate 
wire is connected.

The NotNull (LogiX node) works in the opposite way.
Examples

Using a String as an example. The string being empty outputs as True

When it's no longer empty, it'll output Fales
}



FrooxEngine.LogiX.Operators.Mask_Float2:##################################################################################################################################
{
Mask
Filtered value from Input data by bool switch. 
Bool(True/False) type input switches make output. If switch is set to all "True" then output data is equal by first input parameter.

[1, 2] is True side and [3, 4] is False side. Top switch is True. So getting top data(1) from True side. And bottom switch is set to False this is get bottom data(4) from False side. 
}


FrooxEngine.LogiX.Operators.MatrixElement_Float2x2:##################################################################################################################################
{

The <color=#00FF00>Matrix Element</color> outputs the value of the matrix element at the input Row and Column coordinates.
Usage

When spawned from the node browser, this node accepts the float2x2 datatype by default. 
However, this node can be overloaded to accept 3x3 or 4x4 float matrices (as well as double type matrices) if 
appropriate wire is connected to an input. Note that the output will be zero if one attempts to access an element which is out of range for the input matrix. 

}


FrooxEngine.LogiX.Operators.Negate_Float:##################################################################################################################################
{

The <color=#00FF00>-n</color> node outputs the value of input A multiplied by -1.
Usage

By default this node accepts the float datatype, however it can be overloaded to accept various numeric 
(including some vector and matrix) value types if an appropriate wire is connected. 

}


FrooxEngine.LogiX.Operators.NAND_Int:##################################################################################################################################
{

The <color=#00FF00>NAND</color> node performs the logical NAND operation on inputs A and B.


}



FrooxEngine.LogiX.Operators.NOR_Int:##################################################################################################################################

{

The <color=#00FF00>NOR</color> node performs the logical NOR operation on inputs A and B.
Usage

When spawned from the node browser, this node accepts the Bool datatype by default. The outputs will be True if, and only if, all inputs are False. Otherwise, it will output False. 

}



FrooxEngine.LogiX.Operators.Normalized_Float2:##################################################################################################################################
{

The <color=#00FF00>Normalized</color> node outputs a normalized version of the input vector. A normalized vector is a vector that has been divided by its 
magnitude such that the new vector has a magnitude of 1. Mathematically, this is equal to the input vector divided by the square root of the dot product of the input vector with itself.
Usage

When spawned from the node browser, this node accepts the float2 datatype by default. However, this node can be overloaded to accept different numeric value types 
if an appropriate wire is connected to an input.
Examples

Passing the vector [2, 2] as an input into the Normalized node would return the vector [1/sqrt(2), 1/sqrt(2)]. 

}


FrooxEngine.LogiX.Operators.NotNullNode`1[T]:##################################################################################################################################

{

The <color=#00FF00>NotNull</color> node outputs True if the input reference datatype is not null, otherwise False.
Usage

When spawned from the node browser, this node accepts the object datatype by default. However, this node can be overloaded to accept any reference datatype if an appropriate wire is connected.

The IsNull (LogiX node) works in the opposite way. 


}


FrooxEngine.LogiX.Operators.PackColumns_Float2x2:##################################################################################################################################

{

The <color=#00FF00>Pack Columns</color> node outputs a matrix formed via the joining of two or more input columns. The columns are joined from left to right in order 
of the input they are assigned to. The column inserted into the first input will become the leftmost column, and the column inserted into the last input will become the rightmost column. 

}


FrooxEngine.LogiX.Operators.Construct_Color:##################################################################################################################################

{

The <color=#00FF00>Pack rgba</color> node constructs a color from red, green, blue, and alpha channel float inputs.

Use the Unpack xyzw node to unpack a color to its red, green, blue, and alpha channel components. 

}



FrooxEngine.LogiX.Operators.PackRows_Float2x2:##################################################################################################################################

{

The <color=#00FF00>Pack Rows Float2x2</color> node outputs a matrix formed via the joining of two or more input rows. The rows are joined from top to bottom in order of the input they are assigned to. The row inserted into the first input will become the topmost row, and the row inserted into the last input will become the bottommost row.
Usage

When spawned from the node browser, this node accepts the float2 datatype by default. However, this node can be overloaded to accept different numeric value types if an appropriate wire is connected to an input. 

}


FrooxEngine.LogiX.Operators.Construct_Float2{Combines 2 like values into one vector.}

FrooxEngine.LogiX.Operators.Construct_Float3:##################################################################################################################################
{

Constructs a 3 composited data type from three individual inputs(Equal data types). Unconnected inputs will act as a default data by individual data types. 

Usage

This node can make every 3 composited data. But, Input data type is must same each other.
Examples

In this example Float3s are analagous to Vector3s in several other game engines. They are useful for representing several types of values, particularly 
Cartesian coordinates and Euler angle rotations. By using the Pack XYZ node, float3s can be constructed directly, allowing for manipulation of properties such as object transforms. 

}


FrooxEngine.LogiX.Operators.Construct_Float4:##################################################################################################################################
{

The Pack xyzw node constructs a 4-dimensional vector from four overrideable inputs.

(Note Quaternions use xyzw format and this is a way of building them)
}


FrooxEngine.LogiX.Operators.Project_Float2:##################################################################################################################################
{

The <color=#00FF00>Project</color> node projects vector A onto vector B and returns a new vector representing that projection. 

}


FrooxEngine.LogiX.Operators.Reflect_Float3:##################################################################################################################################
{

The <color=#00FF00>Reflect</color> node outputs vector A reflected over the axis formed by vector B.

}

FrooxEngine.LogiX.Operators.RotateLeft_Int:##################################################################################################################################

{

The <color=#00FF00>ROL</color> node outputs an integer that has had its binary value circularly shifted X units to the left. 

}


FrooxEngine.LogiX.Operators.RotateRight_Int:##################################################################################################################################

{

The <color=#00FF00>ROR</color> node outputs an integer that has had its binary value circularly shifted X units to the right.

}


FrooxEngine.LogiX.Operators.ToString_Float:##################################################################################################################################
{

The <color=#00FF00>To String Float</color> node evalutes the inputs to determine an output as a type string.
Usage

This node determines the string value of the first V input and spits out a string output.

Format provides the node with a pre-determined case of how to format the given input.

This node can be overriden with any type and accepts objects and gives a cleaned up output when given an object as input.
Examples

If given input V is of type color and you give it a Red value; it's stringed output is [1; 0; 0; 1]. This is the internal object printed out in it's string form. 
This should not be used for comparison as it is prone to break.

If given a type that it doesn't directly parse (Example here is a Slot) it'll print out clean versions of the Object type.


If given a slot it'll print out:

Slot: Slotname The slot's name itself.

Parent: Slotname The name of it's parent.


If given a bool it'll print out true or false depending on the input.

If format is provided as 0.00000 and a float input. The print out will display a float as 1.23456 If format is provided as 0.0 and a float4 input. The print out will display a float4 as [1.1; 2.2; 3.3; 4.4] 

}


FrooxEngine.LogiX.Operators.Transpose_Float2x2:##################################################################################################################################
{

The <color=#00FF00>Transpose</color> node outputs a transposed version of the input matrix.


}


FrooxEngine.LogiX.Operators.UnpackColumns_Float2x2:##################################################################################################################################

{

The <color=#00FF00>Unpack Columns</color> node unpacks a matrix into a set of columns.

}

FrooxEngine.LogiX.Operators.UnpackRows_Float2x2:##################################################################################################################################

{

The <color=#00FF00>Unpack Rows</color> node unpacks a matrix into a set of rows.


}


FrooxEngine.LogiX.Operators.Deconstruct_Float2:##################################################################################################################################

{

<color=#00FF00>Unpack xy</color>

Splits a vector with 2 components into its constituent parts. 

}

FrooxEngine.LogiX.Operators.Deconstruct_Float3:##################################################################################################################################

{

<color=#00FF00>Unpack xyz</color>

Splits a vector with 3 components into its constituent parts. 


}

FrooxEngine.LogiX.Operators.Deconstruct_Float4:##################################################################################################################################
{

<color=#00FF00>Unpack xyzw</color>

Splits a vector with 4 components into its constituent parts. 

(NOTE a Method of obtaining the values of a Quaternion aka the true rotation data from an objects interface panel)

}



FrooxEngine.LogiX.Operators.Square_Float:##################################################################################################################################

{

<color=#00FF00>X²</color>

Squares an input value. Mathematically speaking, this is the same as multiplying the input by itself. 


}

FrooxEngine.LogiX.Operators.Cube_Float:##################################################################################################################################
{

The <color=#00FF00>X³</color> outputs the value of input X cubed.
Usage

When spawned from the node browser, this node accepts float data by default. However, this node can be overloaded to accept some numeric value 
types if an appropriate wire is connected the input. X³ is equal to X times X times X. 

}


FrooxEngine.LogiX.Operators.XNOR_Int:##################################################################################################################################
{

The <color=#00FF00>XNOR</color> node performs the logical exclusive NOR (XNOR) operation on inputs A and B.


}






FrooxEngine.LogiX.Playback.PlaybackReadState:##########################################################
{
The <color=#00FF00>Playback state</color> node outputs several pieces of information about the current playback state 
of the Source clip.

Usage

The IsPlaying output is True if the Source is being played, otherwise False. Equivalent to Is Playing (LogiX node).


The Loop output is True if the Source is set to be looped when playback finishes, otherwise False. Equivalent to Is Looped (LogiX node).


The Position output provides the playback position (or progress) of the Source in seconds with microsecond precision. Equivalent to Position (LogiX node).


The NormalizedPosition output provides the playback length of the Source in seconds with microsecond precision. Equivalent to Clip Length (LogiX node).


The Speed output provides the playback speed of the Source. Equivalent to Speed (LogiX node).


Components which can be referenced as an IPlayable include Animator, AudioClipPlayer, and VideoTextureProvider. 
}




FrooxEngine.LogiX.Playback.PlaybackPlay:###############################################################
{
The <color=#00FF00>Play</color> node (re)starts playback of the Target from the beginning when an impulse is received at Play.

Usage

The OnDone output fires an impulse after an impulse is received at Play and the playback of the Target (re)starts. 
Note that this output will not fire if there is no valid Target referenced.


Components which can be referenced as an IPlayable include Animator, AudioClipPlayer, and VideoTextureProvider. 
}
FrooxEngine.LogiX.Playback.PlaybackWait:##############################################################
{
The <color=#00FF00>Wait</color> node waits for playback of the Target to finish after an impulse is received at Wait. 
When playback finishes an impulse is fired from OnFinishedWaiting

Usage

The OnWaitBegin output fires an impulse after an impulse is received at Wait. Note that this output will not fire if there is no valid Target referenced.


The OnFinishedWaiting output fires an impulse when playback of the Target stops after an impulse is received at Wait. Both pauses and full playback stops 
will cause this output to fire. If the Target is looped, this output will not fire an impulse if playback reaches the end and loops back from the start, 
however an impulse will still be fired when playback eventually finishes. The playback speed of the Target becoming 0 does not cause this output to fire.


Components which can be referenced as an IPlayable include Animator, AudioClipPlayer, and VideoTextureProvider. 
}
FrooxEngine.LogiX.Playback.PlaybackPlayAndWait:##################################################
{
The <color=#00FF00>Play & Wait</color> node (re)starts playback of the Target from the beginning for all users when an impulse is received at Play. 
This is similar to Play (LogiX node), however the impulse outputs are different.

Usage

The OnStarted output fires an impulse after an impulse is received at Play and the playback of the Target (re)starts. Note that this output will 
not fire if there is no valid Target referenced.


The OnFinishedPlaying output fires an impulse for all users when playback of the Target stops after it was (re)started by this node. Both pauses and 
full playback stops will cause this output to fire. If the Target is looped, this output will not fire an impulse if playback reaches the end and 
loops back from the start, however an impulse will still be fired when playback eventually finishes. The playback speed of the Target becoming 0 
does not cause this output to fire. Note that this output will not fire if playback of the Target is started by another node unless playback was 
initially started by Play & Wait and playback was merely restarted by another source before finally finishing.


Components which can be referenced as an IPlayable include Animator, AudioClipPlayer, and VideoTextureProvider. 
}
FrooxEngine.LogiX.Playback.PlaybackPause:#######################################################
{
The <color=#00FF00>Pause</color> node pauses playback of the Target when an impulse is received at Pause.

Usage

The OnDone output fires an impulse after an impulse is received at Pause and the Target has been paused. An impulse is fired regardless of whether 
the Target was playing when the incoming impulse was received. Note that this output will not fire if there is no valid Target referenced.

When playback of a Target is paused, the playback position is maintained. Playback can be restarted from the pause point with Resume (LogiX node), 
though consider also Pause/Resume (LogiX node).

Components which can be referenced as an IPlayable include Animator, AudioClipPlayer, and VideoTextureProvider. 
}
FrooxEngine.LogiX.Playback.PlaybackStop:#######################################################
{
The <color=#00FF00>Stop</color> node stops playback of the Target and sets the playback position to 0.

Usage

The OnDone output fires an impulse after an impulse is received at Stop and the playback of the Target stops. An impulse will be fire whether or 
not the Target was actually playing. Note that this output will not fire if there is no valid Target referenced.


Components which can be referenced as an IPlayable include Animator, AudioClipPlayer, and VideoTextureProvider. 
}
FrooxEngine.LogiX.Playback.PlaybackResume:#####################################################
{
The <color=#00FF00>Resume</color> node starts playback of the Target from the current playback position when an impulse is received at Resume.

Usage

The OnDone output fires an impulse after an impulse is received at Pause and playback of the Target has resumed. An impulse is fired regardless 
of whether the Target was playing when the incoming impulse was received. Note that this output will not fire if there is no valid Target referenced.


Components which can be referenced as an IPlayable include Animator, AudioClipPlayer, and VideoTextureProvider. 
}
FrooxEngine.LogiX.Playback.PlaybackPauseResume:########################################################
{
The <color=#00FF00>Pause/Resume</color> node toggles the playback state of the Target when an impulse is received at Pause/Resume.

Usage

The OnDone output fires an impulse after an impulse is received at Pause and the playback state of the Target has been changed. Note that this output 
will not fire if there is no valid Target referenced.

Impulses recieved at Pause/Resume will always change the Target playback state regardless of how it reached that state. e.g. The Target is playing and 
is paused by a Pause/Resume. Playback is then resumed by a Resume (LogiX node). Further impulses at PauseResume will again pause playback despite the 
fact that playback was previously resumed by a difference source.

Components which can be referenced as an IPlayable include Animator, AudioClipPlayer, and VideoTextureProvider. 
}
FrooxEngine.LogiX.Playback.PlaybackPropertiesNode // abstract
FrooxEngine.LogiX.Playback.PlaybackPropertiesOperatorNode`1[T] // abstract

FrooxEngine.LogiX.Playback.PlaybackIsPlaying:#############################################################
{
The <color=#00FF00>Is Playing</color> node outputs True if the Source clip is being played, otherwise False.

Usage

Components which can be referenced as an IPlayable include Animator, AudioClipPlayer, and VideoTextureProvider. Note that the output will still be 
True if the Source is being played even if it is not visible / audible (e.g. the relevant slot or component is disabled or deactivated, playback 
speed is set to 0 etc).
}
FrooxEngine.LogiX.Playback.PlaybackIsLooped:#############################################################
{
The <color=#00FF00>Is Looped</color> node reports the looped status of the Source clip.

Usage

Components which can be referenced as an IPlayable include Animator, AudioClipPlayer, and VideoTextureProvider. The looped status of a clip determines 
whether playback ends if the end of the clip is reached or restarts at the beginning. The looped status of a clip may be modified using the Set Loop 
(LogiX node) or via the world Inspector. 
}
FrooxEngine.LogiX.Playback.PlaybackPosition:############################################################
{
The <color=#00FF00>Position</color> node outputs the playback position (progress) of the Source clip in seconds with microsecond precision.
Usage

Components which can be referenced as an IPlayable include Animator, AudioClipPlayer, and VideoTextureProvider. 
}
FrooxEngine.LogiX.Playback.PlaybackNormalizedPosition:#################################################
{
The <color=#00FF00>Normalized Position</color> node outputs the current playback position, or playback progress, of the Source scaled by the clip length.

Usage

Components which can be referenced as an IPlayable include Animator, AudioClipPlayer, and VideoTextureProvider. The output float is always in the 
range 0 - 1 inclusive. 
}
FrooxEngine.LogiX.Playback.PlaybackSpeed:##############################################################
{
The <color=#00FF00>Speed</color> node outputs the playback speed of the Source.

Usage

Note that this will not necessarily, or normally, be zero if the Source is not being played - playback speed is set independently of whether the clip is 
being played.

Components which can be referenced as an IPlayable include Animator, AudioClipPlayer, and VideoTextureProvider. 
}
FrooxEngine.LogiX.Playback.PlaybackClipLength:#########################################################
{
The <color=#00FF00>Clip Length</color> node outputs the length of the Source clip in seconds with microsecond precision.
Usage

Components which can be referenced as an IPlayable include Animator, AudioClipPlayer, and VideoTextureProvider. 
}
FrooxEngine.LogiX.Playback.PlaybackSetter // abstract
FrooxEngine.LogiX.Playback.PlaybackSetLoop:############################################################
{
The <color=#00FF00>Set Loop</color> node sets the looped status (whether playback stops or restarts when the end of the clip is reached) of the Target 
to the value of the Loop input.

Usage

The OnDone output fires an impulse after an impulse is received at Set and the looped status of the Target has been set. An impulse is fired 
regardless of whether the looped status of the Target was changed by this action. Note that this output will not fire if there is no valid 
Target referenced.


The looped status of a Target can be changed during playback without interrupting it. However, if playback has already looped at least once, 
using Set Loop with input Loop as False will stop playback and the playback position is set to the end of the clip.

Components which can be referenced as an IPlayable include Animator, AudioClipPlayer, and VideoTextureProvider. 
}
FrooxEngine.LogiX.Playback.PlaybackSetPosition:########################################################
{
The <color=#00FF00>Set Position</color> node sets the playback position (in seconds) of the Target to the input Position.
Usage

The OnDone output fires an impulse after an impulse is received at Set and the playback position of the Target has been set. 
An impulse is fired regardless of whether the playback position of the Target was changed by this action. 
Note that this output will not fire if there is no valid Target referenced.


The playback position of a Target can be changed during playback without interrupting it and playback continues from the new position. 
However if the input Position is less than or equal to 0 playback restarts. Similarly, if Position is greater than or equal to the clip length, 
playback stops with the playback position set to the value of the clip length (or restarts if the looped status is True).

Components which can be referenced as an IPlayable include Animator, AudioClipPlayer, and VideoTextureProvider. 
}
FrooxEngine.LogiX.Playback.PlaybackSetNormalizedPosition:##############################################
{
The <color=#00FF00>Set Normalized Position</color> node sets the playback position of the Target such that the normalized playback position 
equals the NormalizedPosition input.

Usage

The OnDone output fires an impulse after an impulse is received at Set and the playback position of the Target has been set. 
An impulse is fired regardless of whether the playback position of the Target was changed by this action. 
Note that this output will not fire if there is no valid Target referenced.


The NormalizedPosition input is effectively clamped to the range 0 - 1 inclusive. This can be interpreted as a fractional position 
along the playback, i.e. if NormalizedPosition is 0.5 the playback position will be set exactly half-way along the clip.


The playback position of a Target can be changed during playback without interrupting it and playback continues from the new position. 
However if the input NormalizedPosition is less than or equal to 0 playback restarts. Similarly, if NormalizedPosition is greater than 
or equal to 1, playback stops with the playback position set to the value of the clip length.

Components which can be referenced as an IPlayable include Animator, AudioClipPlayer, and VideoTextureProvider.
}
FrooxEngine.LogiX.Playback.PlaybackSetSpeed:#########################################################
{
The <color=#00FF00>Set Speed</color> node sets the playback speed of the Target to the input Speed value.
Usage

The OnDone output fires an impulse after an impulse is received at Set and the playback speed of the Target has been set. 
An impulse is fired regardless of whether the playback speed of the Target was changed by this action. Note that this output 
will not fire if there is no valid Target referenced.


The Speed input defaults to 0 which appears to pause playback, however this is not recognised as a pause or stop event . 
A Speed value of 1 results in the standard clip playback speed. Values in the range 0 - 1 exclusive results in slowed playback. 
Values above 1 result in faster playback. Values below 0 result in reversed playback. Special float values NaN or Infinity behave the same as 0.


Components which can be referenced as an IPlayable include Animator, AudioClipPlayer, and VideoTextureProvider. 
}

FrooxEngine.LogiX.Playback.PlaybackShiftPosition:#####################################################
{
The <color=#00FF00>Shift Position</color> node changes playback position of the Target by a number of seconds equal the Delta input.
Usage

The OnDone output fires an impulse after an impulse is received at Set and the playback position of the Target has been set. 
An impulse is fired regardless of whether the playback position of the Target was changed by this action. 
Note that this output will not fire if there is no valid Target referenced.


The playback position of a Target can be changed during playback without interrupting it and playback continues from the new position. 
However playback restarts if the resulting position is less than or equal to 0. Similarly, playback stops if the resulting position 
would be greater than or equal the clip length. Position shifts for looped clips do not wrap around.

Components which can be referenced as an IPlayable include Animator, AudioClipPlayer, and VideoTextureProvider. 
}
FrooxEngine.LogiX.References.ReferenceTarget`1:#########################################################
{
The <color=#00FF00> -&gt; </color> node outputs the SyncRef reference target of the input Reference.
Usage

This node is often required when making a reference typed field from a slot or component interface available to LogiX nodes. For example when a Slot reference interface is extracted with the LogiX tooltip, the parent field must be input to this node before the Slot data it holds can be used by nodes which have a Slot type input. This is because the parent field is of type SyncRef<Slot>, rather than Slot itself. 
}


FrooxEngine.LogiX.References.AllocatingUser:############################################################
{
The <color=#00FF00>AllocatingUser</color> node outputs the User who caused the input Element to be loaded.

Usage

The default output is null. Any slot or component can be provided as inputs for this node. 
}


FrooxEngine.LogiX.References.ReferenceID:###############################################################
{
The <color=#00FF00>RefID</color> node outputs the raw RefID for the input Element.
Usage

In general it is not recommended for most users ever to use this node, see Things to Avoid.

The update notes regarding the implementation of this node were as follows (lightly edited for clarity):

    Please note that RefID is an opaque, non-persistent value (meaning its structure and meaning can change at any time, including between sessions). It's STRONGLY recommended not to work with them directly, but rather interact with typed references and nodes to extract desired data instead. If you rely on particular structure or meaning of RefID, your creations WILL break. If functionality is missing, make a request.
}

FrooxEngine.LogiX.Rendering.BakeReflectionProbe:########################################################
{
The <color=#00FF00>Bake Cubemap</color> node will (re-)bake the cubemap for the input Probe when an impulse is received at Bake.
Usage

The OnBakeStart output fires an impulse when the baking process initiates. This is the passthrough output for impulses received at Bake. Note that the baked cubemap asset Uri will not yet be available from BakedCubemapURL for the impulse chain initiated by OnBakeStart.


The OnBakeFail output fires an impulse if the baking process fails. Note that the baking process simply does not start (rather than failing) if there is no valid input Probe.


The OnBakeCompleted output fires an impulse when the baking process finishes. The baked cubemap asset Uri is available from BakedCubemapURL for the impulse chain initiated by OnBakeCompleted. 
}


FrooxEngine.LogiX.Rendering.BakeReflectionProbes:#######################################################
{
The <color=#00FF00>Bake Reflection Probes</color> node will (re-)bake the cubemaps for all ReflectionProbe components under the input Root slot's heirarchy when an impulse is received at Bake.
Usage

The Root input defines the slot hierarchy which will be searched for ReflectionProbe components to bake. Default is the world root slot.


The BakeInactive input determines whether disabled ReflectionProbe components, or ones present on inactive slots, will be baked. Default is false.


The FilterWithTag input determines can be used to only bake ReflectionProbes on slots with an exactly matching tag. This is empty by default which results in no tag-based filtering.


The DelayBeforeBake input determines the delay between baking successive ReflectionProbes in seconds. Default is 0.25 seconds.


The OnBakeBatchStart output fires an impulse when baking starts. No impulse will be fired if there is no valid (or empty) Root input, however it is not required that there be any valid ReflectionProbes to bake for an impulse to be fired.


The OnBakeBatchStart output fires an impulse immediately before the batch baking starts. No impulse will be fired if there is no valid (or empty) Root input, however it is not required that there be any valid ReflectionProbes to bake for an impulse to be fired.


The OnBeforeProbeBake output fires an impulse immediately before baking begins for each ReflectionProbe.


The OnProbeBaked output fires an impulse after each individual ReflectionProbe has been baked.


The OnBakeBatchFinished output fires an impulse after all valid ReflectionProbes have been baked.


The IsBaking output indicates whether a batch baking operation is in progress.


The CurrentProbe output provides the ReflectionProbe component which is currently being processed. This value is only available during the impulse chains started from OnBeforeProbeBake and OnProbeBaked.


The CurrentProbeIndex output provides the index of the ReflectionProble currently being processed. This value is 0 for the first probe baked in the batch, 1 for the next one and so on. The value from this output is 0 during the impulse chain started from OnBakeBatchStart and equal to the maximum index during the impulse chain started from OnBakeBatchFinished. The value will be correct for the specific ReflectionProbe processed during the impulse chains started from OnBeforeProbeBake and OnProbeBaked.


The CurrentProbeCount output provides the total number of ReflectionProbes which will be baked during the batch. This value is available during the impulse chains started from OnBeforeProbeBake, OnProbeBaked, and OnBakeBatchFinished.


Note that the node will not initate another baking batch if one is currently in progress.
}



FrooxEngine.LogiX.Rendering.RenderToTextureAsset:#######################################################
{
The <color=#00FF00>Render To Texture Asset</color> node will generate a texture using the provided camera when an impulse is received.
Usage

Upon receiving an impulse, the node will capture an image from the perspective of the provided camera, respecting the configuration of that camera. The output Uri can be written into the URL field of a StaticTexture2D component. This data is only available for the duration of the impulse chain fired from OnRendered.


The Format input refers to the file extension of the rendered image, by default this is 'webp'. Other commonly used formats include 'png', 'jpg', and 'tiff'.


The Resolution input refers to the width and height of the rendered image in pixels.


The Quality input currently only refers to the quality level of the webp format. This input ranges from 1 to 100, anything above 100 will result in a lossless image. 
}



FrooxEngine.LogiX.Rendering.SampleColor:################################################################
{
The <color=#00FF00>Sample Color</color> outputs the visible color sampled in a line along the input Direction vector from the input Origin when an impulse is received at Sample.
Usage

The color is sampled after applying all effects of lighting, shadows, emissives, alpha blending of materials etc. along the sampling direction.

The Reference input is the slot in whose local coordinate space the Origin and Direction vectors are interpreted. This is the root slot by default, meaning the global coordinate space is used.


The NearClip input sets a lower bound on the distance at which objects will be included in the sampling. Anything closer to the input Origin than the NearClip value will be ignored.


The FarClip input sets an upper bound on the distance at which objects will be included in the sampling. Anything further from the input Origin than the FarClip value will be ignored.


The OnSampleStart output fires an impulse when the sampling operation begins. This is the impulse passthrough output for the Sample input. Note that the Color output will not yet have the sampled color value!


The OnSampled output fires an impulse when the sampling operation completes. The sampled color will be available from the Color output for the duration of the impulse chain stared by OnSampled. Note that other transient values available during the impulse chain which arrives at Sample and continues from OnSampleStart may not be available during the impulse chain initiated from OnSampled.

}

FrooxEngine.LogiX.String.Capitalize:######################################################################
{
The <color=#00FF00>Capitalize</color> node outputs the input Str with the first character capitalized.
Usage

This node makes no change to the input Str unless the first character is lower-case and it has a valid upper-case variant. 
}

FrooxEngine.LogiX.String.Contains:#########################################################################
{
The <color=#00FF00>Contains</color> node outputs true if the input Str contains at least one exactly matching instance of the input Substring, otherwise false.
Usage

The output will be false if either (or both) of the inputs are empty strings or null. 
}



FrooxEngine.LogiX.String.EndsWith:#########################################################################
{
The <color=#00FF00>Ends With</color> node outputs true if the Str ends with a substring which exactly matches the input Substring, otherwise false.
Usage

The output will be false if either (or both) of the inputs are empty strings or null. 
}



FrooxEngine.LogiX.String.EscapeString:#####################################################################
{
The <color=#00FF00>Escape String</color> node escapes the provided text using the C# regex escape method.

Note: This implementation escapes whitespace. 
}


FrooxEngine.LogiX.String.FormatString:#####################################################################
{
The <color=#00FF00>Format</color> node generates the output Str by inserting the input parameters into specified points in the input Format string.
Usage

The node initially spawns with one parameter input. Use the + or - buttons on the node add or remove parameter inputs.

Parameter inputs are inserted into the Format string at positions specified by curly braces '{}'. For example, if the first parameter input Parameters.0 is a string with the value "World" and the Format string is "Hello {0}!", the output Str will be "Hello World!".

The output will be null if a pair of curly braces is present without a valid parameter value e.g. "{}" or "{1}" if there is only a Parameters.[0] input.

There are many additional options which can be used to control how parameter inputs are formatted. For these more advanced options, much of the C# documentation for the Format method is applicable. For example there are many options for formatting numeric data as detailed here. For standard time & date formatting, here For custom numeric formatting, here and custom date/time formatting, here.
}



FrooxEngine.LogiX.String.IndexOfString:####################################################################
{
The <color=#00FF00>Index Of String</color> node outputs the position index within the Str where a substring exactly matching the input Part is present.
Usage

The StartIndex defines the position within the input Str where searching for the Part begins. The default value is 0.


The SearchFromEnd input determines in which direction the search proceeds from the StartIndex. If false (the default) searching is left-to-right, otherwise it is right-to-left if true.


The default output is -1. This may occur in the event that the Str or Part is null or an empty string, or if the Part cannot be found given the current inputs.

Note that the StartIndex needs to be set to a larger value (generally the length of the Str - 1) since the reversed search still proceeds from this index! 
}


FrooxEngine.LogiX.String.IsStringEmpty:####################################################################
{
The <color=#00FF00>Is String Empty</color> node outputs true if the intput string A is either null or an empty string, otherwise false. 
}



FrooxEngine.LogiX.String.NewLine:##########################################################################
{
The <color=#00FF00>New Line</color> node outputs a newline correct for the current operating system environment.

}



FrooxEngine.LogiX.String.ReplaceFirstSubstring:############################################################
{
The <color=#00FF00>Replace First Substring</color> node outputs the input Str with the first instance of the SearchFor substring replaced with the ReplaceWith string.
Usage

The StartIndex determines which position in the input Str searching for the SearchFor substring should begin. Default is 0.


If no instance of the SearchFor substring is found after the input StartIndex, the output of this node is identical to the Str input.

If you need to replace every instance of a substring, use Replace Substring (LogiX node) instead. 
}


FrooxEngine.LogiX.String.ReplaceSubstring:#################################################################
{
The <color=#00FF00>Replace Substring</color> node outputs the input Str with every instance of the SearchFor substring replaced with the ReplaceWith string.
Usage

If no instance of the SearchFor substring is found, the output of this node is identical to the Str input. 
}


FrooxEngine.LogiX.String.ReverseString:####################################################################
{
The <color=#00FF00>Reverse String</color> node outputs the input A string with all character positions inverted.
}


FrooxEngine.LogiX.String.StartsWith:#######################################################################
{
The <color=#00FF00>Starts With</color> node outputs true if the Str starts with a substring which exactly matches the input Substring, otherwise false.
Usage

The output will be false if either (or both) of the inputs are empty strings or null. 
}



FrooxEngine.LogiX.String.StringInsert:#####################################################################
{
The <color=#00FF00>String Insert<color=#00FF00> node outputs the Str input with the Value string inserted at the StartIndex position.
Usage

If the StartIndex is out of the range of values possible for the input Str (i.e negative values or values greater than the length of Str - 1) the output is null. 
}



FrooxEngine.LogiX.String.StringJoin:#######################################################################
{
The <color=#00FF00>String Join</color> node outputs the input operand strings separated by the Separator input.

Usage

The default Separator is an empty string (i.e. no separation).


The node's default output is an empty string. 
}




FrooxEngine.LogiX.String.StringLength:#####################################################################
{
The <color=#00FF00>String Length</color> node outputs the number of characters in input string A. 
}



FrooxEngine.LogiX.String.StringRemove:#####################################################################
{
<color=#00FF00>String Remove</color>

Usage
Inputs

Str: The input string.

StartIndex: The zero-based starting character position of a substring in Str. Negative start indices are treated as if they were 0.

Length: The number of characters to remove in the string. If this input is not populated, the default is the length of Str. Negative lengths are treated as if they were 0.
Outputs

*: The input Str minus the Length that begins at StartIndex in Str. If StartIndex-Length exceeds the bounds of the input Str, the output of Str will be nulled. 

}



FrooxEngine.LogiX.String.Substring:########################################################################
{
<color=#00FF00>Substring</color>

Usage
Inputs

Str: The input string.

StartIndex: The zero-based starting character position of a substring in Str. Negative start indices are treated as if they were 0.

Length: The number of characters in the substring. If this input is not populated, the default is the length of Str. Negative lengths are treated as if they were 0.
Outputs

*: The substring of length Length that begins at StartIndex in Str. If StartIndex+Length exceeds the bounds of the input Str, the output is truncated to the end of Str. 
}



FrooxEngine.LogiX.String.TrimString:#######################################################################
{
The <color=#00FF00>Trim String</color> node outputs the input A string with any whitespace removed from the beginning and end of the input.
}


FrooxEngine.LogiX.String.UnescapeString:###################################################################
{
The <color=#00FF00>Unescape String</color> node replaces escaped characters in the input with their unescaped counterparts. This uses the C# regex unescape call.

Due to the permissiveness of the unescape method, this is valid for unescaping json string fields, and some forms of string literals in programing languages such as C, C#, and javascript.

Each language may have escape sequences (or may lack escape sequences) for this conversion to be safe, please check with your specific language specification. 
}







Math.Time.TimespanTicksNode
Math.Time.TimespanMillisecondsNode
Math.Time.TimespanSecondsNode
Math.Time.TimespanMinutesNode
Math.Time.TimespanHoursNode
Math.Time.TimespanDaysNode
Math.Time.TimespanTotalMillisecondsNode
Math.Time.TimespanTotalSecondsNode
Math.Time.TimespanTotalMinutesNode
Math.Time.TimespanTotalHoursNode
Math.Time.TimespanTotalDaysNode
{
Extracts a specific unit (such as days or seconds) from a TimeSpan.
}


Math.Time.TimeSpanFromDays
Math.Time.TimeSpanFromHours
Math.Time.TimeSpanFromMinutes
Math.Time.TimeSpanFromSeconds
Math.Time.TimeSpanFromMilliseconds
Math.Time.TimeSpanFromTicks
{
Converts a number (of seconds or days or whatever the node says) into a TimeSpan.
}

FrooxEngine.LogiX.UI.ClearFocus:########################################################################
{
The <color=#00FF00>Clear Focus</color> node closes the Neos software keyboard and finishes editing of any TextEditor when an impulse is received at Focus
Usage

The OnDone output fires an impulse when any open editing has finished as a result of an impulse recieved at Focus. An impulse is fired regardless of whether any editing was in progress.


Focused TextEditors are only closed for the user who owns the impulse.
}

FrooxEngine.LogiX.UI.DefocusFocusable:##################################################################
{
The <color=#00FF00>Defocus</color> node closes the Neos software keyboard and stops editing the Target TextEditor.
Usage

The OnDone output fires an impulse when the Target has been successfully defocused as a result of an impulse received at Defocus. An impulse is still fired even if the Target was not focused. No impulse is fired if there is no valid input Target.


The TextEditor is only defocused for the user who owns the impulse. If a TextEditor other than the Target is focused it will not be defocused if this node receives an impulse. 
}


FrooxEngine.LogiX.UI.FocusFocusable:####################################################################
{
The <color=#00FF00>Focus</color> node opens the the Neos software keyboard for editing the Target TextEditor.
Usage

The OnDone fires an impulse when the Target has been successfully focused. An impulse will not be fired if there is no valid Target input.


The TextEditor is focused only for the user who owns the impulse. 
}




FrooxEngine.LogiX.UI.HasLocalFocus:#####################################################################
{
The <color=#00FF00>Has Local Focus</color> node reports whether the local user has the input Target TextEditor focused for editing.
Usage

The output value is local, i.e. different for each user. 
}





FrooxEngine.LogiX.Math.Binary.AdderNode:#####################################################
{
The <color=#00FF00>Adder</color> node can be used to simulate the behavior of a hardware full adder circuit. It accepts two input bits plus a carry-in and returns the addition result plus a carry-out. 
}


FrooxEngine.LogiX.Math.Binary.BooleanCounter:#################################################
{
The <color=#00FF00>Boolean Counter</color> node counts the number of true/false values among the input boolean values. 
}

Math.Binary.ExtractBits_:#############################################################################
{
Converts an integer into its binary form by providing a boolean output for each bit.
}
Math.Binary.ComposeBits_:#############################################################################
{
Converts boolean values into an integer by providing a boolean input for each bit.
}
Math.Binary.HalfAsUShort:#############################################################################
Math.Binary.FloatAsUInt
Math.Binary.DoubleAsULong
{
Converts a floating point number into its binary representation by providing an integer output.

Can be combined with the extract bits node to read out the individual bits of a floating point number.

If you would like to know more about the binary representation of floating point numbers search IEEE 754 on the internet.
}
Math.Binary.UShortAsHalf:#############################################################################
Math.Binary.UIntAsFloat
Math.Binary.ULongAsDouble
{
Creates a floating point number from the binary representation of an integer.

If you would like to know more about the binary representation of floating point numbers search IEEE 754 on the internet.
}

FrooxEngine.LogiX.Input.DegToRadConstant:#####################################################
{

The <color=#00FF00>Deg -&gt; Rad</color> node 

outputs an approximation to the conversion factor used to convert angles in Degrees to angles in Radians.

Usage

To convert a value from Degrees to Radians simply multiply by this conversion factor. 

}


FrooxEngine.LogiX.Input.e_Node:#################################################################
{
The <color=#00FF00>e</color> node outputs an approximation to the mathematical constant e. 
}


FrooxEngine.LogiX.Input.RadToDegConstant:########################################################
{
The <color=#00FF00>Rad -&gt; Deg</color> node 

outputs an approximation to the conversion factor used to convert angles in Radians to angles in Degrees.

Usage

To convert a value from Radians to Degrees simply multiply by this conversion factor. 
}


FrooxEngine.LogiX.Input.PiNode:###################################################################
{
The <color=#00FF00>π</color> node outputs an approximation to the mathematical constant π. 
}



FrooxEngine.LogiX.Input.HalfPiNode:################################################################
{
The <color=#00FF00>π/2</color> node outputs an approximation to the mathematical constant π divided by 2. 
}



FrooxEngine.LogiX.Input.TauNode:#####################################################################
{
The <color=#00FF00>τ</color> node outputs an approximation to the mathematical constant τ which is equal to π multiplied by 2.
}



FrooxEngine.LogiX.Input.Phi_Node:#####################################################################
{
The Φ node outputs an approximation to the mathematical Golden Ratio. 
}






FrooxEngine.LogiX.Operators.EnumToInt`1:########################################################
{
The <color=#00FF00>Enum To Int`1</color> LogiX node converts an Enum to an integer. Typically such Enum values are properties on components.
Usage

Use this node to convert an Enum to an integer. In general, it is not a good idea to rely on the specific numeric value of an Enum. However, the integer can be used to encode the Enum for storage.
}



FrooxEngine.LogiX.Operators.IntToEnum`1:##########################################################
{
The <color=#00FF00>Int To Enum`1</color> LogiX node converts an integer into an Enum. Typically such enumerated values are properties on components.
Usage

Use this node to convert an integer to an Enum. In general, it is not a good idea to rely on the specific numeric value of an Enum. However, the integer can be used to encode the Enum for storage.

}

Root of Math folder:

FrooxEngine.LogiX.Math.Abs:######################################################
{
The <color=#00FF00>Abs</color> node takes a numeric input and outputs the non-negative value of that input. The outputted value is known as the absolute value.
Usage

When spawned from the node browser, this node accepts float data by default. However, this node can be overloaded to accept a wide variety of numeric datatypes if an appropriate wire is connected to the input. 
}



FrooxEngine.LogiX.Math.Acos:#################################################
{
The <color=#00FF00>Acos</color> node takes an input value in radians and outputs the inverse cosine of that value.

Usage

When spawned from the node browser, this node accepts float data by default. However, this node can be overloaded to accept a wide variety of numeric datatypes if an appropriate wire is connected to the input. The datatype must support decimal places due to the nature of the function. 
}


FrooxEngine.LogiX.Math.Asin:###########################################
{
The <color=#00FF00>Asin</color> node takes an input value in radians and outputs the inverse sin of that value.

Usage

When spawned from the node browser, this node accepts float data by default. However, this node can be overloaded to accept a wide variety of numeric datatypes if an appropriate wire is connected to the input. The datatype must support decimal places due to the nature of the function.
}


FrooxEngine.LogiX.Math.Atan:#####################################
{
The <color=#00FF00>Atan</color> node takes an input value as a tangent and outputs the arc tangent of that value.

Usage

When spawned from the node browser, this node accepts float data by default. However, this node can be overloaded to accept a wide variety of numeric datatypes if an appropriate wire is connected to the input. The datatype must support decimal places due to the nature of the function. 
}



FrooxEngine.LogiX.Math.Atan2:#####################################
{
The <color=#00FF00>Atan2</color> node takes inputs Y, and X, and outputs the result of the 2 input arctangent function.

Usage

When spawned from the node browser, this node accepts float data by default. However, this node can be overloaded to accept a wide variety of numeric datatypes if an appropriate wire is connected to the input. The datatype must support decimal places due to the nature of the function.

Atan2 can be used to calculate the radians that a direction is from the positive x axis on a 2d plane. Put simply, it tells you how far around a circle the point at [x, y] is.
}



FrooxEngine.LogiX.Math.Avg:#######################################
{
The <color=#00FF00>Avg</color> node takes an arbitrary number of input values and outputs the average (AKA the 'mean') of all of those values.

The average of the inputs is defined as the sum of the inputs, divided by the number of inputs.
Usage

When spawned from the node browser, this node accepts float data by default. However, this node can be overloaded to accept a wide variety of numeric datatypes if an appropriate wire is connected to the input. The datatype must support decimal places due to the nature of the function. 
}


FrooxEngine.LogiX.Math.Ceil:######################################
{
The <color=#00FF00>Ceil</color> node (short for 'ceiling') takes a numeric input and outputs that input rounded up to the next whole number.
Usage

When spawned from the node browser, this node accepts float data by default. However, this node can be overloaded to accept a wide variety of numeric datatypes if an appropriate wire is connected to the input. The datatype must support decimal places due to the nature of the function.

When providing this node with a whole number input, the output will remain unchanged. 
}


FrooxEngine.LogiX.Math.CeilToInt:##################################
{
The <color=#00FF00>Ceil To Int</color> node functions identically to Ceil_(LogiX_node), performing a ceiling function. this node takes a numeric input and outputs that input rounded up to the next whole number as an integer.
Usage

When spawned from the node browser, this node accepts float data by default. However, this node can be overloaded to accept a wide variety of numeric datatypes if an appropriate wire is connected to the input. The datatype must support decimal places due to the nature of the function.

When providing this node with a whole number input, the output will remain unchanged. 
}


FrooxEngine.LogiX.Math.Clamp:######################################
{
The <color=#00FF00>Clamp</color> node takes 3 numeric inputs and outputs the Value input clamped between the Min and Max inputs.
Usage

When spawned from the node browser, this node accepts float data by default. However, this node can be overloaded to accept a wide variety of numeric datatypes if an appropriate wire is connected to the input. 
}



FrooxEngine.LogiX.Math.Clamp01:#####################################
{
The <color=#00FF00>Clamp01</color> node functions identically to Clamp_(LogiX_node) with the exception of the Min and Max inputs being fixed at 0 and 1 respectively.

The output will be the Value input clamped between 0 and 1.
Usage

When spawned from the node browser, this node accepts float data by default. However, this node can be overloaded to accept a wide variety of numeric datatypes if an appropriate wire is connected to the input. The datatype must support decimal places due to the nature of the function. 
}



FrooxEngine.LogiX.Math.ConstantLerp:################################
{
The <color=#00FF00>Constant Lerp</color> node outputs a value that approaches the target input at a constant rate based on the speed input.
Usage

When spawned from the node browser, this node accepts float data by default. However, this node can be overloaded to accept a wide variety of numeric datatypes if an appropriate wire is connected to the input. The datatype must support decimal places due to the nature of the function.

The speed input refers to units per second. This means that if you have a target of 10, a speed of 2, and you start at 0, you will reach the target in 5 seconds.

When spawned, whether from the node browser or through duplication, the node's output is the value of its target. 
}




FrooxEngine.LogiX.Math.Quaternions.ConstantSlerp:###################
{
The <color=#00FF00>Constant Slerp</color> node functions identically to the Constant_Lerp_(LogiX_node) node but uses spherical interpolation, which is better suited for rotations.
Usage

When spawned from the node browser, this node accepts FloatQ data.

The speed input refers to degrees per second.

When spawned, whether from the node browser or through duplication, the node's output is the value of its target. 
}



FrooxEngine.LogiX.Math.Cos:##########################################
{
The <color=#00FF00>Cos</color> node takes an input value in radians and outputs the cosine of that value.

Usage

When spawned from the node browser, this node accepts float data by default. However, this node can be overloaded to accept a wide variety of numeric datatypes if an appropriate wire is connected to the input. The datatype must support decimal places due to the nature of the function. 
}



FrooxEngine.LogiX.Math.CosineLerp:###################################
{
The <color=#00FF00>Cosine Lerp</color> node outputs the value that is interpolated between A and B with the Lerp input mapped to a cosine curve. This results in a smoother interpolation than the Lerp node provides.
Usage

When spawned from the node browser, this node accepts float data by default. However, this node can be overloaded to accept a wide variety of numeric datatypes if an appropriate wire is connected to the input. The datatype must support decimal places due to the nature of the function.

}



FrooxEngine.LogiX.Math.CubicLerp:#####################################
{
The <color=#00FF00>Cubic Lerp</color> node outputs the value that is interpolated between From and To with the Lerp input mapped to a spline curve which can be contorted by paired tangent inputs (From Tangent and To Tangent). This results in a much more customizable interpolation than any other current interpolation method in LogiX, with the added work of having to define tangents.
Usage

When spawned from the node browser, this node accepts float data by default. However, this node can be overloaded to accept a wide variety of numeric datatypes if an appropriate wire is connected to the input. The datatype must support decimal places due to the nature of the function. This node does not officially support FloatQ datatype. Attempting to interpolate a FloatQ by first converting it to an Euler angle may yield unexpected results.

Each input point defined has an associated tangent, this tangent is used to define the 'velocity' at that point. This means that if you were interpolating from point A to point B the instantaneous velocity of a point at A (The start of the interpolation) would perfectly match the tangent input associated with A and would end up matching the associated tangent of B once it reaches it. 
}



FrooxEngine.LogiX.Math.Exp:###########################################
{
The <color=#00FF00>Exp</color> node takes a numeric input and outputs the result of the exponential function. The exponential function is defined as eⁿ where e is Euler's number.


Usage

When spawned from the node browser, this node accepts float data by default. However, this node can be overloaded to accept a wide variety of numeric datatypes if an appropriate wire is connected to the input. The datatype must support decimal places due to the nature of the function. 
}




FrooxEngine.LogiX.Math.Floor:##########################################
{
The <color=#00FF00>Floor</color> node takes a numeric input and outputs that input rounded down to the next whole number. More information can be found on the wiki page for Floor And Ceiling Functions.
Usage

When spawned from the node browser, this node accepts float data by default. However, this node can be overloaded to accept a wide variety of numeric datatypes if an appropriate wire is connected to the input. The datatype must support decimal places due to the nature of the function.

When providing this node with a whole number input, the output will remain unchanged.

}



FrooxEngine.LogiX.Math.FloorToInt:#####################################
{
The <color=#00FF00>Floor To Int</color> node functions identically to Floor_(LogiX_node), performing a floor function. This node takes a numeric input and outputs that input rounded down to the next whole number as an integer.
Usage

When spawned from the node browser, this node accepts float data by default. However, this node can be overloaded to accept a wide variety of numeric datatypes if an appropriate wire is connected to the input. The datatype must support decimal places due to the nature of the function.

When providing this node with a whole number input, the output will remain unchanged.

}


FrooxEngine.LogiX.Math.GreatestCommonDivisor:############################
{
The <color=#00FF00>Greatest Common Divisor</color> Int node
(the largest positive integer that divides each of the integers) --- Wikipedia
}


FrooxEngine.LogiX.Math.InverseLerp:#######################################
{
The <color=#00FF00>Inverse Lerp</color> node returns how far along the Value input is to getting to the To input from the From input. This can be quite difficult to intuitively grasp so here's a helpful tutorial!
Usage

When spawned from the node browser, this node accepts float data by default. However, this node can be overloaded to accept a wide variety of numeric datatypes if an appropriate wire is connected to the input. 
}


FrooxEngine.LogiX.Math.IsBetween:##########################################
{
The <color=#00FF00>Is Between</color> node takes 3 inputs and returns true if the 'Value' input is between the 'Min' and 'Max' inputs. It also returns true if the 'Value' input is equal to either the 'Min' or 'Max' inputs.
Usage

When spawned from the node browser, this node accepts float data by default. However, this node can be overloaded to accept a wide variety of numeric datatypes if an appropriate wire is connected to the input. 
}



FrooxEngine.LogiX.Math.LeastCommonMultiple:#################################
{
The <color=#00FF00>Least Common Multiple</color> Int node

(is the smallest positive integer that is divisible by both a and b.[1][2] Since division of integers by zero is undefined, this definition has meaning only if a and b are both different from zero.[3] However, some authors define lcm(a,0) as 0 for all a, since 0 is the only common multiple of a and 0. ) --- Wikipedia
}


FrooxEngine.LogiX.Math.Lerp:#################################################
{
The <color=#00FF00>Lerp</color> node takes 3 inputs and returns the linearly interpolated value between the 'From' and 'To' inputs by the 'Lerp' input.
Usage

When spawned from the node browser, this node accepts float data by default. However, this node can be overloaded to accept a wide variety of numeric datatypes if an appropriate wire is connected to the input. 
}


FrooxEngine.LogiX.Math.Log:###################################################
{
The <color=#00FF00>Log</color> node outputs the natural logarithm of N. 
}



FrooxEngine.LogiX.Math.LogN:###################################################
{
The <color=#00FF00>Log N</color> node outputs the logarithm of N according to a specified base. 
}



FrooxEngine.LogiX.Math.Log10:###################################################
{
The <color=#00FF00>Log10</color> node outputs the base-10 logarithm of N.
}


FrooxEngine.LogiX.Math.Max:######################################################
{
The <color=#00FF00>Max</color> node takes a series of numeric inputs and outputs the highest value in that series. When a multi-dimensional value is inputted the node will output the highest value in each dimension separately from the inputs.
Usage

When spawned from the node browser, this node accepts float data by default. However, this node can be overloaded to accept a wide variety of numeric datatypes if an appropriate wire is connected to the input. 
}

FrooxEngine.LogiX.Math.Min:#######################################################
{
The <color=#00FF00>Min</color> node takes a series of numeric inputs and outputs the lowest value in that series. When a multi-dimensional value is inputted the node will output the lowest value in each dimension separately from the inputs.
Usage

When spawned from the node browser, this node accepts float data by default. However, this node can be overloaded to accept a wide variety of numeric datatypes if an appropriate wire is connected to the input. 
}


FrooxEngine.LogiX.Math.MultiLerp:##################################################
{
The <color=#00FF00>Multi Lerp</color> node is the same as Lerp_(LogiX_node) but takes an arbitrary number of inputs.
Usage

When spawned from the node browser, this node accepts float data by default. However, this node can be overloaded to accept a wide variety of numeric datatypes if an appropriate wire is connected to the input.

The Lerp range is equal to the number of input points minus one. This means that if you have 5 input points then you will reach the final value once the Lerp input is 4. This is because the node functions by interpolating between the individual inputs 2 at a time, essentially working like a regular Lerp_(LogiX_node) in the process.

Suppose you have 3 inputs now, to interpolate between the first 2 inputs, you would need to supply a Lerp value which is between 0 and 1. Similarly, to interpolate between the second and third input, you will need to supply a Lerp value which is between 1 and 2. 
}


FrooxEngine.LogiX.Math.MultiSlerp:################################################
{
The <color=#00FF00>Multi Slerp</color> node behaves identically to the Slerp_(LogiX_node) but accepts an arbitrary number of inputs. 
}



FrooxEngine.LogiX.Math.NthRoot:####################################################
{
The <color=#00FF00>Nth</color> Root node outputs the Nth root of the input value. 
}



FrooxEngine.LogiX.Math.PingPong:###################################################
{
The <color=#00FF00>Ping Pong</color> Float node

(Smooth transition incrementation and decrementation between 2 states forming a triangle waveform as the input value increases.

(Basically the output value "Ping Pongs" up and down in value as the input value increases))
}


FrooxEngine.LogiX.Math.Pow:#########################################################
{
The <color=#00FF00>Pow</color> node outputs a number N raised to a specified power.
}


FrooxEngine.LogiX.Math.Remap:#######################################################
{
The <color=#00FF00>Remap</color> node linearly maps one numerical interval to another interval.
Usage
Examples

An input interval of [-1, 1], an output interval of [0, 1], and an input value of -0.5 would result in the output 0.25. This is because -0.5 represents a fourth of the difference between -1 and 1 and is thus remapped to a fourth of the difference between 0 and 1. 
}



FrooxEngine.LogiX.Math.Remap11_01:##################################################
{
The <color=#00FF00>Remap -1..1 to 0..1</color> node linearly maps the numerical interval [-1, 1] to the interval [0, 1]. This is commonly used for remapping trigonometric functions onto an exclusively positive interval. This node behaves similarly to the Remap node but includes the aforementioned intervals by default. 
}


FrooxEngine.LogiX.Math.Repeat:#######################################################
{
The <color=#00FF00>Repeat</color> node in the Math category takes two arguments, N and Length and outputs the result of the following calculation

    N - floor(N/Length) * Length

so that the output goes between 0 and Length in a repeating fashion, as described in Usage. 

Usage

This node repeats values between 0 and Length, as N is increased. When N is 0, the output is 0, and then the output increases with N, until N reaches the value Length, and it goes to 0, and repeats this pattern for ever. This pattern looks like a positive-valued sawtooth wave as shown below, for a value of Length=2.2 


Note: This node behaves in the same way as Modulus operator (denotes %) in other programming languages, like Python. LogiX uses the different definition of % which C# uses, and therefore offers the Repeat node when the above behaviour is desired.

The Repeat01 (LogiX node) is equivalent to this node, where Length is set to 1. 

}


FrooxEngine.LogiX.Math.Repeat01:#######################################################
{
The <color=#00FF00>Repeat01</color> node in the Math category takes one argument Value, and does the same operation as the Repeat (LogiX node) where N is set to Value and Length is set to 1, that is it outputs

    Value - floor(Value)

This means that the output goes between 0 and 1 in a repeating fashion, as described in Usage.

Usage

This node repeats values between 0 and 1, as N is increased. When N is 0, the output is 0, and then the output equals N as N increases, until N reaches the value 1, and the output goes to 0, and repeats this pattern for ever. This pattern looks like a positive-valued sawtooth wave as shown below, 
}



FrooxEngine.LogiX.Math.Round:##########################################################
{
The <color=#00FF00>Round</color> node outputs the value N rounded to the nearest integer. Note that this node returns an float instead of an integer. Because floating-point errors can occur when using floats, this node may offer less precision and reliability than would otherwise be attainable with the Round To Int node. 
}


FrooxEngine.LogiX.Math.RoundToInt:#####################################################
{
The <color=#00FF00>Round To Int</color> node outputs the value N rounded to the nearest integer. Note that this node returns an integer instead of a rounded float. Because floating-point errors can occur when using floats, this node can offer greater precision and reliability than would otherwise be attainable with the Round node. 
}



FrooxEngine.LogiX.Math.SigmoidNode:#####################################################
{
The <color=#00FF00>Sigmoid</color> node returns the output of the Sigmoid function according to E[Clarification needed] and a specified power.

(The sigmoid function forms an S shaped graph, which means as x approaches infinity, the probability becomes 1, and as x approaches negative infinity, the probability becomes 0. The model sets a threshold that decides what range of probability is mapped to which binary variable.) --- educative.io

}

FrooxEngine.LogiX.Math.Sign:############################################################
{
The <color=#00FF00>Sign</color> Float node 
}


FrooxEngine.LogiX.Math.SimplexNoise:#####################################################
{
The <color=#00FF00>Simplex Noise</color> node outputs simplex noise according to a specified 1D input coordinate. 
}


FrooxEngine.LogiX.Math.Sin:###############################################################
{
The <color=#00FF00>Sin</color> node takes an input value in radians and outputs the sine of that value.
Usage

When spawned from the node browser, this node accepts float data by default. However, this node can be overloaded to accept a wide variety of numeric datatypes if an appropriate wire is connected to the input. The datatype must support decimal places due to the nature of the function. 
}


FrooxEngine.LogiX.Math.Slerp:##############################################################
{
The <color=#00FF00>Slerp</color> node performs a spherical linear interpolation between two floatQs. This is useful for interpolating rotation accurately using quaternions. 
}


FrooxEngine.LogiX.Math.SmoothLerp:#########################################################
{
The <color=#00FF00>Smooth Lerp</color> node smoothly interpolates from it's current value to a specified target value at a given speed. 

Usage

When spawned, the Smooth Lerp node's default data type is float. This can be overloaded to accept the float2, float3, float4, and Color data types by plugging the desired data types into the Target input.

Using a floatQ data type will automatically change the node into a Smooth Slerp logix node, which cannot normally be accessed inside of the Node Browser.

When spawned, whether from the node browser or through duplication, the node's output is the value of its target.

Common uses of this node include:

    Smooth translations of an object's Position or Scale over time.
    Smooth transitions of one color to another over time.
}



FrooxEngine.LogiX.Math.Sqrt:###############################################################
{
The <color=#00FF00>Sqrt</color> node takes a Float input and then outputs the calculated square root.
}



FrooxEngine.LogiX.Math.Tan:################################################################
{
The <color=#00FF00>Tan</color> node returns the output of the tangent function according to an input in radians. 
}



FrooxEngine.LogiX.Math.Delta:##############################################################
{
The △ node takes an input and will output the delta or difference in value per frame of the given input.
Usage

When spawned from the node browser, this node accepts float data by default. However, this node can be overloaded to accept a wide variety of numeric datatypes if an appropriate wire is connected to the input. 
}

FrooxEngine.LogiX.Math.TorqueEstimateNode:###########################################################
{
The <color=#00FF00>Torque Estimate</color> node 
}


FrooxEngine.LogiX.Math.TrajectoryNode:#################################################################
{
The <color=#00FF00>Trajectory</color> node solves for the positional displacement of a projectile according to a set of parameters. This node can be used to help simulate the parabolic motion of a projectile.
Usage

The output of the node (Float3 position) is the position the object will be at relative to the origin at the time that is input at the Time input (Float time), which takes an input of where in time during the trajectory arc you want to have the position of

The gravity input (Float3 gravity) will be how fast the position will move in the direction input at a constant acceleration, generally the standard being a Float3 of (0, -9.81, 0), which results in normal earth gravity on the y axis

Initial Velocity (Float3 intialvelocity) will be your velocity you want it to have at time 0, or when the movement should start

Drag (Float drag) is needed if you want air resistance over time. This can usually be disregarded by setting the value to near zero, however a value of 0 will break the calculations so a value greater than 0 has to be put in 
}FrooxEngine.LogiX.Math.Quaternions.ToAxisAngle_:######################################################
{
The <color=#00FF00>Axis Angle</color> LogiX node converts a rotation represented as an axis-angle to the native quaternion representation. The first input is the axis about which to rotate, and the second input is the angle in degrees to rotate clockwise (positive) or counterclockwise (negative) about the axis by.
Usage

Use this node to convert rotation about an arbitrary axis into a quaternion which can then be used in further computations or used as an object's rotation input.
Examples

Here we have a door with a Door Pivot child placed on the hinge side of the door. We can drive the Door Pivot object's Rotation property (a quaternion) with the Axis Angle node's output (also a quaternion). We specify rotation about the Y axis (the green axis), and 0 degrees of rotation: 

By changing the rotation amount to -60 degrees, we rotate the object 60 degrees counterclockwise. 

}



FrooxEngine.LogiX.Math.Quaternions.EulerAngles_:#####################################################
{
The <color=#00FF00>Euler Angles</color> LogiX node converts a a rotation represented as a native quaternion to an ZYX-ordered Euler angle representation. That is, the object is first rotated about its Z axis, then rotated about its Y axis, then rotated about its X axis.
Usage

Use this node to convert a quaternion into ZYX Euler rotation.
Examples

Here we specify -60 degrees of rotation about the Y axis using an Axis Angle node, then feed the result to the Euler Angles node: 

In the above example, the output representation is -60 degrees of rotation about the Y axis. 
}



FrooxEngine.LogiX.Math.Quaternions.FromEuler_:#######################################################
{
The <color=#00FF00>From Euler</color> node converts a float3 representing the three Euler angles into a floatQ.
}


FrooxEngine.LogiX.Math.Quaternions.FromToRotation_:##################################################
{
The <color=#00FF00>From To Rotation</color> LogiX node creates a rotation represented as a native quaternion which rotates the first (From) vector to the second (To) vector.
Usage

This node can be used to apply a rotation so that the From vector, e.g. a vector along the Y axis, follows a target direction (the To vector).
Examples

Here we want a rotation that rotates a vector along the X axis to a point along a vector halfway between the X and Y axes, or in other words, points the X vector in that direction. 

The resulting rotation is 45 degrees about the Z axis. 

}



FrooxEngine.LogiX.Math.Quaternions.InverseRotation_:##################################################
{
The <color=#00FF00>Inverse Rotation</color> LogiX node creates a rotation represented as a native quaternion which is the opposite of the rotation represented by its input quaternion.
Usage

This node can be used to apply an inverse rotation.
Examples

Here we want a rotation that that is the opposite of a 45 degree rotation about the X axis.

Inverse Rotation Example.jpg 

The resulting rotation is 45 degrees about the -X axis, which is equivalent to a rotation -45 degrees about the X axis. 
}



FrooxEngine.LogiX.Math.Quaternions.LookRotation_:####################################################
{
The <color=#00FF00>Look Rotation</color> LogiX node creates a rotation represented as a native quaternion which will rotate an object such that its Z axis points in the direction of the Forward vector, and its Y axis points in the direction of the component of the Up vector that doesn't point in the direction Forward vector. More technically, the object's X axis will point in the direction of the cross-product of the Forward and Up vectors.
Usage

This node can be used to turn an object to face another object, while keeping its "top" generally facing in the same direction.
Examples

The Z axis of an object is generally considered its "forward" axis and its Y axis is its "up" axis. For example, suppose we had an avatar whose nose was pointing in the Z axis ("forward"), with the top of its head in the Y axis ("up"). However, now we want the avatar to rotate its head so that its nose was pointing along the X axis while still remaining with the top of its head pointing up.

Look Rotation example.jpg

The required head rotation is 90 degrees about the Y axis. 
}




FrooxEngine.LogiX.Math.Quaternions.ToAxisAngle_:######################################################
{
The <color=#00FF00>To Axis Angle</color> LogiX node converts a rotation represented as a native quaternion to an axis-angle representation. The first output is the axis about which to rotate, and the second output is the angle in degrees to rotate clockwise (positive) or counterclockwise (negative) about the axis by.

Note that there are two valid axis-angle representations of a rotation: positive rotation about an axis, and negative rotation about the opposite axis. Which is chosen by To Axis Angle is effectively random.
Usage

Use this node to convert a quaternion into rotation about a specific axis.
Examples

Here we specify -60 degrees of rotation about the Y axis using an Axis Angle node, then feed the result to the To Axis Angle node:

To Axis Angle and Euler Angles example.jpeg

In the above example, the output representation is 60 degrees of rotation about the -Y axis, which is equivalent to -60 degrees of rotation about the +Y axis. 
}


