FrooxEngine.LogiX.Actions.DecrementFloatNode:#############################################################################
{
The <color=#00FF00>--</color> node reduces the referenced <b>Target</b> value by one when it receives an impulse at <b>Decrement</b>.
Usage

The <b>OnDone</b> output fires an impulse when the <b>Target</b> value has been decremented. 
An impulse will not fire if there is no valid <b>Target</b>. This impulse continues the impulse chain which arrived at <b>Decrement<b>.

This node differs from the -1 node under Operators since it only makes changes when it receives an impulse. 
This makes it useful for decrementing a target value (e.g. one stored in a variable node or component e.g. a ValueField) 
in a way which is saved and synchronized across all users. 
If the aim is to decrement a value locally as part of a LogiX calculation the -1 node is likely the better choice. 
}

FrooxEngine.LogiX.Actions.IncrementFloatNode:#############################################################################
{
The <color=#00FF00>++</color> node increases the referenced Target value by one when it receives an impulse at Increment.
Usage

The OnDone output fires an impulse when the Target value has been incremented. 
An impulse will not fire if there is no valid Target. This impulse continues the impulse chain which arrived at Increment.


This node differs from the +1 node under Operators since it only makes changes when it receives an impulse. 
This makes it useful for incrementing a target value (e.g. one stored in a variable node or component e.g. a ValueField) 
in a way which is saved and synchronized across all users. 
If the aim is to increment a value locally as part of a LogiX calculation the +1 node is likely the better choice. 
}


FrooxEngine.LogiX.Actions.DriveValueNode`1[T]:############################################################################
{
The <color=#00FF00><b>Drive</b></color> node will start driving the referenced DriveTarget with the input Source value when an impulse is received at StartDrive. 
The drive can be stopped by an impulse received at StopDrive.

Usage:

The Source input has a 'dummy' datatype when the node is spawned from the node browser. However, the node will overload to the correct value type when a suitable wire is connected.


The OnStartDrive output fires an impulse whenever an impulse arrives at the StartDrive input. This continues the impulse chain which arrived at StartDrive.


The OnStopDrive output fires an impulse whenever an impulse arrives at the StopDrive input. This continues the impulse chain which arrived at StopDrive.


The OnHook fires an impulse whenever the DriveTarget is driven with the Source value and another source (e.g. a Write node or ButtonValueSet component) 
attempts (but is not able) to overwrite the value.


The IsDriving output is True while the DriveTarget is driven with the Source value, otherwise False.


The HookedValue output provides the value which another source attempted to set the DriveTarget to when an impulse is fired from OnHook. 
The value is only available for the duration of the impulse chain started from OnHook.


Note that, when an impulse is received at StartDrive the drive target will become driven by the Source value regardless of whether it was 
already driven by some other source i.e. control of the target value is overridden. 
}


FrooxEngine.LogiX.Actions.DrivePlaybackNode:############################################################################
{

The <color=#00FF00><b>Drive Playback node</b></color> can be used to directly control the rate of playback of the DriveTarget. 
Since this is a drive, it is possible to localise the speed of playback, or even whether the clip is played at all, for differnt users. 

Inputs

When an impulse is received at StartDrive, the node will start driving the playback state of the DriveTarget. 
This gives exclusive control over the playback state to the Drive Playback node. Control will be taken over if the DriveTarget was previously driven by another source.


When an impulse is received at StopDrive, the node will stop driving the playback state of the DriveTarget. Playback will continue in the same state as it was just before driving stopped.


The ForceResync input will force the normalised position of the DriveTarget to the NormalizedPosition input value when an impulse is received.


The NormalizedPosition input controls the rate/state of playback. Default is 0.


The MaximumPositionError value is the maximum number of seconds that the DriveTarget playback position can deviate from the absolute playback position corresponding to 
NormalizedPosition input. The normalized playback position will be reset to the NormalizedPosition if the absolute playback position error is greater than MaximumPositionError. 
Default is 0.


The Speed input scales the rate of playback relative to the rate of change of the NormalizedPosition input, i.e. rate of normalized position change in the DriveTarget 
is equal to rate of change of NormalizedPosition multiplied by the Speed. If this has a value of 1, the default, the rate of change of DriveTarget playback normalized 
position is equal to the rate of change of NormalizedPosition. At higher, lower, or negative values the DriveTarget normalized playback position will start to deviate 
from the NormalizedPosition, resulting in altered playback speed, until the absolute playback position error is greater than the MaximumPositionError.


The Play input controls whether the DriveTarget playback position changes if NormalizedPosition is changing. Default is False.


The Loop input controls whether playback will restart from the beginning if the DriveTarget's normalized position is greater than or equal to 1. Default is False.
Outputs

The OnStartDrive output fires an impulse when an impulse is received at StartDrive. This continues the impulse chain which arrived at StartDrive.


The OnStopDrive output fires an impulse when an impulse is received at StopDrive. This continues the impulse chain which arrived at StopDrive.


The IsDriving output is True if the DriveTarget's playback is being driven by the Drive Playback node, otherwise False. 

}


FrooxEngine.LogiX.Animation.Tweening.TweenValueNode`1[T]:###########################################################################
{

The <color=#00FF00><b>Tween</b></color> node is used to interpolate the value of Target starting at From, and ending at To over Duration seconds when an impulse is received at Tween.
Usage

When an impulse is received at Tween a [Tween (Component)|Tween]] component is created which drives the referenced Target value over the duration.

The To value determines the final value reached at the end of the Duration.


The From value determines the initial value at the start of the Duration.


The Duration input determines how long the transition from From to To takes in seconds. Default is 1.


The CurvePreset determines the shape of the interpolated values. Default is Smooth.


The OnStarted output fires an impulse when tweening of the Target begins as a result of an impulse received at Tween. An impulse will not be fired if there is no valid Target. 
This impulse continues the impulse chain which arrived at Tween.


The OnDone output fires an impulse when tweening of the Target has finished. This does not continue the impulse chain which arrived at Tween.


Note that only one tween operation for the Target can be active at any time. Currently target value changes work via sequential writes to the value which may not appear smooth 
depending on framerates and network latency. Similar, potentially smoother, effects can be achieved with e.g. the various Lerp nodes under Category:LogiX:Math 


}


FrooxEngine.LogiX.Actions.WriteValueNode`1[T]:####################################################################################
{

The <color=#00FF00><b>Write</b></color> node overwrites the referenced Target value with the input Value when an impulse is received at Write.
Usage

When spawned from the node browser, the Value input has a dummy datatype. This will overload to match the input data type when a valid input is connected. 
The input type and that of the referenced Target must match.


The OnDone output fires an impulse when the Target value has been successfully overwritten after an impulse was received at Write or the Target value 
is driven by a system which allows an attempted written variable to be hooked (e.g. Drive node, ValueCopy component, etc.). This impulse continues the 
impulse chain which arrived at Write.


The OnFail output fires an impulse when the Target value could not be set, e.g. if the Target value is driven from another source which does not allow 
hooking of the written value, or if there is no valid Target. This impulse continues the impulse chain which arrived at Write.


Changing the value of a Variable node, Component field etc. via a Write node results in a datamodel change which will then be synchronised to other 
users in the session. Note that changes are only synchronised at the end of every update so, if multiple writes to the same target are performed by a 
single client within an update, only the final value will be sent. Additionally, no changes will be broadcast if the value is reset to the value it held 
at the beginning of an update. Due to this synchronisation process, it is inadvisable to write to a value very regularly (e.g. every update) unless absolutely 
necessary. It is generally better to use the Drive system instead for continuously changing values to avoid unnecessary network traffic. Source.

Generally, with a Write/Write Latch node, one can only write to component or slot fields which are value-typed (e.g. bools, ints, strings, floats), 
whereas reference-typed fields (e.g. slot, user, IAssetProvider<AudioClip> etc.) require Write Ref. However, it is possible to write to reference-typed 
LogiX variable nodes using a Write/Write Latch node where it isn't possible to do so with Write Ref. It is also possible to write to reference-typed fields 
using Write/Write Latch if the input SetValue and ResetValue are RefIDs, rather than reference datatypes - it is generally not recommended to work with raw RefIDs though. 

}

FrooxEngine.LogiX.WriteLatch`1[T]:##################################################################################################
{

The <color=#00FF00><b>Write Latch</b></color> node node overwrites the referenced Target value with the input SetValue or ResetValue when an impulse is received at Set or Reset respectively.
Usage

When spawned from the node browser, the SetValue and ResetValue inputs have a dummy datatype. This will overload to match the input data type when a valid input is connected. 
The type of these two inputs and that of the referenced Target must match.


The OnSet output fires an impulse after an impulse is received at Set. This occurs regardless of whether there is a valid Target or whether any Target was actually written to. 
This continues the impulse chain which arrived at Set.


The OnReset output fires an impulse after an impulse is received at Reset. This occurs regardless of whether there is a valid Target or whether any Target was actually 
written to. This continues the impulse chain which arrived at Reset.


Changing the value of a Variable node, Component field etc. via a Write Latch node results in a datamodel change which will then be synchronised to other users in the session. 
Note that changes are only synchronised at the end of every update so, if multiple writes to the same target are performed by a single client within an update, only the final value 
will be sent. Additionally, no changes will be broadcast if the value is reset to the value it held at the beginning of an update. Due to this synchronisation process, 
it is inadvisable to write to a value very regularly (e.g. every update) unless absolutely necessary. It is generally better to use the Drive system instead for continuously 
changing values to avoid unnecessary network traffic. Source.

Generally, with a Write/Write Latch node, one can only write to component or slot fields which are value-typed (e.g. bools, ints, strings, floats), whereas reference-typed fields 
(e.g. slot, user, IAssetProvider<AudioClip> etc.) require Write Ref. However, it is possible to write to reference-typed LogiX variable nodes using a Write/Write Latch node where 
it isn't possible to do so with Write Ref. It is also possible to write to reference-typed fields using Write/Write Latch if the input SetValue and ResetValue are RefIDs, 
rather than reference datatypes - it is generally not recommended to work with raw RefIDs though.
Examples

These two images illustrate comparable LogiX setups using either one Write Latch node or two Write nodes. Note that the presence of the OnFail impulse output and different 
behaviour of OnDone and OnFail compared with OnSet and OnReset means that the two setups are not exactly identical. 

}


FrooxEngine.LogiX.Actions.WriteReferenceNode`1[T]:#####################################################################################
{

The <color=#00FF00><b>Write Ref</b></color> node overwrites the Reference with a reference to the input Target when an impulse is received at Write.
Usage

When spawned from the node browser, the Target input has a general IWorldElement datatype. It is recommended to overload the node to the 
required datatype by first connecting the Reference output to the target field before connecting an input to Target. This is because any reference type 
can be cast to IWorldElement which is not, generally, the datatype of the intendend target field.


The OnDone output fires an impulse when the Reference target value has been successfully overwritten after an impulse was received at Write or 
the Reference target value is driven by a system which allows an attempted written variable to be hooked (e.g. ReferenceCopy component, etc.). 
This impulse continues the impulse chain which arrived at Write.


The OnFail output fires an impulse when the Reference target value could not be set, e.g. if the Reference target value is driven from another source 
which does not allow hooking of the written value, or if there is no valid Reference target. This impulse continues the impulse chain which arrived at Write.


Changing the value of a Component field etc. via a Write Ref node results in a datamodel change which will then be synchronised to other users in the session. 
Note that changes are only synchronised at the end of every update so, if multiple writes to the same target are performed by a single client within an update, 
only the final value will be sent. Additionally, no changes will be broadcast if the value is reset to the value it held at the beginning of an update. 
Due to this synchronisation process, to avoid unnecessary network traffic it is inadvisable to write to a target very regularly (e.g. every update) unless absolutely necessary . Source.

Generally one should write to component or slot fields which are reference-typed (e.g. slot, user, IAssetProvider<AudioClip> etc.) 
using Write Ref. However, it is not possible to write to reference-typed LogiX variable nodes using a Write Ref node whereas it is 
possible to do so with Write/Write Latch. It is also possible to write to reference-typed fields using Write/Write Latch if the inputs are RefIDs, 
rather than reference datatypes. However, it is generally not recommended to work with raw RefIDs though - better to use Write Ref with the correct datatypes. 

}


FrooxEngine.LogiX.Actions.WriteRefLatch`1[T]:##########################################################################################
{

The <color=#00FF00><b>Write Ref Latch</b></color> node node overwrites the target reference with the input SetReference or ResetReference 
when an impulse is received at Set or Reset respectively.
Usage

When spawned from the node browser, the SetReference and ResetReference have a IWorldElement datatype. This will overload to match the input reference 
type when a valid input is connected. The type of these two inputs and that of the referenced Target must match.


The OnSet output fires an impulse after an impulse is received at Set. This occurs regardless of whether there is a valid Target or whether any 
Target was actually written to. This continues the impulse chain which arrived at Set.


The OnReset output fires an impulse after an impulse is received at Reset. This occurs regardless of whether there is a valid Target or 
whether any Target was actually written to. This continues the impulse chain which arrived at Reset. 

}

































FrooxEngine.LogiX.Assets.AttachAsset`1
FrooxEngine.LogiX.Assets.SampleAnimationTrack`1



FrooxEngine.LogiX.Assets.AttachAudioClip:###############################################################
{
The  <color=#00FF00>Attach Audio Clip</color> node creates an AudioClipProvider component on the Target slot and fills the component's URL field with the input URL.
Usage

If the GetExisting input is True this will not produce components which are exact duplicates of existing ones currently under the slot (i.e. the existing component's URL field is identical to the node's URL input).


The newly attached StaticAudioClip component is available from the AttachedProvider output for the duration of the impulse chain started by OnAttached. 
}


FrooxEngine.LogiX.Assets.AttachMesh:####################################################################
{
The <color=#00FF00>Attach Mesh</color> node creates a StaticMesh component under the Target slot and fills the component's URL field with the input URL.
Usage

If the GetExisting input is True this will not produce components which are exact duplicates of existing ones currently under the slot (i.e. the existing component's URL field is identical to the node's URL input).


The newly attached StaticMesh component is available from the AttachedProvider output for the duration of the impulse chain started by OnAttached. 
}



FrooxEngine.LogiX.Assets.AttachSprite:##################################################################
{
The <color=#00FF00>Attach Sprite</color> node creates a StaticTexture2D component on the Target slot and fills the component's URL field with the input URL. A SpriteProvider component is also created whose Texture field is filled with a reference to the newly created StaticTexture2D component.
Usage

If the GetExisting input is True this will not produce components which are exact duplicates of existing ones currently under the slot (i.e. the existing component's URL field is identical to the node's URL input). The input URL should be for a 2D image asset.


The newly attached SpriteProvider component is available from the AttachedProvider output for the duration of the impulse chain started by OnAttached. 
}




FrooxEngine.LogiX.Assets.AttachTexture2D:###############################################################
{
The <color=#00FF00>Attach Texture2D</color> node creates a StaticTexture2D component under the Target slot and fills the component's URL field with the input URL.
Usage

If the GetExisting input is True this will not produce components which are exact duplicates of existing ones currently under the slot (i.e. the existing component's URL field is identical to the node's URL input).


The newly attached StaticTexture2D component is available from the AttachedProvider output for the duration of the impulse chain started by OnAttached. 
}



FrooxEngine.LogiX.Assets.BakeMeshes:###################################################################
{
The <color=#00FF00>Bake Meshes</color> node creates a new single mesh as a combination of all meshes under the Root input slot's hierarchy. Specific behaviour depends significantly on the input values, see Usage.
Usage

When an impulse is received at Bake, and with all default bool inputs, this node creates a new slot whose name is the name of the original Root input slot with " - Baked" appended. This slot contains MeshRenderer, Grabbable, and MeshCollider components. The MeshRenderer and MeshCollider components' Mesh field is filled with a reference to the newly baked mesh. This is a combination of all meshes previously referenced by enabled MeshRenderer/SkinnedMeshRenderer components under any active slots under the input Root slot's hierarchy. The MeshRenderer component contains references to the materials previously present on the individual meshes; if these are subsequently changed, the changes only affect the part of the baked mesh which was originally affected by the changed material.


If the IncludeInactive input is True (False by default) the baked mesh will also include any meshes on inactive slots under the input Root slot's hierarchy. Inactive meshes will be visible in the final baked mesh.


If the Undoable input is True (False by default), the baking event can be undone using the Undo button on the radial context menu.


If the DestroyOriginal input is False (True by default) the original Root input slot (and all of its children) is not destroyed after baking.


It is recommended to take care with the Undoable and DestroyOriginal options, by default this node will destroy the Root slot, along with its children, in an event which cannot be undone!. It is also important to consider the number of triangles which the eventual baked mesh will contain - MeshColliders for high-poly meshes can impose a significant performance cost. 
}


FrooxEngine.LogiX.Assets.FindAnimationTrackIndex:#######################################################
{
The <color=#00FF00>Find Animation Track Index</color> node finds the index of an animation track based on the input node and property names. 
}




FrooxEngine.LogiX.Assets.FormatLocaleString:############################################################
{
The <color=#00FF00>Format Locale String</color> node displays a given key's localized text according to the provided locale.
}



FrooxEngine.LogiX.Assets.GetTexture2D_Pixel:############################################################
{
The <color=#00FF00>Get Texture 2D Pixel</color> node returns the color of a pixel by locating it on the input 2D texture according to the specified position. This node is distinct from from the Sample Texture2D UV node as it accepts an int2 instead of an float2; this ensures the sampling remains constrained to individual pixels rather than being interpolated across pixels.
Usage

Texture is the texture you want to sample a pixel from. Position is the 2D coordinate (starting from the bottom left of the texture) of the pixel you want to return the color value of.

}



FrooxEngine.LogiX.Assets.GetTexture3D_Pixel:###########################################################
{
The <color=#00FF00>Get Texture 3D Pixel</color> node returns the color of a pixel by locating it on the input 3D texture according to the specified position. This node is distinct from from the Sample Texture3D UVW node as it accepts an int3 instead of an float3; this ensures the sampling remains constrained to individual pixels rather than being interpolated across pixels.
Usage

Texture is the texture you want to sample a pixel from. Position is the 3D coordinate (starting from the bottom left of the texture) of the pixel you want to return the color value of.

}



FrooxEngine.LogiX.Assets.LocaleMessageCount:###########################################################
{
The <color=#00FF00>Locale Message Count</color> node outputs the number of messages for the input locale.

Usage

Locale is the locale you want to get the message count of. Count is the message count of the locale. 
}




FrooxEngine.LogiX.Assets.SampleTexture2D_UV:###########################################################
{
The <color=#00FF00>Sample Texture2D UV</color> node samples the color of a pixel by locating it on the input 2D texture according to the specified position in UV space. This node is distinct from from the Get Texture 2D Pixel node as it accepts a float2 instead of an int2; this lets the sampling be interpolated across pixels rather than being constrained to individual pixels.
Usage

Texture is the texture you want to sample a pixel from. Position is the coordinate of the point you want to sample in UV space, where the components of the input float2 range from 0.0 to 1.0. WrapMode defines whether the texture should wrap around UV space.

}



FrooxEngine.LogiX.Assets.SampleTexture3D_UVW:##########################################################
{
The <color=#00FF00>Sample Texture3D UVW</color> node samples the color of a pixel by locating it on the input 3D texture according to the specified position in UVW space. This node is distinct from from the Get Texture 3D Pixel node as it accepts a float3 instead of an int3; this lets the sampling be interpolated across pixels rather than being constrained to individual pixels.
Usage

Texture is the texture you want to sample a pixel from. Position is the coordinate of the point you want to sample in UVW space, where the components of the input float3 range from 0.0 to 1.0.

}



FrooxEngine.LogiX.Assets.Texture2D_Format:#############################################################
{
The <color=#00FF00>Texture 2D Format</color> node provides specific information about the input texture.

Usage

Texture is the input texture you want to use. Size is the texture's width and height. Format is the formatting type of the texture. MipMapCount is the number of mip maps the texture is using. 
}



FrooxEngine.LogiX.Assets.Texture3D_Format:#############################################################
{
The <color=#00FF00>Texture 3D Format</color> node provides specific information about the input 3D texture.

Usage

Texture is the input texture you want to use. Size is the size of the texture. Format is the formatting type of the texture.
}














FrooxEngine.LogiX.Audio.AudioClipInput:#################################################################
{
The <color=#00FF00>Audio Clip</color> node stores a reference to a an audio file for use with Play One Shot (LogiX node) and Play One Shot & Wait (LogiX node).

Usage

The easiest way to store a reference to an audio clip with this node is to grab an audio player orb and release while the laser is hovering over the Audio Clip Input node - essentially "drag and drop". If the node has a reference stored it will display the clip name on the node's visual. 

}


FrooxEngine.LogiX.Audio.PlayOneShot:####################################################################
{
The <color=#00FF00>Play One Shot</color> node plays the input Clip once when an impulse is received at Play. The manner in which the clip is played is highly configurable.

Usage
Inputs

The Clip input determines which clip will be played. The easiest method to specify this is to use an Audio Clip Input node.


The Volume controls the base volume with which the clip is played. Default is 1, i.e. full volume.


The Speed controls the speed with which the clip is played. Default is 1, i.e. standard playback speed.


The Spatialize input determines whether the audio source is spatialized within the world (i.e it sounds like it originates from a specific point) or non-spatialized. Note that this value can be overridden if the SpatialBlend is specified. Default is True.


The SpatialBlend input can be used to set an intermediate spatialization value. A value of 0 results in completely non-spatialized playback, a value of 1 results in fully spatialized playback, and values between these extremes result in the playback being partially spatialized. Note that this value, if specified, will override any Spatialize input. Default is 1.


The Point sets the origin point from which any spatialized audio will originate. This is interpreted as [X;Y;Z] coordinates in the local coordinate space of the Root input slot. Default is [0;0;0].


The Root input sets the slot relative to whose local coordinate space the Point value is interpreted. Default is the Play One Shot node's slot.


The Priority input sets the priority level of the spawned audio output. In the event too many audio outputs are present in a world, this is used to select which outputs are silenced. Higher priority outputs (i.e. priority number is lower) take precedence over ones with lower priority. Default is 128 (medium priority, lowest possible value is 256).


The Doppler input determines the strength of the simulated Doppler effect. Default is 1 (i.e. Doppler effect is applied), set this to 0 to disable.


The MinDistance input determines the distance (in metres) from the sound source at which volume rolloff begins. This only takes effect if the Rolloff value is Linear. Note that this input value is scaled depending on the DistanceSpace input - if that is set to Global then the MinDistance value is interpreted in global coordinate space, if set to Local it is interpeted in local coordinate space which may then be affected by the scale of the audio output. Default is 1.


The MaxDistance input determines the distance (in metres) from the sound source at which volume rolloff ends and the sound becomes inaudible. This only takes effect if the Rolloff value is Linear. Note that this input value is scaled depending on the DistanceSpace input - if that is set to Global then the MinDistance value is interpreted in global coordinate space, if set to Local it is interpeted in local coordinate space which may then be affected by the scale of the audio output. Default is 500.


The Rolloff input determines the volume rolloff mode used for the audio output. This must be set to Linear for MinDistance and MaxDistance to take effect. Default is Logarithmic.


The Group input determines what volume group the played audio is categorized under. Default is Sound Effects.


The DistanceSpace input determines whether scale and distance values are interpreted relative to global coordinates or local coordinates. Default is Global.


The MinScale input determines the MinScale field value on the spawned AudioOutput.


The MaxScale input determines the MaxScale field value on the spawned AudioOutput.


The ParentUnderRoot input determines whether the spawned "OneShotAudio" slot is parented directly under the input Root slot. If set to False, the "OneShotAudio" slot will be parented under the world root slot. Default is True.


The LocalOnly input determines whether the played audio will only be audible for the local user who owns the impulse arriving at Play. Default is False.
Outputs

The OnStartedPlaying output fires an impulse when the one shot audio has started playing as a result of an impulse at Play. This fires as long as a valid Clip input is present and continues the impulse chain which arrived at Play.
Notes

When an impulse is received at Run, and a valid Clip is available, a new non-persistent slot is spawned called "OneShotAudio" with AudioOutput, AudioClipPlayer, and StoppedPlayableCleaner components. This slot is automatically deleted when playback ends.

Play One Shot is an excellent playback option for audio which should play to completion after some trigger. This is because it prevents cluttering the limited audio buffer unless the relevant sound effect is actually playing. Play One Shot may not be ideal for situations where triggers occur extremely rapidly (e.g. in the case of an automatic weapon) due to the network traffic required to spawn and delete slots and components. In situations like those, consider using a persistent AudioOutput and AudioClipPlayer and using nodes under Category:LogiX:Playback instead. 

}


FrooxEngine.LogiX.Audio.PlayOneShotAndWait:############################################################
{
The <color=#00FF00>Play One Shot & Wait</color> node plays the input Clip when an impulse is received at Play. The difference from Play One Shot (LogiX node) is the additional OnFinishedPlaying impulse output. 

Usage
Inputs

The Clip input determines which clip will be played. The easiest method to specify this is to use an Audio Clip Input node.


The Volume controls the base volume with which the clip is played. Default is 1, i.e. full volume.


The Speed controls the speed with which the clip is played. Default is 1, i.e. standard playback speed.


The Spatialize input determines whether the audio source is spatialized within the world (i.e it sounds like it originates from a specific point) or non-spatialized. Note that this value can be overridden if the SpatialBlend is specified. Default is True.


The SpatialBlend input can be used to set an intermediate spatialization value. A value of 0 results in completely non-spatialized playback, a value of 1 results in fully spatialized playback, and values between these extremes result in the playback being partially spatialized. Note that this value, if specified, will override any Spatialize input. Default is 1.


The Point sets the origin point from which any spatialized audio will originate. This is interpreted as [X;Y;Z] coordinates in the local coordinate space of the Root input slot. Default is [0;0;0].


The Root input sets the slot relative to whose local coordinate space the Point value is interpreted. Default is the Play One Shot node's slot.


The Priority input sets the priority level of the spawned audio output. In the event too many audio outputs are present in a world, this is used to select which outputs are silenced. Higher priority outputs (i.e. priority number is lower) take precedence over ones with lower priority. Default is 128 (medium priority, lowest possible value is 256).

The Doppler input determines the strength of the simulated Doppler effect. Default is 1 (i.e. Doppler effect is applied), set this to 0 to disable.


The MinDistance input determines the distance (in metres) from the sound source at which volume rolloff begins. This only takes effect if the Rolloff value is Linear. Note that this input value is scaled depending on the DistanceSpace input - if that is set to Global then the MinDistance value is interpreted in global coordinate space, if set to Local it is interpeted in local coordinate space which may then be affected by the scale of the audio output. Default is 1.


The MaxDistance input determines the distance (in metres) from the sound source at which volume rolloff ends and the sound becomes inaudible. This only takes effect if the Rolloff value is Linear. Note that this input value is scaled depending on the DistanceSpace input - if that is set to Global then the MinDistance value is interpreted in global coordinate space, if set to Local it is interpeted in local coordinate space which may then be affected by the scale of the audio output. Default is 500.


The Rolloff input determines the volume rolloff mode used for the audio output. This must be set to Linear for MinDistance and MaxDistance to take effect. Default is Logarithmic.


The Group input determines what volume group the played audio is categorized under. Default is Sound Effects.


The DistanceSpace input determines whether scale and distance values are interpreted relative to global coordinates or local coordinates. Default is Global.


The MinScale input determines the MinScale field value on the spawned AudioOutput.


The MaxScale input determines the MaxScale field value on the spawned AudioOutput.


The ParentUnderRoot input determines whether the spawned "OneShotAudio" slot is parented directly under the input Root slot. If set to False, the "OneShotAudio" slot will be parented under the world root slot. Default is True.


The LocalOnly input determines whether the played audio will only be audible for the local user who owns the impulse arriving at Play. Default is False.
Outputs

The OnStartedPlaying output fires an impulse when the one shot audio has started playing as a result of an impulse at Play. This fires as long as a valid Clip input is present and continues the impulse chain which arrived at Play.


The OnfinishedPlaying output fires an impulse when the one shot audio has finished playing. This does not continue the impulse chain which arrived at Play.
Notes

When an impulse is received at Run, and a valid Clip is available, a new non-persistent slot is spawned called "OneShotAudio" with AudioOutput, AudioClipPlayer, and StoppedPlayableCleaner components. This slot is automatically deleted when playback ends.

Play One Shot is an excellent playback option for audio which should play to completion after some trigger. This is because it prevents cluttering the limited audio buffer unless the relevant sound effect is actually playing. Play One Shot may not be ideal for situations where triggers occur extremely rapidly (e.g. in the case of an automatic weapon) due to the network traffic required to spawn and delete slots and components. In situations like those, consider using a persistent AudioOutput and AudioClipPlayer and using nodes under Category:LogiX:Playback instead. 
}


Avatar Folder Root:

FrooxEngine.LogiX.Avatar.BodyNodeSlot:##################################################################
{
The <color=#00FF00>Body Node Slot</color> node outputs the NodeSlot slot corresponding to the input Node on the avatar of the Source user.
Usage

The Source input defaults to the local user - meaning that the NodeSlot output would be different on each user's client.


In the case of the default Node input, or if there is no corresponding slot for the input on the Source user's avatar, the NodeSlot output is null. 
}


FrooxEngine.LogiX.Avatar.DefaultUserScale:##############################################################
{
The <color=#00FF00>Default User Scale</color> node gets the input user's default scale. 
}



FrooxEngine.LogiX.Avatar.EquipAvatar:###################################################################
{
The <color=#00FF00>Equip Avatar</color> node equips the avatar given by the AvatarRoot input for the input User when an impulse is received. 

Usage

This node equips the avatar for the user without moving the user - this behavior is akin to equipping an avatar from the inventory directly instead of equipping an avatar spawned into the world. If DestroyOld is True the user's previously equipped avatar is destroyed once the new avatar is equipped. 
}


FrooxEngine.LogiX.Avatar.FingerPose:####################################################################
{
The <color=#00FF00>Finger Pose</color> node.

Usage

Allows you to pull the transform without the scale of the fingers. 
}


FrooxEngine.LogiX.Avatar.NearestUserHand:###############################################################
{
The color=#00FF00>Nearest User Hand</color> node.


Usage

Allows you to get the nearest hand slot and which hand it is to the references slot and if there is nothing in the references slot it uses itself as the references. 
}

FrooxEngine.LogiX.Avatar.NearestUserHead:###############################################################
{
The <color=#00FF00>Nearest User Head</color> node.


Usage

Allows you to get the nearest head slot on an occupied avatar to the center of the referenced slot. If there is nothing in the reference slot the node will use itself as the reference. Operates very similar to Nearest User Hand (LogiX node) except for finding a head instead of hand.
}


FrooxEngine.LogiX.Avatar.UserFingerPoseSource:##########################################################
{
The <color=#00FF00>User Finger Pose Source</color> node.

Usage

Allows you to get the IFingerPoseSource from a user. 

}


######/Anchors############

FrooxEngine.LogiX.Avatar.AnchorEvents:##################################################################
{
The <color=#00FF00>Anchor Events</color> node fires an impulse from OnAnchored when a user enters the referenced input AvatarAnchor and fires an impulse from OnReleased when a user exits the anchor.


Usage

A reference to the user either entering or exiting the anchor is available for the duration of the impulse chain triggered from OnAnchored or OnReleased. 
}



FrooxEngine.LogiX.Avatar.AnchorLocomotionData:#########################################################
{
The <color=#00FF00>Anchor Locomotion Data</color> node.


Usage

LocomotionUpdate is an impulse that fires every time one of the values is updated. It also returns the user inputs on the anchor. 
}


FrooxEngine.LogiX.Avatar.AnchorUser:###################################################################
{
The <color=#00FF00>Anchor User node</color> anchors the input User at the input Anchor when an impulse is received at DoAnchor. 

Usage

Allows you to put a user on an Anchor. 
}




FrooxEngine.LogiX.Avatar.AnchoredUser:#################################################################
{
The <color=#00FF00>Anchored User</color> node outputs a reference to the user anchored at the referenced input Anchor.

Usage

Default output if a user is not anchored at Anchor is null. 
}


FrooxEngine.LogiX.Avatar.GetUserAnchor:################################################################
{
The <color=#00FF00>Get User Anchor</color> node outputs a reference to the anchor at which the input User is anchored.

Usage

Default output if the User is not anchored is null. 
}


FrooxEngine.LogiX.Avatar.IsUserAnchored:###############################################################
{
The <color=#00FF00>Is User Anchored</color> node outputs a boolean value depending on whether the input User is anchored.


Usage

Allows you to check if a user is in an Anchored. 
}



FrooxEngine.LogiX.Avatar.ReleaseUser:##################################################################
{
The <color=#00FF00>Release User</color> node releases a user from the referenced Anchor when an impulse is received at DoRelease.

Usage

An impulse will not be fired from OnReleased unless a user was released as a result of an impulse at DoRelease. 
}



#########/BodyNode#################

FrooxEngine.LogiX.Utility.BodyNodeChirality:###########################################################
{
The <color=#00FF00>Chirality</color> node outputs the chirality value (Left/Right) of the input Node.
Usage

For body nodes which do not have a chirality (e.g. Hips) the output is -1. 
}



FrooxEngine.LogiX.Utility.ComposeFinger:###############################################################
{
The <color=#00FF00>Compose Finger</color> node output the BodyNode corresponding to the input Finger, Segment, and Chirality values.

Usage

Default values for Finger, Segment, and Chirality are Thumb, Metacarpal, and Left respectively. Therefore the default output value is LeftThumb_Metacarpal. 
}


FrooxEngine.LogiX.Utility.FingerNodeIndex:#############################################################
{
The <color=#00FF00>Finger Node Index</color> node outputs the integer value corresponding to the input Node regardless of it's chirality.
Usage

Node to int mappings are:

    Thumb_Metacarpal - 0
    Thumb_Proximal - 1
    Thumb_Distal - 2
    Thumb_Tip - 3
    IndexFinger_Metacarpal - 4
    IndexFinger_Proximal - 5
    IndexFinger_Intermediate - 6
    IndexFinger_Distal -7
    IndexFinger_Tip - 8
    MiddleFinger_Metacarpal - 9
    MiddleFinger_Proximal - 10
    MiddleFinger_Intermediate - 11
    MiddleFinger_Distal - 12
    MiddleFinger_Tip - 13
    RingFinger_Metacarpal - 14
    RingFinger_Proximal - 15
    RingFinger_Intermediate - 16
    RingFinger_Distal - 17
    RingFinger_Tip - 18
    Pinky_Metacarpal - 19
    Pinky_Proximal - 20
    Pinky_Intermediate - 21
    Pinky_Distal - 22
    Pinky_Tip - 23

To convert these int values into their BodyNode Enum equivalents, add 19 for Left side or 48 for right side. 
}


FrooxEngine.LogiX.Utility.GetFingerSegmentType:########################################################
{
The <color=#00FF00>Finger Segment</color> node outputs the finger segment name for the given Node.
Usage

Possible output values, if the input Node is a finger, are: Metacarpal, Proximal, Intermediate, Distal, or Tip.

The value is -1 for all Node values which are not fingers.

}



FrooxEngine.LogiX.Utility.GetFingerType:###############################################################
{
The <color=#00FF00>Finger Type</color> node outputs the finger type value for the input Node.
Usage

Possible output values, if the input Node is a finger, are: Thumb, Index, Middle, Ring, or Pinky.

The value is -1 for all Node values which are not fingers. 
}


FrooxEngine.LogiX.Utility.GetBodyNodeSide:#############################################################
{
The <color=#00FF00>Get Side</color> node outputs the BodyNode value corresponding to the input Node with the specified Side.
Usage

For any input Node which has a chirality, this outputs either that Node value or the corresponding one with the opposite chirality depending on the input Side. If the input Node has no chirality the output is NONE.

For example, with the input Node LeftController and Side Left the output will be LeftController. However, with the input Node LeftController and Side Right the output will be RightController 
}




FrooxEngine.LogiX.Utility.IsBodyNodeEye:###############################################################
{
The <color=#00FF00>Is Eye</color> node outputs True if the input Node is either LeftEye or RightEye, otherwise False. 
}



FrooxEngine.LogiX.Utility.GetBodyNodeOtherSide:########################################################
{
The <color=#00FF00>Other Side</color> node outputs the BodyNode corresponding to the Node with opposite chirality.

Usage

For example, if Node is LeftController, the output is RightController. For input Node values without a chirality the output is NONE. 
}


FrooxEngine.LogiX.Utility.RelativeBodyNode:############################################################
{
The <color=#00FF00>Relative Body Node</color> node outputs the Root BodyNode unless the Node is an Eye, Palm, or Finger node.

Usage

If the input Node is an Eye the output is Head. If it is either a Palm or Finger the output is the Hand of the same chirality. If the input is NONE, so is the output. 
}







FrooxEngine.LogiX.Color.ColorHue:################################################################
{
Generates a color using hue from a float value ranging from 0 to 1. (0 is 0 degrees 1 is 360 degrees)

If the provided value is above 1 or below 0 it will be looped similarly to how the repeat node works.
}


FrooxEngine.LogiX.Color.HSV_ToColor:################################################################
FrooxEngine.LogiX.Color.HSL_ToColor
{
Converts 3 float values into a color using either the HSV or HSL format, inputs should be ranging from 0 to 1.

If you would like to learn more about the HSV and HSL formats you can look it up online.
}

FrooxEngine.LogiX.Color.ColorSetRed:################################################################
FrooxEngine.LogiX.Color.ColorSetGreen
FrooxEngine.LogiX.Color.ColorSetBlue
FrooxEngine.LogiX.Color.ColorSetAlpha
FrooxEngine.LogiX.Color.ColorSetHue
FrooxEngine.LogiX.Color.ColorSetSaturation
FrooxEngine.LogiX.Color.ColorSetValue
{
Sets a certain channel of a color to the provided value.
}

FrooxEngine.LogiX.Color.ColorMulRed:################################################################
FrooxEngine.LogiX.Color.ColorMulGreen
FrooxEngine.LogiX.Color.ColorMulBlue
FrooxEngine.LogiX.Color.ColorMulRGB
FrooxEngine.LogiX.Color.ColorMulAlpha
FrooxEngine.LogiX.Color.ColorMulHue
FrooxEngine.LogiX.Color.ColorMulSaturation
FrooxEngine.LogiX.Color.ColorMulValue
{
Multiplies a certain channel of a color by the provided value.
}

FrooxEngine.LogiX.Color.ColorAddRed:################################################################
FrooxEngine.LogiX.Color.ColorAddGreen
FrooxEngine.LogiX.Color.ColorAddBlue
FrooxEngine.LogiX.Color.ColorAddRedHDR
FrooxEngine.LogiX.Color.ColorAddGreenHDR
FrooxEngine.LogiX.Color.ColorAddBlueHDR
FrooxEngine.LogiX.Color.ColorAddAlpha
FrooxEngine.LogiX.Color.ColorAddHue
FrooxEngine.LogiX.Color.ColorAddSaturation
FrooxEngine.LogiX.Color.ColorAddValue
FrooxEngine.LogiX.Color.ColorAddValueHDR
{
Adds the provided value to a certain channel of the color.

HDR Variants of these nodes do nothing, except for Add Value which will clamp the RGB values between 0 and 1 while the HDR variant ignores this restriction.
}

FrooxEngine.LogiX.Color.ColorLuminance:################################################################
{
Calculates the luminance of a color.

This is done by multiplying the red channel by 0.2126, the green channel by 0.7152 and the blue channel by 0.0722 and adding the 3 resulting values together.
}
FrooxEngine.LogiX.Color.ColorAlphaBlend:################################################################
// TODO Add better descirption here
{
Determines how 2 colors would be combined in an alpha blend environment.
}
FrooxEngine.LogiX.Color.ColorAdditiveBlend:################################################################
{
Determines how 2 colors would be combined in an additive environment.

This is done by adding the RGBA values together, then limiting the alpha channel to not exceed 1, this limitation is not applied in the negative direction.
}
FrooxEngine.LogiX.Color.ColorMultiplicativeBlend:################################################################
{
Determines how 2 colors would be combined in a multiplicative environment.

This is done by multiplying each channel together.
}
FrooxEngine.LogiX.Color.ColorSoftAdditiveBlend:################################################################
{
Determines how 2 colors would be combined in a soft additive environment.

Assuming that the first input is labelled A and the 2nd one B the formula for this operation goes as follows:
((1 - B.rgb) * A.rgb) + B.rgb
The alpha channel is simply added together, but limited to not exceed 1.
}
FrooxEngine.LogiX.Color.BlackBodyColor:################################################################
{
Determines what color a blackbody would be under a certain amount of temperature (in Kelvin).
}

FrooxEngine.LogiX.Color.ColorToHSL:################################################################
{
The <color=#00FF00>To HSL</color> takes an input color C and decomposes it into the 
corresponding H (hue), S (saturation) and L (lightness) values.

Usage

HSL format is an alternative way to specify colors in the RBG colorspace - see HSL and HSV.


Note that the default input is [0,0,0,0] which gives default output of H = NaN, S = 0 and V = 0. Values of [0,0,0,*] or [1,1,1,*] give NaN as the H output which has the potential to cause unexpected behavior with downstream calculations etc. 
}



FrooxEngine.LogiX.Color.ColorToHSV:################################################################
{
The <color=#00FF00>To HSV</color> takes an input color C and decomposes it into the 
corresponding H (hue), S (saturation) and V (value) values.

Usage

HSV format is an alternative way to specify colors in the RBG colorspace - see HSL and HSV.


Note that the default input is [0,0,0,0] which gives default output of H = NaN, S = 0 and L = 0. 
Values of [0,0,0,*] or [1,1,1,*] give NaN as the H output which has the potential to cause unexpected behavior with downstream calculations etc. 
}



FrooxEngine.LogiX.Color.ColorFromHexCode:##########################################################
{
The <color=#00FF00>Color From Hex Code</color> node outputs a color corresponding to the input HexCode.
Usage

Hexadecimal color codes are commonly used to specify RGB(A) colors in text format, particularly for 
usage on webpages and rich text.


The input HexCode string can include, but does not require, a leading #. If there are only 3 hex values 
(i.e. only RGB is specified) the output alpha value is 1.


The Parsed output indicates whether the HexCode can be successfully parsed to a color.


The default output color is [0,0,0,0] which corresponds to completely transparent black. 
This is output whenever the input cannot be parsed as a valid HexCode. 
}


FrooxEngine.LogiX.Color.ColorToHexCode:##############################################################
{
The <color=#00FF00>Color To Hex Code</color> node outputs a hexadecimal code corresponding to the input RGB(A) Color.
Usage

Default Color output is #000000 which corresponds to black.


If IncludeAlpha is True (False by default) a trailing fourth pair of hexadecimal values is added which encodes the alpha input value.


If ShortForm is True (false by Default) the output corresponding to each of R, G and B (and alpha if IncludeAlpha is True) is scaled and rounded so as to be represented as a single hexadecimal digit.


The Prefix input is prepended to the output string (# by default). 
}


FrooxEngine.LogiX.Color.InvertColor:################################################################
{
The <color=#00FF00>Invert</color> node inverts the RGB channels of the input color.
}


FrooxEngine.LogiX.Components.SetComponentEnabled:##########################################################
{
The <color=#00FF00>Set Component Enabled</color> node node sets the Enabled property of the input Component to the State input value when an impulse is received at Set.
Usage

The State input determines what value the target Component's Enabled property is set to. If this is not specified, this node will not change the Enabled value if an impulse is received at Set.


The OnDone output fires an impulse when the Enabled property of the input Component has been set as a result of an impulse recieved at Set. An impulse is fired as long as a valid Component input is provided regardless of whether the Enabled property value was actually changed. 
}


FrooxEngine.LogiX.Components.GetComponentEnabled:##########################################################
{
The <color=#00FF00>Get Component Enabled</color> node outputs true if the Enabled property of input Component is true, otherwise false. 
}Math.Time.DatetimeMillisecondNode
Math.Time.DatetimeSecondNode
Math.Time.DatetimeMinuteNode
Math.Time.DatetimeHourNode
Math.Time.DatetimeDayNode
Math.Time.DatetimeMonthNode
Math.Time.DatetimeYearNode
Math.Time.DatetimeTicksNode
Math.Time.DatetimeDayOfWeekNode
Math.Time.DatetimeDayOfYearNode
{
Extracts a specific unit (such as days or seconds) from a DateTime.
}
Math.Time.TimespanTicksNode
Math.Time.TimespanMillisecondsNode
Math.Time.TimespanSecondsNode
Math.Time.TimespanMinutesNode
Math.Time.TimespanHoursNode
Math.Time.TimespanDaysNode
Math.Time.TimespanTotalMillisecondsNode
Math.Time.TimespanTotalSecondsNode
Math.Time.TimespanTotalMinutesNode
Math.Time.TimespanTotalHoursNode
Math.Time.TimespanTotalDaysNode
{
Extracts a specific unit (such as days or seconds) from a TimeSpan.
}
Math.Time.ConstructDateTime
{
Creates a DateTime from a bunch of inputs such as days or seconds.
Also allows changing the "Kind" which can be either "Unspecified", "Utc" or "Local", this will change how the DateTime is displayed to other users.
}
Math.Time.DatetimeKindNode
{
Gets the kind of a DateTime.
The kind can be either "Unspecified", "Utc" or "Local", this will change how the DateTime is displayed to other users.
}
Math.Time.SetDatetimeKindNode
{
Changes the kind of a DateTime.
The kind can be either "Unspecified", "Utc" or "Local", this will change how the DateTime is displayed to other users.
}
Math.Time.FromUnixSeconds
Math.Time.FromUnixMilliseconds
{
Converts unix (mili)seconds into a DateTime.

Unix time is time since January 1st 1970.
}
Math.Time.ToUnixSeconds
Math.Time.ToUnixMilliseconds
{
Converts a DateTime into unix (mili)seconds.

Unix time is time since January 1st 1970.
}
Math.Time.ToUniversalTime
{
Converts a DateTime to use the Utc kind, which means each user will see it the same way.
}
Math.Time.ToLocalTime
{
Converts a DateTim to use the Local kind, which means each user will see it in their own timezone.
}


Math.Time.LocalTimeOffset
Math.Time.UserTimeOffset
{
Provides the time zone offset of a certain user.
}
Math.Time.UserTime
{
Provides the time for a certain user, for example if it's 8 AM in the plugged in user's timezone it will say 8 AM for everyone else too.
}
FrooxEngine.LogiX.Debug.DebugAxes:#########################################################################
{
The <color=#00FF00>Debug Axes</color> node generates a temporary set of axes with the specified properties when an impulse is received at Display.
Usage

The Position determines the global position where the axis origin will be.


The Rotation determines the global rotation of the axes.


The Length determines the length of the axis arrow visuals.


The RightColor sets the color of the X axis visual.


The UpColor sets the color of the Y axis visual.


The ForwardColor sets the color of the Z axis visual.


The Duration determines the number of seconds that the axes are visible.


The OnDisplay output fires an impulse when the axes are successfully displayed.


Slots for the debug visuals are produced under a non-persistent slot under the root slot named '_DEBUG'. Children are produced under that slot for each individual user for whom a debug node fires.
}


FrooxEngine.LogiX.Debug.DebugBox:##########################################################################
{
The <color=#00FF00>Debug Box</color> node generates a temporary box visual with the specified properties when an impulse is received at Display.
Usage

The Point input determines the global position of the box visual center point.


The Size input controls the X, Y, and Z dimensions of the spawned box visual.


The Orientation input controls the rotation of the box visual.


The Color input determines the color of the box visual.


The Duration input determines the number of seconds that the box visual persists.


The OnDisplay output fires an impulse when the box is successfully displayed.


Slots for the debug visuals are produced under a non-persistent slot under the root slot named '_DEBUG'. Children are produced under that slot for each individual user for whom a debug node fires. 
}


FrooxEngine.LogiX.Debug.DebugLine:#########################################################################
{
The <color=#00FF00>Debug Line</color> node generates a temporary line with the specified properties when an impulse is received at Display.
Usage

The Point0 determines the global position of one line endpoint.


The Point1 determines the global position of the other line endpoint.


The Color determines the color of the line visual.


The Radius determines the radius of the line visual.


The Duration determines the number of seconds that the line visual persist.


The OnDisplay output fires an impulse when the line is successfully displayed.


Slots for the debug visuals are produced under a non-persistent slot under the root slot named '_DEBUG'. Children are produced under that slot for each individual user for whom a debug node fires.

}

FrooxEngine.LogiX.Debug.DebugSphere:######################################################################
{
The <color=#00FF00>Debug Sphere</color> node generates a temporary sphere visual with the specified properties when an impulse is received at Display.
Usage

The Point input determines the global position of the sphere visual center point.


The Radius input determines the radius of the sphere visual.


The Color input determines the color of the sphere visual.


The Duration input determines the number of seconds that the sphere visual persists.


The OnDisplay output fires an impulse when the sphere is successfully displayed.

Slots for the debug visuals are produced under a non-persistent slot under the root slot named '_DEBUG'. Children are produced under that slot for each individual user for whom a debug node fires. 
}


FrooxEngine.LogiX.Debug.DebugText:########################################################################
{
The <color=#00FF00>Debug Text</color> node generates a temporary text visual with the specified properties when an impulse is received at Display.
Usage

The Position input determines the global position of the text visual center point. This defaults to being centered on the Debug Text node itself.

The Text input determines the content of the text visual. Rich text parsing is enabled.

The Size determines the size of the text visual. A value of 1 is recommended over the default which is very small.

The Color determines the color of the text visual.

The Duration input determines the number of seconds that the text visual persists.

The OnDisplay output fires an impulse when the text is successfully displayed.

Slots for the debug visuals are produced under a non-persistent slot under the root slot named '_DEBUG'. Children are produced under that slot for each individual user for whom a debug node fires. 
}


FrooxEngine.LogiX.Debug.DebugTriangle:####################################################################
{
The <color=#00FF00>Debug Triangle</color> node generates a temporary triangle visual with the specified properties when an impulse is received at Display.
Usage

The Point0, Point1, and Point2 inputs determine the global positions of the triangle vertices.


The Color input determines the color of the triangle visual.


The Duration input determines the number of seconds that the triangle visual persists.


The OnDisplay output fires an impulse when the triangle is successfully displayed.


Slots for the debug visuals are produced under a non-persistent slot under the root slot named '_DEBUG'. Children are produced under that slot for each individual user for whom a debug node fires.

}




FrooxEngine.LogiX.Debug.DebugVector:######################################################################
{
The <color=#00FF00>Debug Vector</color> node generates an arrow visual with the specified properties when an impulse is received at Display.
Usage

The Position input determines the global position of the arrow origin (tail).


The Vector input determines the global direction vector along which the arrow points. The values are not normalized before generating the visual.


The RadiusRatio input is a scaling factor which affects the radius and arrow head size of the displayed visual.


The Color input determines the color of the box visual.


The Duration input determines the number of seconds that the box visual persists.


The OnDisplay output fires an impulse when the vector arrow is successfully displayed.


Slots for the debug visuals are produced under a non-persistent slot under the root slot named '_DEBUG'. Children are produced under that slot for each individual user for whom a debug node fires.

}



FrooxEngine.LogiX.Debug.EstimatedMasterClockError:#######################################################
{
The <color=#00FF00>Estimated Master Clock Error</color> node returns the estimated error of the master clock. 
}







FrooxEngine.LogiX.ProgramFlow.OnActivatedNode:##################################################################################################################################
{

The <color=#00FF00>On Activated</color> node fires an impulse when the node becomes active.
Usage

This node fires an impulse whenever the slot which contains the OnActivatedNode component becomes active in the world. 
As such, if the containing slot is itself active, but is globally inactive due to an inactive parent, the node will fire when the inactive parent becomes active. 
If, however, the slot containing the OnActivatedNode component is itself inactive the node will ignore all activation events for parent slots until it itself becomes active again. 
This impulse fires for all users unless the OnlyHost input is True. 

}


FrooxEngine.LogiX.ProgramFlow.OnDeactivatedNode:##################################################################################################################################
{

The <color=#00FF00>On Deactivated</color> node fires an impulse when the node becomes inactive.
Usage

This node fires an impulse whenever the slot which contains the OnDectivatedNode component becomes inactive in the world. 
As such, even if the containing slot is itself active, but is globally inactivated due to an parent becoming inactivated, the node will fire. 
If the slot containing the OnDectivatedNode component is itself inactive the node will ignore all deactivation events for parent slots until it itself becomes active again. 
This impulse fires for all users unless the OnlyHost input is True.
}


FrooxEngine.LogiX.ProgramFlow.OnDestroyNode:##################################################################################################################################
{

The <color=#00FF00>On Destroy</color> node fires an impulse as the node is destroyed.
Usage

The impulse from this node fires as it is destroyed, therefore any values or references held under the destroyed hierarchy are not available to nodes 
activated by this impulse chain since they no longer exist. This impulse fires for all users unless the OnlyHost input is True. 

}


FrooxEngine.LogiX.ProgramFlow.OnDestroyingNode:##################################################################################################################################
{

The <color=#00FF00>On Destroying</color> nodefires an impulse just before the node is destroyed.
Usage

The impulse from this node fires just before it is destroyed, therefore any values or references held under the hierarchy about to be destroyed are 
still available to nodes activated by this impulse chain. The impulse fires for the user who triggered the destroy event. 

}


FrooxEngine.LogiX.ProgramFlow.OnDuplicateNode:##################################################################################################################################
{

The <color=#00FF00>On Duplicate</color> node fires an impulse after it is created in a duplication event.
Usage

When an On Duplicate node is duplicated, only the newly created node fires an impulse. This includes duplication via the radial context menu, 
duplicate button in the slot inspector panel, and the Duplicate Slot LogiX node. The impulse fires for the user who triggered the duplication event. 

}


FrooxEngine.LogiX.ProgramFlow.OnLoadedNode:##################################################################################################################################
{

The <color=#00FF00>On Loaded</color> node fires an impulse whenever the node is loaded from a saved instance. The impulse fires once for the relevant user 
(i.e. one who spawned the object etc).
Usage

Events which trigger this node include

    Spawning from the inventory
    Loading as part of a world opening
    Re-loading due to an undo / redo action etc

Note that this node does not check whether assets in its hierarchy have fully loaded.
Examples

The impulse from this node can be used to reliably save the user who spawns it's parent object from their inventory if the Loaded impulse chain writes the local user to a variable. 
Alternatively, use the Allocating User node.


}



FrooxEngine.LogiX.ProgramFlow.OnPasteNode:##################################################################################################################################

{

The <color=#00FF00>On Paste</color> node fires an impulse whenever the node is Pasted.
Usage

In the context of this node, 'pasting' is when an object is transferred from one world session to another. The impulse is fired for the user who pastes the object. 

}


FrooxEngine.LogiX.ProgramFlow.OnSavingNode:##################################################################################################################################
{

The <color=#00FF00>On Saving</color> node fire an impulse when it is saved.
Usage

Saving events include saving the node as part of an object to a user's inventory or saving the current world state. The impulse fires for the user who triggered the save event. 

}



FrooxEngine.LogiX.ProgramFlow.OnStartNode:##################################################################################################################################
{

The <color=#00FF00>On Start</color> node fires an impulse whenever the node is initialized. This happens locally for each user, 
unless the Only Host input is set to True, in which case it will only fire for the Host User.
Usage

Events which trigger this node include

    Spawning from the inventory
    On world start
    A new user joining the world
    On duplication
    Re-loading due to an undo / redo action etc

}



FrooxEngine.LogiX.ProgramFlow.BooleanToggle:##################################################################################################################################

{

The <color=#00FF00>Boolean Latch</color> node stores a Boolean value which can be set, reset or toggled by input impulses.
Usage

The Set impulse input changes the stored bool value to True when an impulse is received.


The Reset impulse input changes the stored bool value to False when an impulse is received.


The Toggle impulse input toggles the stored bool value when an impulse is received.


The OnSet output fires an impulse whenever the stored bool is set to True as a result of an impulse received at Set or Toggle. An impulse will be fired if an impulse 
is received at Set regardless of whether the stored value was actually changed.


The OnReset output fires an impulse whenever the stored bool is set to False as a result of an impulse received at Reset or Toggle. An impulse will be fired 
if an impulse is received at Reset regardless of whether the stored value was actually changed.


The * output provides the value of the stored bool. 

}


FrooxEngine.LogiX.ProgramFlow.DelayNode:##################################################################################################################################
{

The <color=#00FF00>Delay</color> node is used to fire an impulse from Impulse after Delay seconds have elapsed following an impulse received at Trigger.
Usage

The Delay input sets the number of seconds which must elapse before the delayed impulse is fired from Impulse. The default value is 0 which results in a delay of 1 frame update.


The OnTrigger output fires an impulse immediately after an impulse is received at Trigger. This continues the impulse chain which arrived at Trigger.


The delayed impulses do not continue the impulse chain which arrived at Trigger and any temporary values present will have been lost - if a temporary value must be stored 
until the delayed impulse is fired use Delay With Value. Each impulse which arrives at Trigger sets up a separate delayed impulse and multiple can be queued at once with 
different delay durations. If a user focuses a different world while they have delayed impulses queued, the delayed impulses will fire as normal. However, if a user with 
delayed impulses leave the world entirely, their delayed impulses will never fire.
Examples

}



FrooxEngine.LogiX.ProgramFlow.DelayWithValueNode`1[T]:##################################################################################################################################

{

The <color=#00FF00>Delay with value</color> node is used to fire an impulse from Impulse after Delay seconds have elapsed following an impulse received at Trigger. 
Additionally a value can be stored over the delay.
Usage

The Delay input sets the number of seconds which must elapse before the delayed impulse is fired from Impulse. The default value is 0 which results in a delay of 1 frame update.


The Value input value at the moment an impulse is received at Trigger is stored. When the node is spawned from the node browser this accepts a 'dummy' datatype, 
however the node will overload to accept any specific input datatype when a wire is connected.


The OnTrigger output fires an impulse immediately after an impulse is received at Trigger. This continues the impulse chain which arrived at Trigger. 
If a user focuses a different world while they have delayed impulses queued, the delayed impulses will fire as normal. However, if a user with delayed 
impulses leave the world entirely, their delayed impulses will never fire.


The DelayedValue output provides the value at the Value input when the delayed impulse was queued. This is only available for the duration of the impulse chain started by Impulse.


The delayed impulses do not continue the impulse chain which arrived at Trigger and any temporary values, other than that the single stored value will be lost. 
Each impulse which arrives at Trigger sets up a separate delayed impulse with corresponding stored value and multiple can be queued at once with different delay 
durations and stored values.

}

FrooxEngine.LogiX.ProgramFlow.DynamicImpulseReceiver:##################################################################################################################################

{

The <color=#00FF00>Dynamic Impulse Receiver</color> node fires an impulse whenever a Dynamic Impulse Trigger is triggered and the receiver node is present under the 
trigger's TargetHierarchy. This will only occur if the Tag string inputs of the trigger and receiver are identical.
Usage

Note that the tag system for dynamic impulse triggers / receivers is completely unrelated to slot tag properties. This node will only respond to Dynamic 
Impulse Triggers - it ignores dynamic impulses from Dynamic Impulse Trigger With Value`1 nodes. 


}


FrooxEngine.LogiX.ProgramFlow.DynamicImpulseReceiverWithValue`1[System.Boolean]:##################################################################################################################################
{

The <color=#00FF00>Dynamic Impulse Receiver With Value`1</color> node fires an impulse whenever a Dynamic Impulse Trigger With Value`1 is triggered and the receiver node is present 
under the trigger's TargetHierarchy. This will only occur if the Tag string inputs of the trigger and receiver are identical. The Value output by the receiver node is equal to 
the Value input of the trigger node at the moment it was triggered.
Usage

Note that the tag system for dynamic impulse triggers / receivers is completely unrelated to slot tag properties. This node will only respond to Dynamic Impulse Trigger With Value`1 
nodes with identical Value datatypes - it ignores dynamic impulses from Dynamic Impulse Trigger nodes or Dynamic Impulse Trigger With Value`1 nodes with different Value datatypes. 
The output Value is only equal to the Value input from the trigger for the duration of the impulse chain started from the receiver Impulse output.

When spawning this node from the node browswer there is a selection of possible datatypes for this node. See this tutorial by ProbablePrime for how to create receiver nodes 
for other data types.

}



FrooxEngine.LogiX.ProgramFlow.DynamicImpulseTrigger:##################################################################################################################################

{

The <color=#00FF00>Dynamic Impulse Trigger</color> node sends a dynamic impulse when impulse is received at Run which triggers any Dynamic Impulse Receiver nodes present under
 the input TargetHierarchy 
whose Tag input matches that on the Dynamic Impulse Trigger.
Usage

The ExcludeDisabled input determines whether Dynamic Impulse Receiver nodes present on inactive slots will be triggered. Default is False, meaning that all valid receivers may
 be triggered.


The OnTriggered output fires an impulse after any impulse chains triggered from Dynamic Impulse Receivers have completed. This continues the impulse chain which arrived at Run


Note that the tag system for dynamic impulse triggers / receivers is completely unrelated to slot tag properties. When an impulse is received at Run, this node starts a 
descending search for any Dynamic Impulse Receiver nodes present under the TargetHierarchy. All such receiver nodes with Tag inputs matching the trigger Tag will fire an impulse. 
Note that Dynamic Impulse Receiver With Value`1 nodes will be ignored. The hierarchy search is highly efficient, however it is best to set the input TargetHierarchy as close to 
the intended target node as possible to minimize performance costs. 

}


FrooxEngine.LogiX.ProgramFlow.DynamicImpulseTriggerWithValue`1[System.Boolean]:##################################################################################################################################
{

The <color=#00FF00>Dynamic Impulse Trigger With Value`1</color> node sends a dynamic impulse when an impulse is received at Run which triggers any Dynamic 
Impulse Receiver nodes (with the same Value datatype) present under the input TargetHierarchy whose Tag input matches that on the Dynamic Impulse Trigger With Value`1.
Usage

The ExcludeDisabled input determines whether Dynamic Impulse Receiver With Value`1 nodes present on inactive slots will be triggered. Default is False, meaning that 
all valid receivers may be triggered.


The OnTriggered output fires an impulse after any impulse chains triggered from Dynamic Impulse Receiver With Value`1 nodes have completed. This continues the impulse 
chain which arrived at Run


Note that the tag system for dynamic impulse triggers / receivers is completely unrelated to slot tag properties. When an impulse is received at Run, this node starts 
a descending search for any Dynamic Impulse Receiver With Value`1 nodes present under the TargetHierarchy whose Value datatype matches that of the trigger. 
All such receiver nodes with Tag inputs matching the trigger Tag will fire an impulse. Note that Dynamic Impulse Receiver nodes will be ignored. The hierarchy 
search is highly efficient, however it is best to set the input TargetHierarchy as close to the intended target node as possible to minimize performance costs. 

}



FrooxEngine.LogiX.ProgramFlow.FireOnChange`1[T]:##################################################################################################################################
{

The <color=#00FF00>Fire On Change</color> node fires an impulse whenever the input Value changes.
Usage

The Value input has a 'dummy' datatype when the node is spawned from the node browser. The node will overload to any given datatype if a wire of that type is connected to Value.

The second input to this node, OnlyForUser, exists to control which users fire the impulse when the Condition is met/changed. Its handling is as follows:

    If a User is specified in the OnlyForUser only fire for this user.
    If a User is not specified BUT the Node exists parented to a User then fire for the user it is parented to. This usually happens on avatars.
    Otherwise fire for all users.

Do not use Local User with this node. Use Local Fire On Change instead.

It is recommended to specify a user at OnlyForUser to ensure that the user for whom the impulse fires is predictable.

Note that this node will only fire one impulse in the event that Value changes multiple times within a single impulse chain. 
Similarly this node will not fire an impulse if the Value is changed and then reset to the previous value within a single impulse chain. 

}



FrooxEngine.LogiX.ProgramFlow.FireOnFalse:##################################################################################################################################
{

The <color=#00FF00>Fire On False</color> node node fires a single impulse whenever the input Condition becomes False.
Usage

After an impulse has been fired, the Condition must first be reset to True before any additional impulses can be fired. When the node is spawned from the node 
browser Condition is False by default, however no impulse is fired as a result.

The second input to this node, OnlyForUser, exists to control which users fire the impulse when the Condition is met/changed. Its handling is as follows:

    If a User is specified in the OnlyForUser only fire for this user.
    If a User is not specified BUT the Node exists parented to a User then fire for the user it is parented to. This usually happens on avatars.
    Otherwise fire for all users.

Do not use Local User with this node. Use Local Fire On False instead.

It is recommended to specify a user at OnlyForUser to ensure that the user for whom the impulse fires is predictable.

Note that this node will only fire one impulse in the event that Condition becomes False multiple times within a single impulse chain. Similarly this node will not 
fire an impulse if the Condition becomes False and then reset to True within a single impulse chain. 

}


FrooxEngine.LogiX.ProgramFlow.FireOnTrue:##################################################################################################################################
{

The <color=#00FF00>Fire On True</color> node fires a single impulse whenever the input Condition becomes True.
Usage

After an impulse has been fired, the Condition must first be reset to False before any additional impulses can be fired.

The second input to this node, OnlyForUser, exists to control which users fire the impulse when the Condition is met/changed. Its handling is as follows:

    If a User is specified in the OnlyForUser only fire for this user.
    If a User is not specified BUT the Node exists parented to a User then fire for the user it is parented to. This usually happens on avatars.
    Otherwise fire for all users.

Do not use Local User with this node. Use Local Fire On True instead.

It is recommended to specify a user at OnlyForUser to ensure that the user for whom the impulse fires is predictable.

Note that this node will only fire one impulse in the event that Condition becomes True multiple times within a single impulse chain. Similarly this node will not fire 
an impulse if the Condition becomes True and then reset to False within a single impulse chain.



}


FrooxEngine.LogiX.ProgramFlow.FireWhileTrue:##################################################################################################################################

{

The <color=#00FF00>Fire While True</color> node fires an impulse every frame while the input Condition is True.
Usage

The FiringUser input determines for which users impulses will fire: if a valid user value is present, impulses will only fire for that user. If no FiringUser is provided, 
or Local User is used, impulses will fire for all users. If an explicit null value provided, no impulses will fire at all.


It is recommended to specify the FiringUser to minimize redundant impulses and to keep behavior predictable.
Examples

This will continue firing until the condition is no longer True. 

}

FrooxEngine.LogiX.ProgramFlow.ForNode:##################################################################################################################################

{

The <color=#00FF00>For</color> node is used to fire impulses from the LoopIteration output a specific number of times when an impulse is received at Run.
Usage

The Count input determines how many times impulses will be fired from the LoopIteration output. Default is 0. Note that this is evaluated immediately after the LoopStart 
impulse chain has completed, just before any impulses are fired from LoopIteration.


The Reverse input controls whether the Iteration output value is incremented or decremented each LoopIteration. Default is False, meaning Iteration is incremented each iteration.


The LoopStart output fires an impulse once after an impulse is received at Run. The impulse chain will complete before any impulses are fired from LoopIteration.


The LoopIteration output fires impulses sequentially until the total number which have been fired is equal to the Count input. Each impulse chain started from LoopIteration 
completes before the following one is fired.


The LoopEnd output fires an impulse once the final impulse chain started from LoopIteration has ended.


The Iteration output value is either incremented or decremented each time a new impulse is fired from LoopIteration, depending on the value of Reverse. If Reverse is False, 
Iteration is incremented each time an impulse is fired from LoopIteration starting with the value 0, during the first iteration, and ending with Count - 1 on the final iteration. 
If Reverse is True, the Iteration value is Count - 1 on the first iteration and decremented each time down to 0 on the final iteration.


Note that all impulse chains started from this node effectively continue the one which arrived at Run, meaning that any temporary values from previous nodes are still available. 
All iterations from LoopIteration complete within a single frame update and therefore this can produce framerate hitches if an excessively demanding computation is performed.
 There is a failsafe which will put this node into an error state (node visual turns red) if a frame is delayed excessively - this helps prevent complete freezes. 

}


FrooxEngine.LogiX.ProgramFlow.IfNode:##################################################################################################################################
{

The <color=#00FF00>If</color> node fires an impulse from one of two outputs dependent on the Condition when an impulse is received at Run.
Usage

Upon receiving an impulse at Run, an impulse is fired from True if Condition is True or from False if Condition is False. The default Condition value is False. 

}


FrooxEngine.LogiX.ProgramFlow.ImpulseDemultiplexer:##################################################################################################################################
{

The <color=#00FF00>Impulse Demultiplexer</color> node fires an impulse from OnTriggered whenever an impulse is received at any Trigger input. It also indicates which input was 
triggered via the Index value.
Usage

The Index output value corresponds to the index of the input which was triggered. Neos uses zero-based indexing meaning that the top input being triggered corresponds to Index = 0. 
This value is only available for the duration of the impulse chain fired from OnTriggered. Default value is 0.


The number of Trigger inputs can be changed with the + or - buttons.

}



FrooxEngine.LogiX.ProgramFlow.ImpulseMultiplexer:##################################################################################################################################

{

The <color=#00FF00>Impulse Multiplexer</color> node fires an impulse from the output which matches the value of the input Index when an impulse is received at Trigger.
Usage

An impulse is only fired if there is a corresponding output for the Index, e.g. no impulse will be fired if the Index is -1 when an impulse is 
received at Trigger. Neos uses zero indexing, hence the topmost output will fire an impulse when Index is zero. The number of outputs can be changed with the + and - buttons. 

}



FrooxEngine.LogiX.ProgramFlow.LocalFireOnChange`1[T]:##################################################################################################################################
{

The <color=#00FF00>Local Fire On Change`1</color> node fires an impulse independently for each user whenever the input Value changes locally for them.
Usage

The Value input has a 'dummy' datatype when the node is spawned from the node browser. The node will overload to any given datatype if a wire of that type is connected to Value. 

}


FrooxEngine.LogiX.ProgramFlow.LocalFireOnFalse:##################################################################################################################################
{

The <color=#00FF00>Local Fire On False</color> node fires an impulse independently for each user whenever the input Condition locally becomes False for them.
Usage

Note that the initial default value is false, however the node does not fire an impulse when it is first created. Hence the input value 
must become True at least once before this node will fire.

There are a few mechanisms which can cause values in NeosVR to be different for different users; if there were 3 users in a session (A, B, and C) 
and the Condition became False for A and B (but not C), impulses would be fired for both A and B (but not C). If later the Condition also became False for C and 
impulse would fire only for C. 

}



FrooxEngine.LogiX.ProgramFlow.LocalFireOnTrue:##################################################################################################################################

{

The <color=#00FF00>Local Fire On True</color> node fires an impulse independently for each user whenever the input Condition locally becomes True for them.
Usage

Note that the initial default value is False.

There are a few mechanisms which can cause values in NeosVR to be different for different users; if there were 3 users in a session (A, B, and C) 
and the Condition became True for A and B (but not C), impulses would be fired for both A and B (but not C). If later the Condition also became True for C 
and impulse would fire only for C. 

}

FrooxEngine.LogiX.ProgramFlow.LocalImpulseTimeout:##################################################################################################################################
{

The <color=#00FF00>Local Impulse Timeout</color> node can be used to filter the rate of impulses passing along an impulse chain.
Usage

When an impulse is first received at Trigger, an impulse is fired from Pulse which continues the impulse chain. No further impulses will be fired from Pulse, no matter how many 
arrive at Trigger. Until either an impulse is received at Reset or a number of seconds has elapsed greater than or equal to TimeoutSeconds. The duration to wait is fixed at the 
moment that an impulse is fired from Pulse. As such, if the TimeoutSeconds value is changed after the timeout begins, no further impulses will fire from Pulse until enough seconds 
have elapsed greater than or equal to the previous value of TimeoutSeconds (or an impulse is received at Reset).

As the node name implies, timeouts and resets are local for each user. Meaning one user may fire an impulse from Pulse and initate a timeout for any impulses owned by them, 
but another user would be capable of triggering an impulse from Pulse and initating their own timeout immediately afterwards. 

}


FrooxEngine.LogiX.ProgramFlow.LocalLeakyImpulseBucket:##################################################################################################################################

{


The <color=#00FF00>Local Leaky Impulse Bucket</color> node can be used as a buffer to store multiple impulses and release them at a constant rate. This node operates 
according to the Leaky bucket algorithm.
Usage

Trigger is the impulse source for the bucket. Reset will remove all remaining impulses from the bucket. Interval is a configurable time interval which affects how often 
impulses are poured out of the bucket. MaximumCapacity is the maximum number of impulses that can be stored in the bucket. Pulse fires whenever the specified time interval 
has elapsed if there are impulses remaining. Overflow fires whenever an impulse is received through Trigger while the bucket is full. CurrentCapacity is the current number 
of impulses in the bucket. 

}


FrooxEngine.LogiX.ProgramFlow.OnePerFrame:##################################################################################################################################
{

The <color=#00FF00>One Per Frame</color> node fires an impulse from Pulse when it receives an impulse at Trigger. 
No further impulses are fired from Pulse, however many may arrive at Trigger, until the next frame update.

}


FrooxEngine.LogiX.ProgramFlow.PulseRandom:##################################################################################################################################
{

The <color=#00FF00>Pulse Random</color> node fires an impulse from one random output when an impulse is received at Trigger.
Usage

The number of outputs can be changed using the + / - buttons on the node visual. 

}


FrooxEngine.LogiX.ProgramFlow.SequenceImpulse:##################################################################################################################################
{

The <color=#00FF00>Sequence</color> node fires an impulse from each output sequentially when an impulse is received at Trigger.
Usage

Impulses are fired from outputs in numerically ascending order [0], [1] etc.. Successive output impulses are only fired when the chain initiated by the preceding one has completed. 

}


FrooxEngine.LogiX.ProgramFlow.TimerNode:##################################################################################################################################

{

The <color=#00FF00>Timer</color> node fires impulses from Pulse separated by the number of seconds specified by the Interval input.
Contents

    1 Usage
        1.1 User Handling
    2 Examples
    3 Node Menu

Usage

Each frame update, this node checks whether a number of seconds greater than or equal to the Interval input have elapsed. If they have, an impulse is fired owned by the UpdatingUser. If no UpdatingUser is provided, the default owner is the world host. If a null UpdatingUser is provided, the node will not fire at all.
User Handling

It is NOT recommended to use Local User with this node. When Local User is used, it will fire impulses for all users in the session. This is similar to the guidance for Fire On True etc. 

}



FrooxEngine.LogiX.ProgramFlow.UpdateNode:##################################################################################################################################
{

The <color=#00FF00>Update</color> node fires an impulse from Update every frame.
Usage

Impulses are fired owned by the UpdatingUser. This defaults to the world host if no UpdatingUser is provided. If a null user value is explicitly provided the node will not fire impulses.

Due to the frequency that this node fires impulses, one should be careful to ensure that impulses are filtered such that downstream LogiX is only evaluated when absolutely necessary. Unnecessary use of this node has the potential to incur significant performance penalties and there are almost always better alternatives. 

}



FrooxEngine.LogiX.ProgramFlow.UpdatesDelayNode:##################################################################################################################################
{

The <color=#00FF00>Update</color>Updates Delay</color> node is used to fire an impulse from Impulse after a number of frame updates greater than or equal to Updates have completed following an impulse received at Trigger.
Usage

The Updates input sets the number of frame updates which must complete before the delayed impulse is fired from Impulse. The default value is 1.


The OnTrigger output fires an impulse immediately after an impulse is received at Trigger. This continues the impulse chain which arrived at Trigger.


The delayed impulses do not continue the impulse chain which arrived at Trigger and any temporary values present will have been lost - if a temporary value must be stored until the delayed impulse is fired use Updates Delay With Value. Each impulse which arrives at Trigger sets up a separate delayed impulse and multiple can be queued at once with different delay durations.


}



FrooxEngine.LogiX.ProgramFlow.UpdatesDelayWithValueNode`1[T]:##################################################################################################################################
{

The <color=#00FF00>Updates Delay with value</color> node is used to fire an impulse from Impulse after a number of frame updates greater than or equal to Updates have completed following an impulse received at Trigger. Additionally a value can be stored over the delay.
Usage

The Updates input sets the number of frame updats which must complete before the delayed impulse is fired from Impulse. The default value is 1.


The Value input value at the moment an impulse is received at Trigger is stored. When the node is spawned from the node browser this accepts a 'dummy' datatype, however the node will overload to accept any specific input datatype when a wire is connected.


The OnTrigger output fires an impulse immediately after an impulse is received at Trigger. This continues the impulse chain which arrived at Trigger.


The DelayedValue output provides the value at the Value input when the delayed impulse was queued. This is only available for the duration of the impulse chain started by Impulse.


The delayed impulses do not continue the impulse chain which arrived at Trigger and any temporary values, other than that the single stored value will be lost. Each impulse which arrives at Trigger sets up a separate delayed impulse with corresponding stored value and multiple can be queued at once with different delay durations and stored values. 

}


FrooxEngine.LogiX.ProgramFlow.WhileNode:##################################################################################################################################
{

The <color=#00FF00>While</color> node is used to fire impulses from the LoopIteration output until the Condition becomes True after an impulse is received at Run.
Usage

The LoopStart output fires an impulse once after an impulse is received at Run. The impulse chain will complete before any impulses are fired from LoopIteration.


The LoopIteration output fires impulses sequentially until the Condition becomes True. Each impulse chain started from LoopIteration completes before the following one is fired.


The LoopEnd output fires an impulse once the final impulse chain started from LoopIteration has ended.


Note that all impulse chains started from this node effectively continue the one which arrived at Run, meaning that any temporary values from previous nodes are still available. All iterations from LoopIteration complete within a single frame update and therefore this can produce framerate hitches if an excessively demanding computation is performed. There is a failsafe which will put this node into an error state (node visual turns red) if a frame is delayed excessively - this helps prevent complete freezes.
Examples

The While node is useful when looping and the required number of iterations cannot be determined in advance. If similar looping behavior is required, but the number of required iterations can be fixed, use the For node instead. 


}








FrooxEngine.LogiX.CurrentCulture:##########################################################################
{
The <color=#00FF00>Current Culture</color> node outputs information about a user's current locale.
Usage

This node provides information used when formatting data to strings (with the To String node) or parsing data from strings (using nodes under the Parsing category). The output from Current Culture can be provided to the FormatProvider of compatible nodes, an autocast node will be created upon connection. Locale information defines the default format for dates, times, numbers, currency values, the sorting order of text, casing conventions, and string comparisons for the user's; this can vary between countries and therefore it is possible that outputs from affected nodes may differ for different users depending on their locale. If such variance is undesirable consider using the Invariant Culture node instead.
Examples

Imagine that the float 3.14 is connected to the V input of a To String node, the string "C2" is connected to the Format input and Current Culture is connected to the FormatProvider input. For users in the en-GB (British English) locale the output from To String will be 3.14. However, for users in the en-US locale the output will be $3.14 while for users in many European countries it would be 3.14. 
}


FrooxEngine.LogiX.InvariantCulture:########################################################################
{
The color=#00FF00>Invariant Culture</color> node outputs a fixed locale which will be the same for all users.
Usage

This node provides information used when formatting data to strings (with the To String node) or parsing data from strings (using nodes under the Parsing category). The output from Invariant Culture can be provided to the FormatProvider of compatible nodes, an autocast node will be created upon connection. Locale information defines the default format for dates, times, numbers, currency values, the sorting order of text, casing conventions, and string comparisons for the user's; using the Invariant Culture node ensures that affected nodes will behave the same for all users regardless of their current locale.
Examples

It is generally recommended to use this node, rather than the Current Culture node, when parsing data from input files. Different locales have significantly different conventions for formatting numbers which can cause issues e.g. the number 1,000 would be interpreted as 'one thousand' in most English locales but 'one point zero zero zero' in many others. 
}




FrooxEngine.LogiX.Input.GeneralHeadset:#################################################################
{
'General Headset' LogiX node
Inputs
  	User 	User
Outputs
  	Float 	BatteryLevel
  	Bool 	IsBatteryCharging

The <color=#00FF00>General Headset</color> node returns generic information about the input user's current headset.

}

########Controllers########################
FrooxEngine.LogiX.Input.CosmosController:###############################################################
{
The <color=#00FF00>Cosmos Controller</color> provides more controller data than the Standard Controller (LogiX node) specifically for HTC VIVE Cosmos controllers.
Usage

The Active output indicates whether the User is using Cosmos.


The BatteryLevel output output provides the estimated remaining battery charge. The value is in the range 0 to 1 with precision to two decimal places.


The IsBatteryCharging output indicates whether the controller battery is currently charging.


The Menu output


The ButtonBY output


The ButtonAX output


The GripClick output


The Joystick output


The JoystickTouch output


The JoystickClick output


The Trigger output


The TriggerTouch output


The TriggerClick output


The Bumper output 
}



FrooxEngine.LogiX.Input.HPReverbController:#############################################################
{
The <color=#00FF00>HPReverb Controller</color> provides more controller data than the Standard Controller (LogiX node) specifically for second generation Windows Mixed Reality (WMR) controllers compatible with the HP Reverb G2 headset.
Usage

The IsActive output indicates whether the User is using 2nd generation WMR controllers.


The BatteryLevel output provides the estimated remaining battery charge. The value is in the range 0 to 1 with precision to two decimal places.


The IsBatteryCharging output is intended to indicate whether the controller is currently charging. This output cannot be used as 2nd generation WMR controllers use replacable batteries and therefore cannot be charged while in use.


The AppMenu output


The ButtonYB output


The ButtonXA output


The Grip output indicates how far the grip/grab button is pressed.


The GripTouch output


The GripClick output indicates whether the grip/grab button is fully pressed.


The Joystick output indicates the current position of the joystick. X and Y values are in the range -1 to 1. X indicates left/right location, Y indicates forward/back. The resting joystick position is [0,0].


The JoystickClick output indicates whether the joystick is pressed down.


The Trigger output indicates how far the trigger button is pressed down. This corresponds to the button labelled Primary on the graphic below. The value is in the range 0 to 1 with 1 being reached somewhat before the button is fully pressed.


The TriggerClick output is indicates whether the trigger button is pressed to the point of registering as a button click. This is reached somewhat before the button is fully pressed. 
}




FrooxEngine.LogiX.Input.IndexController:###############################################################
{
The <color=#00FF00>Index Controller</color> provides more controller data than the Standard Controller (LogiX node) specifically for Valve Index controllers.
Usage

The IsActive output indicates whether the User is using Index controllers.


The BatteryLevel output provides the estimated remaining battery charge. The value is in the range 0 to 1 with precision to two decimal places.


The IsBatteryCharging output indicates whether the controller is currently charging.


The ButtonA output


The ButtonB output


The ButtonA_Touch output


The ButtonB_Touch output


The Grip output


The GripTouch output


The GripClick output


The Joystick output


The JoystickTouch output


The JoystickClick output


The Trigger output


The TriggerTouch output


The TriggerClick output


The Touchpad output


The TouchpadTouch output


The TouchpadPress output


The TouchpadForce output 
}



FrooxEngine.LogiX.Input.StandardController:############################################################
{
The <color=#00FF00>Standard Controller</color> provides access to standard data available from all supported VR controller types.
Usage

The IsActive output indicates whether the User is using VR controllers.


The BatteryLevel output provides the estimated remaining battery charge. The value is in the range 0 to 1 with precision to two decimal places.


The IsBatteryCharging output is intended indicates whether the controller is currently charging. This is only functional with Index and Vive controllers.


The Type output indicates which type of VR controllers the User is using.


The Primary output indicates whether the primary button is pressed. This corresponds to the trigger button on most controllers and is used to activate / user the interaction lasers.


The Secondary output indicates whether the secondary button is pressed.


The Grab output indicates whether the grab/grip button is pressed.


The Menu output indicates whether the menu button is pressed.


The Strength output indicates how far the primary button is pressed down. The value is in the range 0 to 1.


The Axis on Windows Mixed Reality controllers indicates the touch location on the capacitative touchpad. The X and Y values are in the range -1 to 1. X indicates left/right location, Y indicates forward/back. 
}





FrooxEngine.LogiX.Input.TouchController:###############################################################
{
The <color=#00FF00>Touch Controller</color> provides more controller data than the Standard Controller (LogiX node) specifically for Oculus controllers.
Usage

The IsActive output indicates whether the User is using Oculus (Meta) Touch controllers.


The BatteryLevel output provides the estimated remaining battery charge. The value is in the range 0 to 1 with precision to two decimal places.


The IsBatteryCharging output indicates whether the controller is currently charging.


The Start output


The ButtonYB output


The ButtonXA output


The ButtonYB_Touch output


The ButtonXA_Touch output


The ThumbRestTouch output


The Grip output


The GripClick output


The Joystick output


The JoystickTouch output


The JoystickClick output


The Trigger output


The TriggerTouch output


The Model output


The TriggerClick output 
}



FrooxEngine.LogiX.Input.ViveController:################################################################
{
<color=#00FF00>Vive Controller</color>

Usage

The IsActive output indicates whether the User is using HTC VIVE controllers.


The BatteryLevel output provides the estimated remaining battery charge. The value is in the range 0 to 1 with precision to two decimal places.


The IsBatteryCharging output indicates whether the controller is currently charging.


The Grip output


The App output


The Trigger output


The TriggerHair output


The TriggerClick output


The Touchpad output


The TouchpadTouch output


The TouchpadClick output 
}


FrooxEngine.LogiX.Input.WindowsMR_Controller:##########################################################
{
The <color=#00FF00>Windows MR Controller</color> provides more controller data than the Standard Controller (LogiX node) specifically for first generation Windows Mixed Reality (WMR) controllers.
Usage

The IsActive output indicates whether the User is using WMR controllers.


The BatteryLevel output provides the estimated remaining battery charge. The value is in the range 0 to 1 with precision to two decimal places.


The IsBatteryCharging output is intended to indicate whether the controller is currently charging. This output cannot be used as WMR controllers use replacable batteries and therefore cannot be charged while in use.


The Grip output indicates whether the grip button is pressed. This corresponds to the button labelled Grab on the graphic below.


The App output indicates whether the app button is pressed. This corresponds to the button which opens the Dash / Context menu on the graphic below.


The Joystick output indicates the current position of the joystick. X and Y values are in the range -1 to 1. X indicates left/right location, Y indicates forward/back. The resting joystick position is [0,0].


The JoystickClick output indicates whether the joystick is pressed down.


The Trigger output indicates how far the trigger button is pressed down. This corresponds to the button labelled Primary on the graphic below. The value is in the range 0 to 1 with 1 being reached somewhat before the button is fully pressed.


The TriggerHair output is intended to indicate whether the trigger is lightly pressed. In this case it seems to be functionally equivalent to TriggerClick.


The TriggerClick output is indicates whether the trigger button is pressed to the point of registering as a button click. This is reached somewhat before the button is fully pressed.


The Touchpad output indicates the touch location on the capacitative touchpad. The X and Y values are in the range -1 to 1. X indicates left/right location, Y indicates forward/back.


The TouchpadTouch output indicates whether the capacitative touchpad is currently touched.


The TouchpadClick output indicates whether the capacitative touchpad is currently pressed. 
}



##########Haptics###############

FrooxEngine.LogiX.Input.TriggerHapticsInHierarchy:#####################################################
{
The <color=#00FF00>Trigger Haptics In Hierarchy</color> node causes all haptic feedback devices (typically controller vibration) under the input TargetHierarchy to activate. Haptics will not activate if an affected user has Controller Vibration unchecked in their settings menu. 

Usage

Haptic activation is extremely short in duration so for prolonged vibration this node needs to be repeatedly triggered. Activation intensity is modulated by the RelativeIntensity input.
}



FrooxEngine.LogiX.Input.TriggerHapticsOnController:####################################################
{
The <color=#00FF00>Trigger Haptics On Controller</color> node causes controller haptic feedback (vibration) activate on the input Controller. Haptics will not activate if an affected user has Controller Vibration unchecked in their settings menu.


Usage

Haptic activation is extremely short in duration so for prolonged vibration this node needs to be repeatedly triggered. Activation intensity is modulated by the RelativeIntensity input.
}



#########Keyboard#############
FrooxEngine.LogiX.Input.KeyHeld:#######################################################################
{
The <color=#00FF00>Key Held</color> node reports whether the input Key is being held down.
Usage

This node only reports on inputs via a user's hardware keyboard. It does not respond to key presses on the Neos software keyboard. Additionally inputs from a hardware keyboard will not be recognised by this node if a user is editing an input field.

The output of this node is local, and thus potentially different, for each user. Hence each user only sees the value relevant to their system hardware. 
}


FrooxEngine.LogiX.Input.KeyPressed:####################################################################
{
The <color=#00FF00>Key Pressed</color> node reports whether the input Key has just been pressed.
Usage

This node only reports on inputs via a user's hardware keyboard. It does not respond to key presses on the Neos software keyboard. Additionally inputs from a hardware keyboard will not be recognised by this node if a user is editing an input field.

The output of this node is local, and thus potentially different, for each user. Hence each user only sees the value relevant to their system hardware. This node only has the value True for a single frame when the indicated Key is pressed.

}



FrooxEngine.LogiX.Input.KeyReleased:###################################################################
{
The <color=#00FF00>Key Released</color> node reports whether the input Key has just been released.
Usage

This node only reports on inputs via a user's hardware keyboard. It does not respond to key presses on the Neos software keyboard. Additionally inputs from a hardware keyboard will not be recognised by this node if a user is editing an input field.

The output of this node is local, and thus potentially different, for each user. Hence each user only sees the value relevant to their system hardware. This node only has the value True for a single frame when the indicated Key is released. 
}



FrooxEngine.LogiX.Input.TypeDelta:#####################################################################
{
The <color=#00FF00>Type Delta</color> node outputs the keys which were pressed on a user's keyboard during the last frame.
Usage

This node only reports on inputs via a user's hardware keyboard. It does not respond to key presses on the Neos software keyboard. Additionally inputs from a hardware keyboard will not be recognised by this node if a user is editing an input field.

The output of this node is local, and thus potentially different, for each user. Hence each user only sees the value relevant to their system hardware. This node only has any specific output value for single frame.
}


#########Mouse######################
FrooxEngine.LogiX.Input.DesktopMousePosition:##########################################################
{
The <color=#00FF00>Desktop Mouse Position</color> node outputs the current pixel position of the mouse cursor on the user's desktop.
Examples

In the output Float2, the X value corresponds to the mouse horizontal position and Y corresponds to the mouse vertical position relative to the user's primary desktop monitor. Both values start at 0 when the cursor is at the top left corner of a user's screen. Note that, if the mouse input is being captured by Neos, the value will correspond to the middle of the Neos window.


The output of this node is local, and thus potentially different, for each user. Hence each user only sees the value relevant to their system hardware. 
}



FrooxEngine.LogiX.Input.LeftMouseButtonHeld:###########################################################
{
The <color=#00FF00>Left Mouse Button Held</color> node reports whether the user's left mouse button is pressed down.
Usage

The output of this node is local, and thus potentially different, for each user. Hence each user only sees the value relevant to their system hardware.
}


FrooxEngine.LogiX.Input.LeftMouseButtonReleased:#######################################################
{
The <color=#00FF00>Left Mouse Button Released</color> node reports whether the user's left mouse button has just been released.
Usage

The output of this node is local, and thus potentially different, for each user. Hence each user only sees the value relevant to their system hardware. This node only has the value True for a single frame when the left mouse button is released. 
}

FrooxEngine.LogiX.Input.LeftMousePressed:##############################################################
{
The <color=#00FF00>Left Mouse Pressed</color> node reports whether the user's left mouse button has just been pressed.
Usage

The output of this node is local, and thus potentially different, for each user. Hence each user only sees the value relevant to their system hardware. This node only has the value True for a single frame when the left mouse button is pressed. 
}


FrooxEngine.LogiX.Input.MiddleMouseButtonHeld:#########################################################
{
The <color=#00FF00>Middle Mouse Button Held</color> node reports whether the user's middle mouse button is pressed down.
Usage

The output of this node is local, and thus potentially different, for each user. Hence each user only sees the value relevant to their system hardware. 
}




FrooxEngine.LogiX.Input.MiddleMouseButtonReleased:#####################################################
{
The <color=#00FF00>Middle Mouse Button Released</color> node reports whether the user's middle mouse button has just been released.
Usage

The output of this node is local, and thus potentially different, for each user. Hence each user only sees the value relevant to their system hardware. This node only has the value True for a single frame when the left mouse button is released.

}


FrooxEngine.LogiX.Input.MiddleMousePressed:############################################################
{
The <color=#00FF00>Middle Mouse Pressed</color> node reports whether the user's middle mouse button has just been pressed.
Usage

The output of this node is local, and thus potentially different, for each user. Hence each user only sees the value relevant to their system hardware. This node only has the value True for a single frame when the middle mouse button is pressed. 
}


FrooxEngine.LogiX.Input.MouseMovementDelta:############################################################
{
The <color=#00FF00>Mouse Movement Delta</color> node outputs the change in the user's mouse position (in screen pixel units) during the last frame.
Usage

The output X value corresponds to horizontal movement, Y corresponds to vertical movement. Positive X values indicate a move to the right, negative values indicate movement to the left. Positive Y values indicate a move upwards, negative values indicate downward movement.

The output of this node is local, and thus potentially different, for each user. Hence each user only sees the value relevant to their system hardware. 
}


FrooxEngine.LogiX.Input.MousePosition:#################################################################
{
The <color=#00FF00>Mouse Position</color> node outputs the current pixel position of the mouse cursor relative to the Neos application window.
Usage

In the output Float2, the X value corresponds to the mouse horizontal position and Y corresponds to the mouse vertical position. Both values start at 0 when the cursor is at the bottom left corner of a user's Neos application window. Note that, if the mouse input is being captured by Neos, the value will correspond to the middle of the Neos window.


The output of this node is local, and thus potentially different, for each user. Hence each user only sees the value relevant to their system hardware. 
}



FrooxEngine.LogiX.Input.MouseScrollWheelDelta:#########################################################
{
The <color=#00FF00>Mouse Scroll Wheel Delta</color> node outputs the number of 'ticks' that the mouse scroll wheel moved through during the last frame.
Usage

The output value is a whole number float value. Positive values correspond to the mouse wheel being pushed forwards, negative values correspond to the wheel being rolled back.

The output of this node is local, and thus potentially different, for each user. Hence each user only sees the value relevant to their system hardware. 
}


FrooxEngine.LogiX.Input.RightMouseButtonHeld:##########################################################
{
The <color=#00FF00>Right Mouse Button Held</color> node reports whether the user's right mouse button is pressed down.
Usage

The output of this node is local, and thus potentially different, for each user. Hence each user only sees the value relevant to their system hardware. 
}



FrooxEngine.LogiX.Input.RightMouseButtonReleased:######################################################
{
The <color=#00FF00>Right Mouse Button Released</color> node reports whether the user's right mouse button has just been released.
Usage

The output of this node is local, and thus potentially different, for each user. Hence each user only sees the value relevant to their system hardware. This node only has the value True for a single frame when the right mouse button is released. 
}



FrooxEngine.LogiX.Input.RightMousePressed:##############################################################
{
The Right Mouse Pressed node reports whether the user's right mouse button has just been pressed.
Usage

The output of this node is local, and thus potentially different, for each user. Hence each user only sees the value relevant to their system hardware. This node only has the value True for a single frame when the right mouse button is pressed. 
}





FrooxEngine.LogiX.Locomotion.GetActiveLocomotionModule:####################################################
{
The <color=#00FF00>Get Active Locomotion Module</color> node outputs the input User's current locomotion module.
Usage

When a user is referenced, you can get the type of Locomotion the user is currently using. 
}



FrooxEngine.LogiX.Locomotion.InstallLocomotionModules:#####################################################
{
The <color=#00FF00>Install Locomotion Modules</color> node installs locomotion modules under the ModulesRoot slot hierarchy for use by the TargetUser when an impulse is received at Install.
Usage

The TargetUser input defaults to the local user.


The ClearExisting input determines whether all modules previously installed for the TargetUser are removed before installing new modules.


The OnInstalled fires an impulse when any locomotion modules under the ModulesRoot have been installed as a result of an impulse received at Install. An impulse will not be fired if there is no valid ModulesRoot input. However, an impulse will be fired as long as there is a ModulesRoot, even if there are no locomtion module components under the hierarchy which can be installed. This impulse continues the impulse chain which arrived at Install.


When an impulse is received at Install, the ModulesRoot slot hierarchy is copied under the Locomotion Modules slot under the TargetUser's user root slot. Any locomotion module components under that hierarchy are then registered with that user's Locomotion Controller. This process does not check for duplicates before installing, so pulsing this node with the same ModulesRoot and TargetUser will install multiple copies of the same module. The name of an installed module in the context menu is taken from the name of the slot on which the module is present. 
}


FrooxEngine.LogiX.Physics.OnLocomotionGripEnd:#############################################################
{
The <color=#00FF00>On Grip End</color> node fires an impulse when a user stops gripping the input Grip.
Usage

The Grip input takes a reference to a LocomotionGrip component.


The OnEvent output fires an impulse when the Grip stops being gripped by a user. Impulses are owned by the user who released the Grip component.


The Module output provides the locomotion module in use by the user who released the Grip component. This value is only available for the duration of the impulse chain started by OnEvent.


The GrippingBodyNode output provides a BodyNode enum value indicating which body node the Grip was released by. This will most likely be the Right Hand or Left Hand.

}


FrooxEngine.LogiX.Physics.OnGripStart:#####################################################################
{
The <color=#00FF00>On Grip Start</color> node fires an impulse when a user starts gripping the input Grip.
Usage

The Grip input takes a reference to a LocomotionGrip component.


The OnEvent output fires an impulse when the Grip starts being gripped by a user. Impulses are owned by the user who gripped the Grip component.


The Module output provides the locomotion module in use by the user who gripped the Grip component. This value is only available for the duration of the impulse chain started by OnEvent.


The GrippingBodyNode output provides a BodyNode enum value indicating which body node the Grip was gripped by. This will most likely be the Right Hand or Left Hand. 
}



FrooxEngine.LogiX.Physics.OnGripStay:######################################################################
{
The <color=#00FF00>On Grip Stay</color> node fires an impulse every frame while a user grips the input Grip.
Usage

The Grip input takes a reference to a LocomotionGrip component.


The OnEvent output fires impulses while the Grip is gripped by a user. Impulses are owned by the user gripping the Grip component.


The Module output provides the locomotion module in use by the user gripping the Grip component. This value is only available for the duration of the impulse chain started by OnEvent.


The GrippingBodyNode output provides a BodyNode enum value indicating which body node the Grip is gripped by. This will most likely be the Right Hand or Left Hand.

}



FrooxEngine.LogiX.Physics.OnLocomotionGripBegin:###########################################################
{
The <color=#00FF00>On Locomotion Grip Begin</color> node fires impulses whenever the active user of the input Locomotion module starts gripping an object.
Usage

The OnEvent fires an impulse when a locomotion grip starts with the input Locomotion module. Impulses are owned by the user who performed the grip.


The GrippedSlot provides the slot which was gripped. This value is only available for the duration of the impulse chain started by OnEvent.


The GrippedPoint provides the global position of the point at which the grip occurred.


The GrippingHand provides a Chirality enum indicating which hand the grip was performed with.

}



FrooxEngine.LogiX.Physics.OnLocomotionGripBegin:##########################################################
{
The <color=#00FF00>On Locomotion Grip End</color> node fires impulses whenever the active user of the input Locomotion module stops gripping an object.
Usage

The OnEvent fires an impulse when a locomotion grip stops with the input Locomotion module. Impulses are owned by the user who released the grip.


The GrippedSlot provides the slot which was released from being gripped. This value is only available for the duration of the impulse chain started by OnEvent.


The GrippedPoint provides the global position of the point at which the grip was released.


The GrippingHand provides a Chirality enum indicating which hand the grip was released with.

}


FrooxEngine.LogiX.Locomotion.SwitchLocomotionModule:######################################################
{

The <color=#00FF00>Switch Locomotion Module</color> node switches the TargetUser's active locomotion module to one with a matching ModuleName when an impulse is received at Switch.

Usage

The TargetUser input defaults to the local user.


The ModuleName input specifies which locomotion module should be switched to. For the standard locomotion module presets, use the relevant locale strings:

    Locomotion.Noclip.Name
    Locomotion.Teleport.Name
    Locomotion.Fly.Name
    Locomotion.WalkRun.Name
    Locomotion.WalkRunGripping.Name
    Locomotion.ZeroG.Name
    Locomotion.GrabWorld.Name
    Locomotion.Slide.Name

For custom locomotion modules, use the slot name under which the relevant component is present. e.g. if you have a customized PhysicalLocomotion preset on a slot called "Swim" then use Swim as the input string to ModuleName.


The ExactMatch controls whether only modules with exactly matching names will be used. Default is False.


The OnSwitched output fires an impulse when the TargetUser's locomotion is successfully switched as a result of an impulse received at Switch. An impulse will be fired as long as a valid match was detected even if it was the same as the user's already active module.


The OnNotFound output fires an impulse if no valid matching locomotion module can be found when an impulse is received at Switch. This may fire if:

    the ModuleName is null, empty or just a string composed of whitespace
    the user has no LocomotionController component (users will normally have one of these!)
    there is no matching locomotion module given the ModuleName and ExactMatch values


Searching for valid locomotion modules is performed on the modules referenced in the TargetUser's LocomotionController (present on their user root slot) in ascending index order. If there are two matches, the one with the lowest index will be used. No impulse will be fired from either OnSwitched or OnNotFound if the TargetUser input is not empty, but null. 

}




FrooxEngine.LogiX.Meta.RemoveAllLogixVisuals:##############################################################
{
The <color=#00FF00>Remove All Logix Visuals</color> node packs any LogiX nodes parented under the SearchRoot slot directly under the MoveUnder slot when an impulse is received at Remove. This both removes the node visuals and reparents the node slots.
Usage

The SearchRoot input defines the hierarchy from which slots containing LogiX components will be moved. Any nodes which are parented under the SearchRoot, or any of its child slots (down to arbitrary depth), will be moved and have visuals hidden. There is no default input.


The MoveUnder input slot is the slot under which any slots containing LogiX components will be parented. If this input is unset and an impulse is received at Remove then LogiX node visuals will be hidden without any reparenting.


The Traversal input enum value controls how the node graph traversal operates. If set to StopAtOtherNodes, nodes which are not currently parented under the SearchRoot and which are only connected to nodes which are via references (arrow shaped Ref nodes) will not be affected if an impulse is received at Remove. By contrast, if set to Complete, nodes which are linked to nodes parented under the SearchRoot will also be affected (e.g. storage variable nodes which are targets of a Write node. This works the same way as the Traversal setting on the LogiX tooltip (see tutorial by ProbablePrime). Defaults to StopAtOtherNodes.


The OnRemoved output fires an impulse when the node has successfully performed it's operation after an impulse is received at Remove. This only requires that there be a valid SearchRoot input, an impulse is still fired even if there are no LogiX nodes parented under the SearchRoot and therefore no changes made.

}



FrooxEngine.LogiX.Meta.RevealAllLogixVisuals:##############################################################
{
The <color=#00FF00>Reveal All Logix Visuals</color> node unpacks and generates visuals for all LogiX nodes parented under the SearchRoot when an impulse is received at Reveal.
Usage

The OnRevealed output fires an impulse when any LogiX nodes are successfully unpacked as a result of an impulse received at Reveal. This only requires that a valid SearchRoot input slot is present, an impulse is still fired even if no LogiX nodes are actually unpacked.


The function of the Traversal input is currently unclear. 
}


FrooxEngine.LogiX.Network.EscapeUriDataString:#############################################################################
{
Escapes dissallowed uri characters into uri escapes which allows you to send the output string over the network without issues.
For example `Hello World!` turns into `Hello%20World%21`.
}
FrooxEngine.LogiX.Network.UnescapeUriDataString
{
Unescapes uri escape characters into their original forms which allows you to easily read output from the network.
For example `Hello%20World%21` turns into `Hello World!`.
}
FrooxEngine.LogiX.Network.IsHostAccessAllowed:#############################################################################
FrooxEngine.LogiX.Network.IsHostAccessAllowedUrl
{
Checks whether a user has allowed host access to a provided domain.

In neos by default you cannot perform web request to arbitrary domains, to do this each user has to explicitly allow each domain that you want to perform requests to.
}
FrooxEngine.LogiX.Network.RequestHostAccessBase:#############################################################################
{
this node isn't even supposed to exist. why are you here, get out, pick a normal node instead like smooth lerp or something
}
FrooxEngine.LogiX.Network.RequestHostAccessUrl:#############################################################################
{
Prompts the user with a popup asking if the user wants to allow neos to make web requests to a provided domain.

In neos by default you cannot perform web request to arbitrary domains, to do this each user has to explicitly allow each domain that you want to perform requests to.
}

FrooxEngine.LogiX.Network.WebsocketBaseNode // abstract
FrooxEngine.LogiX.Network.WebsocketConnectionEvents:######################################################
{
The <color=#00FF00>Websocket Connection Events</color> node provides impulses that indicate if a given 
Websocket Client has successfully connected, failed to connect, or was otherwise disconnected

Usage

After initiating a connection with the Websocket Connect node, this node will provide an impulse indicating 
if the connection was successful, or if it failed.

Once a Connectedimpulse is received, other WebSocket nodes can be used to communicate with the endpoint, 
such as the Websocket Text Message Sender and Websocket Text Message Receiver

A Disconnected impluse indicates that the Websocket was disconnected, or the connection was rejected by 
the user specified in Client 
}
FrooxEngine.LogiX.Network.WebsocketTextMessageReceiver:#####################################################
{
The <color=#00FF00>Websocket Text Message Receiver</color> node indicates when the Websocket endpoint 
specified by Client has received data. 
}
FrooxEngine.LogiX.Network.WebsocketConnect:##################################################################
{
The <color=#00FF00>Websocket Connect</color> node allows the User specified in HandlingUser to connect 
to a websocket endpoint, as defined by Client

Usage

This node must be used in conjunction with other WebSocket nodes to establish communication with an endpoint, 
which is defined by a Websocket Client component that is passed to the Client input.

The OnConnectStart impulse signifies that the Client has started the connection process - it does *not* mean 
that the client has successfully connected.

Connection success/fail events are provided by the Websocket Connection Events Node 
}
FrooxEngine.LogiX.Network.WebsocketTextMessageSender:#########################################################
{
The <color=#00FF00>Websocket Text Message Sender</color> node sends a string specified by Data to the 
websocket endpoint specified by Client

Usage

Once a connection has been initialized by a Websocket Connect node, and the Connected event has been 
received on a Websocket Connection Events node, this node can be used to send strings to the target endpoint.

OnSendStart indicates that the Data string has began transmitting.

OnSent indicates that the Data string has finished transmitting successfully.

OnSendError indicates that the Data string failed to transmit - either the socket is no longer connected, 
or some other error occurred during transmission.

If the send was successful, SentData contains the string that was originally given as Data - this is useful 
in cases where Data's value has changed between the Send impulse, and the OnSent impulse. 
}



FrooxEngine.LogiX.Network.RequestHostAccess:################################################################
{
The <color=#00FF00>Request Host Access</color> node informs the user that owns the Request impulse that you wish to connect to a particular host, and allows them to grant or deny access.
Usage

When given a Request impulse, the following will occur:

    If the user has previously granted access to this host, OnGranted will immediately fire
    If the user has previously denied access to this host, OnDenied will immediately fire, and any attempt to connect to this host will fail
    If the user has not previously granted or denied access, or has closed the prompt without selecting an option before, they will be presented with a prompt displaying the Host and Reason, and given the option to Allow or Reject the connection.
        If allowed, OnGranted will fire, and no further prompts will be displayed.
        If rejected, OnDenied will fire, and no further prompts will be displayed, and any attempt to connect to this host will fail
        If dismissed, no impulse will fire, and any future host access requests will result in the prompt being shown again.

Host should contain only the host portion of the URL you wish to connect to.

For example, if you wanted to perform a GET request to https://wiki.neos.com/index.php, you would provide wiki.neos.com as the Host parameter.

Reason should provide a clear and concise reason for wanting to connect to the external service - It should include an obvious title or description of the object that is attempting to establish the connection, so that the user is aware of what item in the world is prompting the connection.

The object should also have some way of indicating that it did not successfully connect to the target service, and that it will not function as intended, if at all. 
}



FrooxEngine.LogiX.Network.GET_String:#######################################################################
{
The <color=#00FF00>GET String</color> node makes an HTTP GET Request to a given URL, and upon success returns the result as a String
Usage

Before using this node, check if the user allows connections to this host using the Is Host Access Allowed node. If access is not already granted, it can be requested using the Request Host Access node

Executing a HTTP request without being granted access will result in the request failing.

    URL is the full host path to which a HTTP GET request will be sent
    OnSent indicates that the request has been sent, but has not yet received a response.
    OnResponse indicates that the remote server has responded. Any text returned by the server will be available in Content, and StatusCode will indicate any errors the remote server encountered while handling this request.
    OnError indicates that there was an error connecting to the remote server.
    Content contains any string returned by the server in the response body.
    StatusCode contains the HTTP Status Code of the response. Normally, this will be 200/OK to indicate success.
}
FrooxEngine.LogiX.Network.POST_String:#####################################################################
{
<color=#00FF00>Post String</color> logix node requires you to specify the type of data being send to the server 
}



FrooxEngine.LogiX.CacheNode`1[T]:##########################################################################
{
The <color=#00FF00>Cache</color> node can be used for performance optimization. If you have a complex or heavy calculation with result that's read by multiple other nodes, you can place this node at the end. This will make sure that the input is evaluated only once (per evaluation context) and the result reused for the other nodes. In most cases you don't need it and it doesn't change the functionality in any way. At some point in the future this is going to be handled automatically. 
}

FrooxEngine.LogiX.DelayValueNode`1[T]:#####################################################################
{
The <color=#00FF00>Delay Value</color> node outputs the value that the Value input held at a time DelayTime seconds before hand.
Usage

If the DelayTime input is increased while a valid Value is provided, the output value will freeze at the most recent output value until sufficient delay has accumulated. The output will be frozen for a number of seconds equal to the new DelayTime - previous DelayTime. e.g. if DelayTime is 1 and then it is instantly increased to 10 the output value will be frozen for 9 seconds. If, instead, the DelayTime value is decreased, the delayed value updates to the correct value immediately.

When spawned from the Node Browser this node has a 'dummy' datatype, however it will overload to the correct type if a valid value or reference type input is connected. 
}


FrooxEngine.LogiX.Operators.Demultiplexer`1[T]:############################################################
{
The <color=#00FF00>Demultiplex</color> node outputs the input Value at the output with corresponding to the input Index. Every other output is set to the input DefaultValue.
Usage

The Index value corresponding to each ValueOutput is indicated in square brackets in the output's name.


The OutputCount output provides the number of ValueOutputs the node currently supports.


This node has a dummy unset datatype when spawned from the node browser. However, it will overload to the correct type when any value or reference typed input is connected. If the Index is less than 0 or greater than OutputCount -1 all outputs will have the DefaultValue.

}

FrooxEngine.LogiX.Display.Display:#########################################################################
{
The <color=#00FF00>Display</color> node displays the current value of the Datatype. Create this node by Dragging a Datatype and pressing the Secondary Action Button. 
}


FrooxEngine.LogiX.Display.Display_Color
FrooxEngine.LogiX.Display.Display_ColorX:##################################################################
{
Test Description for datatype Overwrite
}



FrooxEngine.LogiX.Display.DisplayImpulse:##################################################################
{
The <color=#00FF00>Display Impulse</color> node displays a colourful 'pulse' visual whenever an impulse is received at ImpulseTarget. These can be spawned by dragging a wire out from any impulse output and pressing the Secondary Action Button.
Usage

The node also displays for the most recent received impulse:

    The session time at which the impulse was received
    Who the impulse was owned by (i.e. on whose Neos client the impulse chain ran)
    The total number of impulses received by the node
    The global index (i.e. how many impulses in total have been received by impulse display nodes in the current session)
}


FrooxEngine.LogiX.ImpulseRelay:############################################################################
{
The <color=#00FF00>Impulse Relay</color> node is used to make your LogiX tidy. Instead of the impulse connection graphically going directly from point A to point B, you can insert impulse relays into the connection, and then drag the relays around until the connection path looks nicer.

To insert an impulse relay in an impulse connection, simply grab using the LogiX Tooltip on the connection at the location you want the relay to be inserted.
Usage
Examples

In this image, red arrows point to the locations of impulse relays along a long impulse connection. Without these relays, the connection would go directly from the If node on the left to the If node on the right, obscuring some of the logic. 
}


FrooxEngine.LogiX.Operators.Multiplexer`1[T]:#############################################################
{
The <color=#00FF00>Multiplex</color> node outputs one of the multiple Operands input values determined by the Index input.
Usage

The index corresponding to each input is visible in square brackets in the respective input name.


The InputCount output provides the current number of inputs.


This node initially had an unset dummy datatype when spawned from the node browser. It will overload to the correct datatype when any value or reference typed value is connected. If the Index value is out of range, i.e. it is less than 0 or greater than InputCount -1, the output will either be the type default value (for value types) or null for reference types.
}


FrooxEngine.LogiX.Operators.PickRandom`1[T]:############################################################
{
<color=#00FF00>Pick Random</color>
Outputs randomly from the inputs.
}

FrooxEngine.LogiX.RelayNode`1[T]:#########################################################################
{
The <color=#00FF00>Impulse Relay</color> node contains 1 Input node and 1 Output node. The use of the relay is to create a connection point to help organize your code. 
}



FrooxEngine.LogiX.UpdatingRelayNode`1[T]:#################################################################
{
<color=#00FF00>Updating</color>
Usage

Ensure that changes are generated and evaluated every single frame, even if the input nodes don't trigger changes themselves. Can be used to force per-frame updates for some nodes that don't automatically update for performance or implementation reasons, for example GetTag.

Use only when you actually need updates every frame (e.g. using a driver node or On Changes node), as this has performance implications. 
}







FrooxEngine.LogiX.Operators.All_Bool2
{Basically an AND gate for Boolean Vectors... Boolean vectors a bundle of Boolean values in a single wire
 IF ALL boolean values in wire are True, then the output is True}

FrooxEngine.LogiX.Operators.Any_Bool2
{Basically an OR gate for Boolean Vectors... Boolean vectors a bundle of Boolean values in a single wire
IF ANY boolean values in the wire are True, then the output is True}

FrooxEngine.LogiX.Operators.None_Bool2
{Basically a NOR gate for Boolean Vectors... Boolean vectors a bundle of Boolean values in a single wire
If NO boolean values in the wire are True, then the output is True}

FrooxEngine.LogiX.Operators.PackNullable`1:#######################################################################################################
FrooxEngine.LogiX.Operators.UnpackNullable`1
{
<color=#00FF00>Pack</color> / <color=#00FF00>Unpack</color> nullable allow you to create and extract nullable types which are normal value types 
(such as int), with the ability of becoming null. These aren't useful in user made creations but are sometimes used in existing components 
(such as AvatarRenderSettings)
}



FrooxEngine.LogiX.Operators.Parse:##############################
{
parses a string into the respective value
}


FrooxEngine.LogiX.Operators.Sub_Float:##################################################################################################################################
{
The <color=#00FF00>-</color> node subtracts the value of input B from input A.
Usage

Note that this node takes a float datatype by default, however it can cast to handle various different numeric datatypes if an appropriate wire is connected. 
If there are more than 3 inputs the naming of inputs changes to Operands.[0], Operands.[1] ... etc. In that case, all inputs are subtracted from Operands.[0]. 
}


FrooxEngine.LogiX.Operators.NOT_Int:##################################################################################################################################
{

The <color=#00FF00>!</color> node performs the logical NOT operation on input A. 

Usage:
When spawned from the node browser, this node accepts an int datatype by default, but it is more commonly used to work with Boolean values (True/False) 
where it inverts whatever input it receives  True becomes False / False becomes True. This node will accept some numeric datatypes, in which case it performs 
the operation in a bitwise manner. 

The most common use of the node as a boolean operator simply inverts the value it receives. True becomes False, and False becomes True. 

}


FrooxEngine.LogiX.Operators.NotEquals_Float:##################################################################################################################################
{
The <color=#00FF00>!=</color> node checks whether inputs A and B are not equal, outputting True if they are not equal and False if they are equal. 

When spawned from the node browser, this node accepts float data by default. However, this node can be overloaded to accept 
a wide variety of value and reference datatypes if an appropriate wire is connected to one of the inputs. 
}


FrooxEngine.LogiX.Operators.Mod_Float:##################################################################################################################################
{

The <color=#00FF00>%</color> node divides A by B and outputs the remainder.
Usage

The top input is the number to divide, the bottom what we are dividing by. Returns the remainder of division. 

We can use the Modulo node to determine whether a number is even or odd. To do this, divide the number by 2. 0 indicates even and 1 indicates odd. 

}

FrooxEngine.LogiX.Operators.AND_Int:##################################################################################################################################
{

The <color=#00FF00>&</color> node performs the logical AND operation on inputs A and B.
Usage

When spawned from the node browser, this node accepts the int datatype by default, but it is more commonly used to work with Boolean values (True/False). 
The outputs will be True if, and only if, all inputs are True - otherwise it will output False. This node will accept some numeric datatypes, in which case 
it performs the operation in a bitwise manner. 
}

FrooxEngine.LogiX.Operators.ConditionalOperator`1[T]
FrooxEngine.LogiX.Operators.Conditional_Float:##################################################################################################################################
{
The <color=#00FF00>?:</color> node outputs either the OnTrue or OnFalse input values depending on the value of the Condition input. 

When spawned from the node browser, this node accepts the float datatype by default. However, this node can be overloaded to use 
other value or reference types if an appropriate wire is connected. This operator is commonly referred to as the 'ternary' or 'conditional' operator. 
}


FrooxEngine.LogiX.Operators.NullCoalesce`1[T]:##################################################################################################################################
{
The <color=#00FF00>??</color> node outputs the value of the first input which is not null.
Usage

When spawned from the node browser, this node accepts the object datatype by default. However, this node can be overloaded to use various reference 
types if an appropriate wire is connected. Inputs are checked for not-null values in order: A, then B (or Operands.[0], Operands.[1], Operands.[2] ... 
etc. if more than 2 inputs are present). Output will be null if all inputs are also null. This operator can be referred to as the 'null-coalescing' operator. 
}


FrooxEngine.LogiX.Operators.XOR_Int:##################################################################################################################################
{
The <color=#00FF00>^</color> node performs the logical exclusive OR (XOR) operation on inputs A and B.
Usage

When spawned from the node browser, this node accepts the int datatype by default, but it is more commonly used to work with Boolean values (True/False).

If any inputs are toggled the output will also toggle. This node will accept some numeric datatypes, in which case it performs the operation in a bitwise manner. 
}


FrooxEngine.LogiX.Operators.OR_Int:##################################################################################################################################
{
The <color=#00FF00>|</color> node performs the logical inclusive OR operation on inputs A and B.
Usage

When spawned from the node browser, this node accepts the int datatype by default, but it is more commonly used to work with Boolean values (True/False) as shown in the image.

The output will be True if any of inputs are True  otherwise it will output False. This node will accept some numeric datatypes, in which case it performs the operation 
in a bitwise manner. 
}


FrooxEngine.LogiX.Operators.Magnitude_Float2:##################################################################################################################################
{
<color=#00FF00>Magnitude</color> (LogiX node)
Get distance by float from center(Coordinate 0.0.0) of parent object with root() calculate. 

Get actual distance value from center(0.0.0) point if parent object is world. 
}


FrooxEngine.LogiX.Operators.SqrMagnitude_Float2:##################################################################################################################################
{
<color=#00FF00>Magnitude Squared</color> (LogiX node)
Get distance by float from center(Coordinate 0.0.0) of parent without root() calculate. It's equal to Magnitude(|V|) after root calculate 
Usage

Get approximity distance value from center of parent. 
}


FrooxEngine.LogiX.Operators.Add_Float:##################################################################################################################################
{
The <color=#00FF00>+</color> node outputs the sum of all input values.
Usage

When spawned from the node browser, this node accepts the float datatype by default. However, this node can be overloaded to accept different numeric 
value types if an appropriate wire is connected to an input. This node can also be overloaded to accept the string datatype, in which case it outputs 
all inputs concatenated together. 
}


FrooxEngine.LogiX.Operators.PlusMinus_Float:##################################################################################################################################
{
The <color=#00FF00>+/-</color> node
Usage

Adds and subtracts the two floats at the same time. Top output adds the 2 floats together. Bottom output subtracts the 2 floats from each other. 
}

FrooxEngine.LogiX.Operators.Inc_Float:##################################################################################################################################
{
The <color=#00FF00>+1</color> node outputs the value of input A increased by 1.
Usage

When spawned from the node browser, this node accepts the float datatype by default. However, this node can be overloaded to accept various numeric value 
types if an appropriate wire is connected to the input. 
}

FrooxEngine.LogiX.Operators.LessThan_Float:##################################################################################################################################
{
The < node checks whether input A is less than B.
Usage

When spawned from the node browser, this node accepts the float datatype by default. 
However, this node can be overloaded to accept various numeric value types if an appropriate wire is connected to the input. 
This node outputs True if input A is less than input B, otherwise False. 
}

FrooxEngine.LogiX.Operators.ShiftLeft_Int:##################################################################################################################################
{

<color=#00FF00>Left Shift</color>
The << node outputs an integer that has had its binary value arithmetically shifted X units to the left. 
}


FrooxEngine.LogiX.Operators.Equals_Float:##################################################################################################################################s
{

The <color=#00FF00>==</color> node checks whether inputs A and B are equal, outputting True if they are equal and False if they are not equal.
Usage

When spawned from the node browser, this node accepts float data by default. However, this node can be overloaded to 
accept a wide variety of value and reference datatypes if an appropriate wire is connected to one of the inputs. 

}

FrooxEngine.LogiX.Operators.GreaterThan_Float:##################################################################################################################################s
{

<color=#00FF00>Greater Than</color>
The > node checks whether input A is greater than B.
Usage

When spawned from the node browser, this node accepts the float datatype by default. However, this node can be overloaded 
to accept various numeric value types if an appropriate wire is connected to the input. This node outputs True if input A is greater than input B, otherwise False. 

}


FrooxEngine.LogiX.Operators.ShiftRight_Int:##################################################################################################################################s
{
<color=#00FF00>Right Shift</color>

The >> node outputs an integer that has had its binary value arithmetically shifted X units to the right.
}


FrooxEngine.LogiX.Operators.Mul_Float:##################################################################################################################################s
{

The <color=#00FF00></color> node multiplies the input values by each other and outputs the product.
Usage

When spawned from the node browser, this node accepts the float datatype by default. However, this node can be overloaded to accept 
different numeric value types if an appropriate wire is connected to an input. If vector datatypes are connected, e.g. float3 values, 
the multiplication is calculated element-wise. For example, if inputs A and B are [1,2,3] and [4,5,6] are connected the output will be [4,10,18].

This node can be overloaded to accept some mixtures of datatypes. For example if a vector value (e.g. a float3, RGBA color value etc.) 
is connected to the A input a scalar value (e.g. float) can be connected to the B input. The output will be a vector with the same number 
of dimensions as A with all elements multiplied by B.

Another useful combination of datatypes allows strings to be repeated a defined number of times and concatenated together. To do this, 
connect the string to be repeated to input A and an integer (int) with the number of times the string should be repeated to input B. See below for an example.

Note that, if the number of inputs is increased above 2, it is no longer possible to perform operations with mixed datatypes.
Examples

Given the inputs "A" and 3 would result in the output string "AAA" 

}



FrooxEngine.LogiX.Operators.MulDeltaTime_Float:##################################################################################################################################s
{
The <color=#00FF00>dT</color> node multiplies the input value by the duration of the previous frame update (in seconds).

}

FrooxEngine.LogiX.Operators.Div_Float:##################################################################################################################################s
{
The <color=#00FF00></color> node divides the A input by the B input, and returns the result.
Usage

When spawned from the node browser, this node accepts the float datatype by default. However, this node can be overloaded to accept different numeric value 
types if an appropriate wire is connected to an input. With most datatypes connected, this node performs floating point division. Notably in this mode 0  0 
outputs the special numeric value NaN. Any non-zero number divided by zero results in the special value Infinity. If integer (int) datatypes are connected, 
this node performs integer division and outputs the quotient of the result (if the remainder is required instead use % (LogiX node)).

If vector datatypes are connected, e.g. float3 values, the division is calculated element-wise. For example, if inputs A and B are [10,15,20] and [2,3,4] are 
connected the output will be [5,5,5].

This node can be overloaded to accept some mixtures of datatypes. For example if a vector value (e.g. a float3, RGBA color value etc.) is connected to the 
A input a scalar value (e.g. float) can be connected to the B input. The output will be a vector with the same number of dimensions as A with all elements divided by B. 

}


FrooxEngine.LogiX.Operators.DivDeltaTime_Float:##################################################################################################################################
{
The <color=#00FF00>dT</color> node divides the input value by the duration of the previous frame update (in seconds).
Usage

This node can be very useful for detemining changes (e.g. speeds) in units per second by normalising other instantaneous values. 
An example would be to connect the Character Linear Velocity (LogiX node) output to this node to get a result in metres per second.
}


FrooxEngine.LogiX.Operators.Approximately_Float:##################################################################################################################################
{
The <color=#00FF00></color> nodechecks whether inputs A and B are approximately equal. If they are within the margin of error specified by the Epsilon input this node 
outputs True, otherwise False.
Usage

Due to the fact that decimal numbers often cannot be precisely encoded in binary it is unreliable to use the == (LogiX node) to attempt to test whether two floating point 
numbers are exactly equal. This node can be used in this situation to check whether two floating point numbers are approximately equal. Note that the output can 
sometimes be counterinuitive, again due to the inability to precisely encode decimal numbers in binary. For example, 0 and 0.5 are reported as not equal with an 
Epsilon of 0.5. However 0.4 and 0.9, where the difference is again 0.5, are reported as equal with the same Epsilon value.

This node can be overloaded to accept vector inputs at A and B (e.g. float 3). In that case equality comparisons are performed element-wise using the same Epsilon value for each.

Other nodes which can often be used in place of this node are  or . 

}


FrooxEngine.LogiX.Operators.SmallerOrEqual_Float:##################################################################################################################################
{

The  node checks whether input A is less than or equal to B.
Usage

When spawned from the node browser, this node accepts the float datatype by default. However, 
this node can be overloaded to accept various numeric value types if an appropriate wire is connected to the input. 
This node outputs True if input A is less than or equal to input B, otherwise False. 


}


FrooxEngine.LogiX.Operators.GreaterOrEqual_Float:##################################################################################################################################
{

The  node checks whether input A is greater than or equal to B.
Usage

When spawned from the node browser, this node accepts the float datatype by default. However, this node can be overloaded to accept various numeric value types 
if an appropriate wire is connected to the input. This node outputs True if input A is greater than or equal to input B, otherwise False.

}


FrooxEngine.LogiX.Operators.Angle_Float2:##################################################################################################################################

{

The <color=#00FF00></color> node outputs the smallest angle between A and B in degrees.
Usage

When spawned from the node browser, this node accepts the float2 datatype by default. However, this node can be overloaded to accept different numeric vector value types 
if an appropriate wire is connected to an input. Note that if an integer (int) vector is connected the output is still a float.

Default values for A and B are [0,0], resulting in a default output of 90. Output is always in the range 0 to 180 inclusive. 

}


FrooxEngine.LogiX.Operators.Dot_Float2:##################################################################################################################################

{

The <color=#00FF00></color> node calculates the dot (or scalar) product of input vectors A and B.
Usage

When spawned from the node browser, this node accepts the float2 datatype by default. However, this node can be overloaded to accept different numeric vector 
value types if an appropriate wire is connected to an input. Note that if an integer (int) vector is connected the output is still a float.
Examples

The vector dot product has a very useful property: if the input vectors are pointing in approximately the same direction the sign of the output is positive. 
Similarly the sign will be negative if the vectors point in approximately opposite directions. The value is zero if the vectors are exactly at right angles to each other. 

}


FrooxEngine.LogiX.Math.ZeroOne:##################################################################################################################################
{
The <color=#00FF00>0 1</color> node can be used to convert a Boolean value to a float.
Usage

For the Boolean input True the output is 1, for False the output is 0.
Examples

This is commonly used to convert a bool to a float for driving blendshapes. 

}



FrooxEngine.LogiX.Operators.Dec_Float:##################################################################################################################################
{

The <color=#00FF00>-1</color> node subtracts 1 from the value of input A.
Usage

By default this node accepts the float datatype, however it can cast to accept other numeric datatypes if an appropriate one is connected. 

}



FrooxEngine.LogiX.Operators.Reciprocal_Float:##################################################################################################################################
{

The <color=#00FF00>1/x</color> node outputs the reciprocal of X  or 1 divided by the input X.
Usage

By default this node accepts the float datatype, however it can be overloaded to accept various numeric value types if an appropriate wire is connected. 
If a vector datatype is connected (e.g. float3), the output will have the same number of dimensions with each element of the output being 1 divided by the 
corresponding element of the input. Note that for integer (int and related) datatypes this node performs integer division. This results in an invalid output 
which causes errors if the input is 0, output of 1 if the input is 1, and output of 0 for any other value. 

}

FrooxEngine.LogiX.Operators.OneMinus_Float:##################################################################################################################################
{

The <color=#00FF00>1-x</color> node outputs the value of X subtracted from 1.
Usage

By default this node accepts the float datatype, however it can be overloaded to accept various numeric value types if an appropriate wire is connected. 
If a vector datatype is connected (e.g. float3), the output will have the same number of dimensions with each element of the output being the corresponding element substracted from 1. 

}



FrooxEngine.LogiX.Operators.Inverse_Float2x2:##################################################################################################################################
{

The <color=#00FF00>A^-1</color> node outputs the inverse matrix of the input matrix A.
Usage

When spawned from the node browser, this node accepts the float2x2 datatype by default. However, this node can be overloaded to accept 
3x3 or 4x4 float matrices (as well as double type matrices) if appropriate wire is connected to an input. Note that not all input matrices are 
guaranteed to be invertible, the output will be a zero matrix in the case that it is not. 

}


FrooxEngine.LogiX.Operators.Cross_Float3:##################################################################################################################################
{

The <color=#00FF00>Cross</color> node calculates the cross (or vector) product of input 3-dimensional vectors A and B.
Usage

When spawned from the node browser, this node accepts the float3 datatype by default. 
However, this node can be overloaded to accept the double3 datatype if an appropriate wire is connected. 

}



FrooxEngine.LogiX.Operators.Determinant_Float2x2:##################################################################################################################################
{

The <color=#00FF00>Determinant</color> node calculates the determinant of the input matrix.
Usage

When spawned from the node browser, this node accepts the float2x2 datatype by default. 
However, this node can be overloaded to accept 3x3 or 4x4 float matrices (as well as double type matrices) 
if appropriate wire is connected to an input. 

}



FrooxEngine.LogiX.Operators.Distance_Float:##################################################################################################################################
{
Get distance by float between two object. 
}


FrooxEngine.LogiX.Operators.FilterInvalid_Float:##################################################################################################################################
{

The <color=#00FF00>Filter Invalid</color> node outputs the input Value unless it contains the special NaN or Infinity values, in which case it outputs the Fallback input.
Usage

When spawned from the node browser, this node accepts the float datatype by default. However, this node can be overloaded to accept float2/3/4/Q (or double typed variants) 
if an appropriate wire is connected to the input. Note that for vector input types the full Fallback value will be output if any of the input vector components is NaN/Infinity. 

}


FrooxEngine.LogiX.Operators.GetType:##################################################################################################################################
{

The <color=#00FF00>Get Type</color> node outputs the name of datatype of the input connection wire.
Usage

This node can be useful for determining what the datatype of an unfamiliar wire or connection point. Particularly useful with component index cards. 

}


FrooxEngine.LogiX.Operators.IsInfinity_Float:##################################################################################################################################
{

The <color=#00FF00>IsInfinity</color> node outputs True if the input value has the special numeric value Infinity, otherwise False.
Usage

When spawned from the node browser, this node accepts the float datatype by default. However, this node can be overloaded to accept float2/3/4/Q 
(or double typed variants) if an appropriate wire is connected to the input. Note that for vector input types the output is True if any component of the input Value is Infinity. 

}


FrooxEngine.LogiX.Operators.IsNaN_Float:##################################################################################################################################

{

The <color=#00FF00>IsNaN</color> node outputs True if the input value has the special numeric value NaN, otherwise False.
Usage

When spawned from the node browser, this node accepts the float datatype by default. However, this node can be overloaded to 
accept float2/3/4/Q (or double typed variants) if an appropriate wire is connected to the input. Note that for vector input types the 
output is True if any component of the input Value is NaN. 

}


FrooxEngine.LogiX.Operators.IsNullNode`1[T]:##################################################################################################################################
{

The <color=#00FF00>IsNull</color> node outputs True if the input reference datatype is null, otherwise False.
Usage

When spawned from the node browser, this node accepts the object datatype by default. However, this node can be overloaded to accept any reference datatype if an appropriate 
wire is connected.

The NotNull (LogiX node) works in the opposite way.
Examples

Using a String as an example. The string being empty outputs as True

When it's no longer empty, it'll output Fales
}



FrooxEngine.LogiX.Operators.Mask_Float2:##################################################################################################################################
{
Mask
Filtered value from Input data by bool switch. 
Bool(True/False) type input switches make output. If switch is set to all "True" then output data is equal by first input parameter.

[1, 2] is True side and [3, 4] is False side. Top switch is True. So getting top data(1) from True side. And bottom switch is set to False this is get bottom data(4) from False side. 
}


FrooxEngine.LogiX.Operators.MatrixElement_Float2x2:##################################################################################################################################
{

The <color=#00FF00>Matrix Element</color> outputs the value of the matrix element at the input Row and Column coordinates.
Usage

When spawned from the node browser, this node accepts the float2x2 datatype by default. 
However, this node can be overloaded to accept 3x3 or 4x4 float matrices (as well as double type matrices) if 
appropriate wire is connected to an input. Note that the output will be zero if one attempts to access an element which is out of range for the input matrix. 

}


FrooxEngine.LogiX.Operators.Negate_Float:##################################################################################################################################
{

The <color=#00FF00>-n</color> node outputs the value of input A multiplied by -1.
Usage

By default this node accepts the float datatype, however it can be overloaded to accept various numeric 
(including some vector and matrix) value types if an appropriate wire is connected. 

}


FrooxEngine.LogiX.Operators.NAND_Int:##################################################################################################################################
{

The <color=#00FF00>NAND</color> node performs the logical NAND operation on inputs A and B.


}



FrooxEngine.LogiX.Operators.NOR_Int:##################################################################################################################################

{

The <color=#00FF00>NOR</color> node performs the logical NOR operation on inputs A and B.
Usage

When spawned from the node browser, this node accepts the Bool datatype by default. The outputs will be True if, and only if, all inputs are False. Otherwise, it will output False. 

}



FrooxEngine.LogiX.Operators.Normalized_Float2:##################################################################################################################################
{

The <color=#00FF00>Normalized</color> node outputs a normalized version of the input vector. A normalized vector is a vector that has been divided by its 
magnitude such that the new vector has a magnitude of 1. Mathematically, this is equal to the input vector divided by the square root of the dot product of the input vector with itself.
Usage

When spawned from the node browser, this node accepts the float2 datatype by default. However, this node can be overloaded to accept different numeric value types 
if an appropriate wire is connected to an input.
Examples

Passing the vector [2, 2] as an input into the Normalized node would return the vector [1/sqrt(2), 1/sqrt(2)]. 

}


FrooxEngine.LogiX.Operators.NotNullNode`1[T]:##################################################################################################################################

{

The <color=#00FF00>NotNull</color> node outputs True if the input reference datatype is not null, otherwise False.
Usage

When spawned from the node browser, this node accepts the object datatype by default. However, this node can be overloaded to accept any reference datatype if an appropriate wire is connected.

The IsNull (LogiX node) works in the opposite way. 


}


FrooxEngine.LogiX.Operators.PackColumns_Float2x2:##################################################################################################################################

{

The <color=#00FF00>Pack Columns</color> node outputs a matrix formed via the joining of two or more input columns. The columns are joined from left to right in order 
of the input they are assigned to. The column inserted into the first input will become the leftmost column, and the column inserted into the last input will become the rightmost column. 

}


FrooxEngine.LogiX.Operators.Construct_Color:##################################################################################################################################

{

The <color=#00FF00>Pack rgba</color> node constructs a color from red, green, blue, and alpha channel float inputs.

Use the Unpack xyzw node to unpack a color to its red, green, blue, and alpha channel components. 

}



FrooxEngine.LogiX.Operators.PackRows_Float2x2:##################################################################################################################################

{

The <color=#00FF00>Pack Rows Float2x2</color> node outputs a matrix formed via the joining of two or more input rows. The rows are joined from top to bottom in order of the input they are assigned to. The row inserted into the first input will become the topmost row, and the row inserted into the last input will become the bottommost row.
Usage

When spawned from the node browser, this node accepts the float2 datatype by default. However, this node can be overloaded to accept different numeric value types if an appropriate wire is connected to an input. 

}


FrooxEngine.LogiX.Operators.Construct_Float2{Combines 2 like values into one vector.}

FrooxEngine.LogiX.Operators.Construct_Float3:##################################################################################################################################
{

Constructs a 3 composited data type from three individual inputs(Equal data types). Unconnected inputs will act as a default data by individual data types. 

Usage

This node can make every 3 composited data. But, Input data type is must same each other.
Examples

In this example Float3s are analagous to Vector3s in several other game engines. They are useful for representing several types of values, particularly 
Cartesian coordinates and Euler angle rotations. By using the Pack XYZ node, float3s can be constructed directly, allowing for manipulation of properties such as object transforms. 

}


FrooxEngine.LogiX.Operators.Construct_Float4:##################################################################################################################################
{

The Pack xyzw node constructs a 4-dimensional vector from four overrideable inputs.

(Note Quaternions use xyzw format and this is a way of building them)
}


FrooxEngine.LogiX.Operators.Project_Float2:##################################################################################################################################
{

The <color=#00FF00>Project</color> node projects vector A onto vector B and returns a new vector representing that projection. 

}


FrooxEngine.LogiX.Operators.Reflect_Float3:##################################################################################################################################
{

The <color=#00FF00>Reflect</color> node outputs vector A reflected over the axis formed by vector B.

}

FrooxEngine.LogiX.Operators.RotateLeft_Int:##################################################################################################################################

{

The <color=#00FF00>ROL</color> node outputs an integer that has had its binary value circularly shifted X units to the left. 

}


FrooxEngine.LogiX.Operators.RotateRight_Int:##################################################################################################################################

{

The <color=#00FF00>ROR</color> node outputs an integer that has had its binary value circularly shifted X units to the right.

}


FrooxEngine.LogiX.Operators.ToString_Float:##################################################################################################################################
{

The <color=#00FF00>To String Float</color> node evalutes the inputs to determine an output as a type string.
Usage

This node determines the string value of the first V input and spits out a string output.

Format provides the node with a pre-determined case of how to format the given input.

This node can be overriden with any type and accepts objects and gives a cleaned up output when given an object as input.
Examples

If given input V is of type color and you give it a Red value; it's stringed output is [1; 0; 0; 1]. This is the internal object printed out in it's string form. 
This should not be used for comparison as it is prone to break.

If given a type that it doesn't directly parse (Example here is a Slot) it'll print out clean versions of the Object type.


If given a slot it'll print out:

Slot: Slotname The slot's name itself.

Parent: Slotname The name of it's parent.


If given a bool it'll print out true or false depending on the input.

If format is provided as 0.00000 and a float input. The print out will display a float as 1.23456 If format is provided as 0.0 and a float4 input. The print out will display a float4 as [1.1; 2.2; 3.3; 4.4] 

}


FrooxEngine.LogiX.Operators.Transpose_Float2x2:##################################################################################################################################
{

The <color=#00FF00>Transpose</color> node outputs a transposed version of the input matrix.


}


FrooxEngine.LogiX.Operators.UnpackColumns_Float2x2:##################################################################################################################################

{

The <color=#00FF00>Unpack Columns</color> node unpacks a matrix into a set of columns.

}

FrooxEngine.LogiX.Operators.UnpackRows_Float2x2:##################################################################################################################################

{

The <color=#00FF00>Unpack Rows</color> node unpacks a matrix into a set of rows.


}


FrooxEngine.LogiX.Operators.Deconstruct_Float2:##################################################################################################################################

{

<color=#00FF00>Unpack xy</color>

Splits a vector with 2 components into its constituent parts. 

}

FrooxEngine.LogiX.Operators.Deconstruct_Float3:##################################################################################################################################

{

<color=#00FF00>Unpack xyz</color>

Splits a vector with 3 components into its constituent parts. 


}

FrooxEngine.LogiX.Operators.Deconstruct_Float4:##################################################################################################################################
{

<color=#00FF00>Unpack xyzw</color>

Splits a vector with 4 components into its constituent parts. 

(NOTE a Method of obtaining the values of a Quaternion aka the true rotation data from an objects interface panel)

}



FrooxEngine.LogiX.Operators.Square_Float:##################################################################################################################################

{

<color=#00FF00>X</color>

Squares an input value. Mathematically speaking, this is the same as multiplying the input by itself. 


}

FrooxEngine.LogiX.Operators.Cube_Float:##################################################################################################################################
{

The <color=#00FF00>X</color> outputs the value of input X cubed.
Usage

When spawned from the node browser, this node accepts float data by default. However, this node can be overloaded to accept some numeric value 
types if an appropriate wire is connected the input. X is equal to X times X times X. 

}


FrooxEngine.LogiX.Operators.XNOR_Int:##################################################################################################################################
{

The <color=#00FF00>XNOR</color> node performs the logical exclusive NOR (XNOR) operation on inputs A and B.


}





FrooxEngine.LogiX.Physics.ApplyCharacterForce:#############################################################
{
The <color=#00FF00>Apply Character Force</color> node changes the linear velocity of the input Character CharacterController (Component) proportional to the input Force when an impulse is received at Apply.
Usage

The IgnoreMass input determines whether the Mass field on any associated collider (must be on the same Slot as the Character and must have Type CharacterController) is taken into account when calculating the resulting velocity. If False, the MassScaling Enum value on the Character will also be taken into account and the effective mass value scaled by the Character Slot's global scale. Default is False.


The OnDone output fires an impulse when the velocity of the input CharacterController has been changed as a result of an impulse received at Apply. No impulse will be fired if there is no valid CharacterController input.


If IgnoreMass is False, the change in velocity of the CharacterController is the input Force multiplied by the local user's frame update time divided by the CharacterCollider's effective mass. If IgnoreMass is True, the change in velocity of the CharacterController is the input Force multiplied by the local user's frame update time.

Note that for the input CharacterController to be affected, the impulse received at Apply must be owned by the SimulatingUser set in the referenced CharacterController component. For an explanation, see Frooxius' comment on GitHub
}



FrooxEngine.LogiX.Physics.ApplyCharacterImpulse:###########################################################
{
The <color=#00FF00>Apply Character Impulse</color> node changes the linear velocity of the input Character CharacterController (Component) proportional to the value of the input Impulse when an impulse is received at Apply.
Usage

The IgnoreMass input determines whether the Mass field on any associated collider (must be on the same Slot as the Character and must have Type CharacterController) is taken into account when calculating the resulting velocity. If true, the MassScaling Enum value on the Character will also be taken into account and the effective mass value scaled by the Character Slot's global scale. Default is False.


The OnDone output fires an impulse when the velocity of the input CharacterController has been changed as a result of an impulse received at Apply. No impulse will be fired if there is no valid CharacterController input.


If IgnoreMass is False, the change in velocity of the Character is the input Impulse divided by the CharacterCollider's effective mass. If IgnoreMass is True, the change in velocity of the Character is the input Impulse.

Note that for the input CharacterController to be affected, the impulse received at Apply must be owned by the SimulatingUser set in the referenced CharacterController component. For an explanation, see Frooxius' comment on GitHub 
}



FrooxEngine.LogiX.Physics.AsCharacterController:###########################################################
{
The <color=#00FF00>As Character Controller</color> node attempts to output the CharacterController (Component) associated with the input Collider.
Usage

Output is null unless the input is a valid character collider. 
}


FrooxEngine.LogiX.Physics.CharacterControllerUser:#########################################################
{
The <color=#00FF00>Character Controller User</color> node attempts to output the user referenced in the SimulatingUser field of the input CharacterController.
Usage

Output is null unless a valid user reference is available. 
}


FrooxEngine.LogiX.Physics.CharacterGravity:################################################################
{
The <color=#00FF00>Character Gravity</color> node outputs the Gravity vector for the input Character CharacterController (Component).
Usage

The Gravity output provides the current Gravity value.


The ActualGravity output provides the Gravity value from the previous update.


Default values are [0;0;0] for both outputs if there is no valid input CharacterController. 
}




FrooxEngine.LogiX.Physics.CharacterGroundCollider:#########################################################
{
The <color=#00FF00>Character Ground Collider</color> node outputs a reference to the collider the user of the input Character CharacterController (Component) is standing on.
Usage

Output is null if there is no valid input or the relevant user is not standing on a surface. 
}



FrooxEngine.LogiX.Physics.CharacterLinearVelocity:#########################################################
{
The <color=#00FF00>Character Linear Velocity</color> node outputs the linear velocity of the input Character CharacterController (Component) in global coordinate space. 
}


##########################################################################################################
FrooxEngine.LogiX.Physics.FindCharacterControllerFromSlot
FrooxEngine.LogiX.Physics.FindCharacterControllerFromUser
{
The <color=#00FF00>Find Character Controller</color> node attempts to find and output a CharacterController (Component) from either the input user or slot.
Usage

This node has two versions which work slightly differently but to the same effect:

    The User variant of this node outputs the CharacterController associated with the input user's currently selected locomotion module.
    The Slot variant of this node attempts to output the closest CharacterController component from the input slot or its parent slots.
        Failing this, it attempts to output the CharacterController associated with its active user's currently selected locomotion module.

If the User in question here is using a Locomotion Module that lacks a CharacterController such as NoClip this node will output null.

The Default output is null. 
}



FrooxEngine.LogiX.Physics.HitUVCoordinate:################################################################
{
The <color=#00FF00>Hit UV Coordinate</color> node outputs the UV coordinate corresponding to the input HitPoint on the HitTriangleIndex for the input HitCollider mesh collider.
Usage

The HitCollider must be a MeshCollider (Component) otherwise only default output values are used.


The UV output provides the calculated UV coordinates, [0;0] by default.


The IsValidUV outputs true if valid HitCollider and HitTriangleIndex values are provided, otherwise false.


This node is primarily to be used in conjuction with Raycast One (LogiX node) or Raycaster (LogiX node). 
}



FrooxEngine.LogiX.Physics.IsCharacterController:##########################################################
{
The <color=#00FF00>Is Character Controller</color> node outputs true if the input Collider is a CharacterController (Component), otherwise false. 
}



FrooxEngine.LogiX.Physics.IsCharacterOnGround:############################################################
{
The <color=#00FF00>Is Character On Ground</color> node ouputs true if the input Character CharacterController (Component) is standing on a collider, otherwise false. 
}


FrooxEngine.LogiX.Physics.OnCollisionEnd:#################################################################
{
The <color=#00FF00>On Collision End</color> node fires an impulse from OnEvent when the Other collider stops colliding with the input Collider.
Usage

The Other output provides the collider which stopped colliding with the input Collider. This value is available for the duration of the impulse chain started from OnEvent.


Note that, in general, collisions where neither collider is a CharacterController (Component) will generate an impulse from OnEvent for each user in a session. This usually requires filtering the impulses such that only the ones for relevant users propagate to downstream nodes. For collisions where the Other collider is a CharacterController an impulse will only be fired for the CharacterCollider's SimulatingUser. 
}



FrooxEngine.LogiX.Physics.OnCollisionStart:###############################################################
{
The <color=#00FF00>On Collision Start</color> node fires an impulse from OnEvent when the Other collider starts colliding with the input Collider.
Usage

The Other output provides the collider which started colliding with the input Collider. This value is available for the duration of the impulse chain started from OnEvent.


Note that, in general, collisions where neither collider is a CharacterController (Component) will generate an impulse from OnEvent for each user in a session. This usually requires filtering the impulses such that only the ones for relevant users propagate to downstream nodes. For collisions where the Other collider is a CharacterController an impulse will only be fired for the CharacterCollider's SimulatingUser. 
}




FrooxEngine.LogiX.Physics.OnCollisionStay:################################################################
{
The <color=#00FF00>On Collision Stay</color> node fires an impulse from OnEvent every frame while the Other collider is colliding with the input Collider.
Usage

The Other output provides the collider which is colliding with the input Collider. This value is available for the duration of the impulse chain started from OnEvent.


The OnEvent impulses from On Collision Stay start the frame after an impulse would be fired by On Collision Start (LogiX node), i.e. the frame after the Collider and Other start collding.

Note that, in general, collisions where neither collider is a CharacterController (Component) will generate an impulse from OnEvent for each user in a session. This usually requires filtering the impulses such that only the ones for relevant users propagate to downstream nodes. For collisions where the Other collider is a CharacterController an impulse will only be fired for the CharacterCollider's SimulatingUser.
}


FrooxEngine.LogiX.Physics.RaycastOne:#####################################################################
{
The <color=#00FF00>Raycast One</color> node performs a raycast when an impulse is received at Raycast. Properties of the raycast are controlled by the various inputs and information about the first collider hit are provided by the node outputs. 

Usage
Inputs

The Origin defines the point from which the ray is cast. This value is treated as being relative to the local coordinate space of the input Root slot. Default is [0;0;0].


The Direction defines the direction vector along which the ray is cast. This value is treated as being relative to the local coordinate space of the input Root slot. This input requires a value to be set as the default is [0;0;0].


The MaxDistance controls the maximum length of the raycast. The actual length of the raycast is affected by both this input and the global scale of the input Root slot. Default value is very large (~3.41038), so setting this is recommended.


The HitTriggers determines whether collider components with the collider Type field set as Trigger or HapticTrigger are considered valid hit targets. Default is false.


The UsersOnly determines whether colliders which do not have an active user are considered valid hit targets. Defaults to false, in which case all colliders are considered valid hit targets (depending on other factors). However, if set to true, only colliders with an active user (i.e. are parented under a user's slot hierarchy) are considered valid hit targets.


The DebugDuration input determines how long the raycast debug visual persists. This value is in seconds however if set to 0 (the default) the visual will persist for 1 frame. If set to a negative value no debug visual is drawn.


The Root input defines the slot relative to whose local coordinate space the Origin, Direction, and MaxDistance are calcluated.
Outputs

The OnHit output fires an impulse if a valid target collider is hit when a ray is cast.


The OnMiss output fires an impulse if no valid targets are hit when a ray is cast.


The HitCollider output provides the first valid target collider hit along the path of the raycast. This value is only available for the duration of the impulse chain started from OnHit. Default is null.


The HitDistance output provides the global distance between the raycast origin and the HitPoint. This value is only available for the duration of the impulse chain started from OnHit. Default is 0.


The HitPoint output provides the global coordinates of the point where raycast first intersects with the HitCollider. This value is only available for the duration of the impulse chain started from OnHit. Default is [0;0;0].


The HitNormal output provides the normal vector for the intersection of the raycast and the HitCollider.


The HitTriangleIndex outputs the index of the mesh triangle which was hit in the case that the HitCollider is a MeshCollider (Component).
Notes

Colliders will generally be valid hit targets for raycasts unless their Type enum field is set to Trigger, HapticTrigger, or HapticSampler, though see details for the HitTriggers input. Colliders will not be valid targets if the IgnoreRaycasts bool is set to false on the collider component.
Examples

    Neos VR: BasicTooltip with RayCastOne by ProbablePrime

}



FrooxEngine.LogiX.Physics.Raycaster:######################################################################
{
The <color=#00FF00>Raycaster</color> node generates a raycast with the input properties which is updated every frame update. Details about the current hit target collider (if there is one) are available from the outputs. 

Usage
Inputs

The Origin defines the point from which the ray is cast. This value is treated as being relative to the local coordinate space of the input Root slot. Default is [0;0;0].


The Direction defines the direction vector along which the ray is cast. This value is treated as being relative to the local coordinate space of the input Root slot. This input requires an value to be set as the default is [0;0;0].


The MaxDistance controls the maximum length of the raycast. The actual length of the raycast is affected by both this input and the global scale of the input Root slot. Default value is very large (~3.41038), so setting this is recommended.


The HitTriggers determines whether collider components with the collider Type field set as Trigger or HapticTrigger are considered valid hit targets. Default is false.


The UsersOnly determines whether colliders which do not have an active user are considered valid hit targets. Defaults to false, in which case all colliders are considered valid hit targets (depending on other factors). However, if set to true, only colliders with an active user (i.e. are parented under a user's slot hierarchy) are considered valid hit targets.


The Root input defines the slot relative to whose local coordinate space the Origin, Direction, and MaxDistance are calcluated.
Outputs

The HasHit input outputs whether the raycast has a valid hit target currently.


The HitCollider output provides the first valid target collider hit along the path of the raycast. Default is null.


The HitDistance output provides the global distance between the raycast origin and the HitPoint. Default is 0.


The HitPoint output provides the global coordinates of the point where raycast first intersects with the HitCollider. Default is [0;0;0].


The HitNormal output provides the normal vector for the intersection of the raycast and the HitCollider.


The HitTriangleIndex outputs the index of the mesh triangle which was hit in the case that the HitCollider is a MeshCollider (Component).
Notes

Colliders will generally be valid hit targets for raycasts unless their Type enum field is set to Trigger, HapticTrigger, or HapticSampler, though see details for the HitTriggers input. Colliders will not be valid targets if the IgnoreRaycasts bool is set to true on the collider component. 

}



FrooxEngine.LogiX.Physics.SetCharacterGravity:############################################################
{
The <color=#00FF00>Set Character Gravity</color> node overwrites the Gravity field value on the input Character CharacterController (Component) with the input Gravity vector.
Usage

The Gravity input defaults to [0;0;0] which corresponds to no gravity.


The OnDone output fires an impulse when the Gravity field value of the input Character has been set as a result of an impulse received at Apply. No impulse will be fired if there is no valid Character input.


Note that for the input CharacterController to be affected, the impulse received at Apply must be owned by the SimulatingUser set in the referenced CharacterController component.

}



FrooxEngine.LogiX.Physics.SetCharacterVelocity:###########################################################
{
The <color=#00FF00>Set Character Velocity</color> node overwrites the linear velocity of the input Character CharacterController (Component) with the input Velocity when an impulse is received at Apply.
Usage

The Velocity default is [0;0;0].


The OnDone output fires an impulse when the linear velocity of the input Character has been set as a result of an impulse received at Apply. No impulse will be fired if there is no valid Character input.


Note that for the input CharacterController to be affected, the impulse received at Apply must be owned by the SimulatingUser set in the referenced CharacterController component. For an explanation, see Frooxius' comment on GitHub 
}
















FrooxEngine.LogiX.Playback.PlaybackReadState:##########################################################
{
The <color=#00FF00>Playback state</color> node outputs several pieces of information about the current playback state 
of the Source clip.

Usage

The IsPlaying output is True if the Source is being played, otherwise False. Equivalent to Is Playing (LogiX node).


The Loop output is True if the Source is set to be looped when playback finishes, otherwise False. Equivalent to Is Looped (LogiX node).


The Position output provides the playback position (or progress) of the Source in seconds with microsecond precision. Equivalent to Position (LogiX node).


The NormalizedPosition output provides the playback length of the Source in seconds with microsecond precision. Equivalent to Clip Length (LogiX node).


The Speed output provides the playback speed of the Source. Equivalent to Speed (LogiX node).


Components which can be referenced as an IPlayable include Animator, AudioClipPlayer, and VideoTextureProvider. 
}




FrooxEngine.LogiX.Playback.PlaybackPlay:###############################################################
{
The <color=#00FF00>Play</color> node (re)starts playback of the Target from the beginning when an impulse is received at Play.

Usage

The OnDone output fires an impulse after an impulse is received at Play and the playback of the Target (re)starts. 
Note that this output will not fire if there is no valid Target referenced.


Components which can be referenced as an IPlayable include Animator, AudioClipPlayer, and VideoTextureProvider. 
}
FrooxEngine.LogiX.Playback.PlaybackWait:##############################################################
{
The <color=#00FF00>Wait</color> node waits for playback of the Target to finish after an impulse is received at Wait. 
When playback finishes an impulse is fired from OnFinishedWaiting

Usage

The OnWaitBegin output fires an impulse after an impulse is received at Wait. Note that this output will not fire if there is no valid Target referenced.


The OnFinishedWaiting output fires an impulse when playback of the Target stops after an impulse is received at Wait. Both pauses and full playback stops 
will cause this output to fire. If the Target is looped, this output will not fire an impulse if playback reaches the end and loops back from the start, 
however an impulse will still be fired when playback eventually finishes. The playback speed of the Target becoming 0 does not cause this output to fire.


Components which can be referenced as an IPlayable include Animator, AudioClipPlayer, and VideoTextureProvider. 
}
FrooxEngine.LogiX.Playback.PlaybackPlayAndWait:##################################################
{
The <color=#00FF00>Play & Wait</color> node (re)starts playback of the Target from the beginning for all users when an impulse is received at Play. 
This is similar to Play (LogiX node), however the impulse outputs are different.

Usage

The OnStarted output fires an impulse after an impulse is received at Play and the playback of the Target (re)starts. Note that this output will 
not fire if there is no valid Target referenced.


The OnFinishedPlaying output fires an impulse for all users when playback of the Target stops after it was (re)started by this node. Both pauses and 
full playback stops will cause this output to fire. If the Target is looped, this output will not fire an impulse if playback reaches the end and 
loops back from the start, however an impulse will still be fired when playback eventually finishes. The playback speed of the Target becoming 0 
does not cause this output to fire. Note that this output will not fire if playback of the Target is started by another node unless playback was 
initially started by Play & Wait and playback was merely restarted by another source before finally finishing.


Components which can be referenced as an IPlayable include Animator, AudioClipPlayer, and VideoTextureProvider. 
}
FrooxEngine.LogiX.Playback.PlaybackPause:#######################################################
{
The <color=#00FF00>Pause</color> node pauses playback of the Target when an impulse is received at Pause.

Usage

The OnDone output fires an impulse after an impulse is received at Pause and the Target has been paused. An impulse is fired regardless of whether 
the Target was playing when the incoming impulse was received. Note that this output will not fire if there is no valid Target referenced.

When playback of a Target is paused, the playback position is maintained. Playback can be restarted from the pause point with Resume (LogiX node), 
though consider also Pause/Resume (LogiX node).

Components which can be referenced as an IPlayable include Animator, AudioClipPlayer, and VideoTextureProvider. 
}
FrooxEngine.LogiX.Playback.PlaybackStop:#######################################################
{
The <color=#00FF00>Stop</color> node stops playback of the Target and sets the playback position to 0.

Usage

The OnDone output fires an impulse after an impulse is received at Stop and the playback of the Target stops. An impulse will be fire whether or 
not the Target was actually playing. Note that this output will not fire if there is no valid Target referenced.


Components which can be referenced as an IPlayable include Animator, AudioClipPlayer, and VideoTextureProvider. 
}
FrooxEngine.LogiX.Playback.PlaybackResume:#####################################################
{
The <color=#00FF00>Resume</color> node starts playback of the Target from the current playback position when an impulse is received at Resume.

Usage

The OnDone output fires an impulse after an impulse is received at Pause and playback of the Target has resumed. An impulse is fired regardless 
of whether the Target was playing when the incoming impulse was received. Note that this output will not fire if there is no valid Target referenced.


Components which can be referenced as an IPlayable include Animator, AudioClipPlayer, and VideoTextureProvider. 
}
FrooxEngine.LogiX.Playback.PlaybackPauseResume:########################################################
{
The <color=#00FF00>Pause/Resume</color> node toggles the playback state of the Target when an impulse is received at Pause/Resume.

Usage

The OnDone output fires an impulse after an impulse is received at Pause and the playback state of the Target has been changed. Note that this output 
will not fire if there is no valid Target referenced.

Impulses recieved at Pause/Resume will always change the Target playback state regardless of how it reached that state. e.g. The Target is playing and 
is paused by a Pause/Resume. Playback is then resumed by a Resume (LogiX node). Further impulses at PauseResume will again pause playback despite the 
fact that playback was previously resumed by a difference source.

Components which can be referenced as an IPlayable include Animator, AudioClipPlayer, and VideoTextureProvider. 
}
FrooxEngine.LogiX.Playback.PlaybackPropertiesNode // abstract
FrooxEngine.LogiX.Playback.PlaybackPropertiesOperatorNode`1[T] // abstract

FrooxEngine.LogiX.Playback.PlaybackIsPlaying:#############################################################
{
The <color=#00FF00>Is Playing</color> node outputs True if the Source clip is being played, otherwise False.

Usage

Components which can be referenced as an IPlayable include Animator, AudioClipPlayer, and VideoTextureProvider. Note that the output will still be 
True if the Source is being played even if it is not visible / audible (e.g. the relevant slot or component is disabled or deactivated, playback 
speed is set to 0 etc).
}
FrooxEngine.LogiX.Playback.PlaybackIsLooped:#############################################################
{
The <color=#00FF00>Is Looped</color> node reports the looped status of the Source clip.

Usage

Components which can be referenced as an IPlayable include Animator, AudioClipPlayer, and VideoTextureProvider. The looped status of a clip determines 
whether playback ends if the end of the clip is reached or restarts at the beginning. The looped status of a clip may be modified using the Set Loop 
(LogiX node) or via the world Inspector. 
}
FrooxEngine.LogiX.Playback.PlaybackPosition:############################################################
{
The <color=#00FF00>Position</color> node outputs the playback position (progress) of the Source clip in seconds with microsecond precision.
Usage

Components which can be referenced as an IPlayable include Animator, AudioClipPlayer, and VideoTextureProvider. 
}
FrooxEngine.LogiX.Playback.PlaybackNormalizedPosition:#################################################
{
The <color=#00FF00>Normalized Position</color> node outputs the current playback position, or playback progress, of the Source scaled by the clip length.

Usage

Components which can be referenced as an IPlayable include Animator, AudioClipPlayer, and VideoTextureProvider. The output float is always in the 
range 0 - 1 inclusive. 
}
FrooxEngine.LogiX.Playback.PlaybackSpeed:##############################################################
{
The <color=#00FF00>Speed</color> node outputs the playback speed of the Source.

Usage

Note that this will not necessarily, or normally, be zero if the Source is not being played - playback speed is set independently of whether the clip is 
being played.

Components which can be referenced as an IPlayable include Animator, AudioClipPlayer, and VideoTextureProvider. 
}
FrooxEngine.LogiX.Playback.PlaybackClipLength:#########################################################
{
The <color=#00FF00>Clip Length</color> node outputs the length of the Source clip in seconds with microsecond precision.
Usage

Components which can be referenced as an IPlayable include Animator, AudioClipPlayer, and VideoTextureProvider. 
}
FrooxEngine.LogiX.Playback.PlaybackSetter // abstract
FrooxEngine.LogiX.Playback.PlaybackSetLoop:############################################################
{
The <color=#00FF00>Set Loop</color> node sets the looped status (whether playback stops or restarts when the end of the clip is reached) of the Target 
to the value of the Loop input.

Usage

The OnDone output fires an impulse after an impulse is received at Set and the looped status of the Target has been set. An impulse is fired 
regardless of whether the looped status of the Target was changed by this action. Note that this output will not fire if there is no valid 
Target referenced.


The looped status of a Target can be changed during playback without interrupting it. However, if playback has already looped at least once, 
using Set Loop with input Loop as False will stop playback and the playback position is set to the end of the clip.

Components which can be referenced as an IPlayable include Animator, AudioClipPlayer, and VideoTextureProvider. 
}
FrooxEngine.LogiX.Playback.PlaybackSetPosition:########################################################
{
The <color=#00FF00>Set Position</color> node sets the playback position (in seconds) of the Target to the input Position.
Usage

The OnDone output fires an impulse after an impulse is received at Set and the playback position of the Target has been set. 
An impulse is fired regardless of whether the playback position of the Target was changed by this action. 
Note that this output will not fire if there is no valid Target referenced.


The playback position of a Target can be changed during playback without interrupting it and playback continues from the new position. 
However if the input Position is less than or equal to 0 playback restarts. Similarly, if Position is greater than or equal to the clip length, 
playback stops with the playback position set to the value of the clip length (or restarts if the looped status is True).

Components which can be referenced as an IPlayable include Animator, AudioClipPlayer, and VideoTextureProvider. 
}
FrooxEngine.LogiX.Playback.PlaybackSetNormalizedPosition:##############################################
{
The <color=#00FF00>Set Normalized Position</color> node sets the playback position of the Target such that the normalized playback position 
equals the NormalizedPosition input.

Usage

The OnDone output fires an impulse after an impulse is received at Set and the playback position of the Target has been set. 
An impulse is fired regardless of whether the playback position of the Target was changed by this action. 
Note that this output will not fire if there is no valid Target referenced.


The NormalizedPosition input is effectively clamped to the range 0 - 1 inclusive. This can be interpreted as a fractional position 
along the playback, i.e. if NormalizedPosition is 0.5 the playback position will be set exactly half-way along the clip.


The playback position of a Target can be changed during playback without interrupting it and playback continues from the new position. 
However if the input NormalizedPosition is less than or equal to 0 playback restarts. Similarly, if NormalizedPosition is greater than 
or equal to 1, playback stops with the playback position set to the value of the clip length.

Components which can be referenced as an IPlayable include Animator, AudioClipPlayer, and VideoTextureProvider.
}
FrooxEngine.LogiX.Playback.PlaybackSetSpeed:#########################################################
{
The <color=#00FF00>Set Speed</color> node sets the playback speed of the Target to the input Speed value.
Usage

The OnDone output fires an impulse after an impulse is received at Set and the playback speed of the Target has been set. 
An impulse is fired regardless of whether the playback speed of the Target was changed by this action. Note that this output 
will not fire if there is no valid Target referenced.


The Speed input defaults to 0 which appears to pause playback, however this is not recognised as a pause or stop event . 
A Speed value of 1 results in the standard clip playback speed. Values in the range 0 - 1 exclusive results in slowed playback. 
Values above 1 result in faster playback. Values below 0 result in reversed playback. Special float values NaN or Infinity behave the same as 0.


Components which can be referenced as an IPlayable include Animator, AudioClipPlayer, and VideoTextureProvider. 
}

FrooxEngine.LogiX.Playback.PlaybackShiftPosition:#####################################################
{
The <color=#00FF00>Shift Position</color> node changes playback position of the Target by a number of seconds equal the Delta input.
Usage

The OnDone output fires an impulse after an impulse is received at Set and the playback position of the Target has been set. 
An impulse is fired regardless of whether the playback position of the Target was changed by this action. 
Note that this output will not fire if there is no valid Target referenced.


The playback position of a Target can be changed during playback without interrupting it and playback continues from the new position. 
However playback restarts if the resulting position is less than or equal to 0. Similarly, playback stops if the resulting position 
would be greater than or equal the clip length. Position shifts for looped clips do not wrap around.

Components which can be referenced as an IPlayable include Animator, AudioClipPlayer, and VideoTextureProvider. 
}
FrooxEngine.LogiX.References.ReferenceTarget`1:#########################################################
{
The <color=#00FF00> -&gt; </color> node outputs the SyncRef reference target of the input Reference.
Usage

This node is often required when making a reference typed field from a slot or component interface available to LogiX nodes. For example when a Slot reference interface is extracted with the LogiX tooltip, the parent field must be input to this node before the Slot data it holds can be used by nodes which have a Slot type input. This is because the parent field is of type SyncRef<Slot>, rather than Slot itself. 
}


FrooxEngine.LogiX.References.AllocatingUser:############################################################
{
The <color=#00FF00>AllocatingUser</color> node outputs the User who caused the input Element to be loaded.

Usage

The default output is null. Any slot or component can be provided as inputs for this node. 
}


FrooxEngine.LogiX.References.ReferenceID:###############################################################
{
The <color=#00FF00>RefID</color> node outputs the raw RefID for the input Element.
Usage

In general it is not recommended for most users ever to use this node, see Things to Avoid.

The update notes regarding the implementation of this node were as follows (lightly edited for clarity):

    Please note that RefID is an opaque, non-persistent value (meaning its structure and meaning can change at any time, including between sessions). It's STRONGLY recommended not to work with them directly, but rather interact with typed references and nodes to extract desired data instead. If you rely on particular structure or meaning of RefID, your creations WILL break. If functionality is missing, make a request.
}

FrooxEngine.LogiX.Rendering.BakeReflectionProbe:########################################################
{
The <color=#00FF00>Bake Cubemap</color> node will (re-)bake the cubemap for the input Probe when an impulse is received at Bake.
Usage

The OnBakeStart output fires an impulse when the baking process initiates. This is the passthrough output for impulses received at Bake. Note that the baked cubemap asset Uri will not yet be available from BakedCubemapURL for the impulse chain initiated by OnBakeStart.


The OnBakeFail output fires an impulse if the baking process fails. Note that the baking process simply does not start (rather than failing) if there is no valid input Probe.


The OnBakeCompleted output fires an impulse when the baking process finishes. The baked cubemap asset Uri is available from BakedCubemapURL for the impulse chain initiated by OnBakeCompleted. 
}


FrooxEngine.LogiX.Rendering.BakeReflectionProbes:#######################################################
{
The <color=#00FF00>Bake Reflection Probes</color> node will (re-)bake the cubemaps for all ReflectionProbe components under the input Root slot's heirarchy when an impulse is received at Bake.
Usage

The Root input defines the slot hierarchy which will be searched for ReflectionProbe components to bake. Default is the world root slot.


The BakeInactive input determines whether disabled ReflectionProbe components, or ones present on inactive slots, will be baked. Default is false.


The FilterWithTag input determines can be used to only bake ReflectionProbes on slots with an exactly matching tag. This is empty by default which results in no tag-based filtering.


The DelayBeforeBake input determines the delay between baking successive ReflectionProbes in seconds. Default is 0.25 seconds.


The OnBakeBatchStart output fires an impulse when baking starts. No impulse will be fired if there is no valid (or empty) Root input, however it is not required that there be any valid ReflectionProbes to bake for an impulse to be fired.


The OnBakeBatchStart output fires an impulse immediately before the batch baking starts. No impulse will be fired if there is no valid (or empty) Root input, however it is not required that there be any valid ReflectionProbes to bake for an impulse to be fired.


The OnBeforeProbeBake output fires an impulse immediately before baking begins for each ReflectionProbe.


The OnProbeBaked output fires an impulse after each individual ReflectionProbe has been baked.


The OnBakeBatchFinished output fires an impulse after all valid ReflectionProbes have been baked.


The IsBaking output indicates whether a batch baking operation is in progress.


The CurrentProbe output provides the ReflectionProbe component which is currently being processed. This value is only available during the impulse chains started from OnBeforeProbeBake and OnProbeBaked.


The CurrentProbeIndex output provides the index of the ReflectionProble currently being processed. This value is 0 for the first probe baked in the batch, 1 for the next one and so on. The value from this output is 0 during the impulse chain started from OnBakeBatchStart and equal to the maximum index during the impulse chain started from OnBakeBatchFinished. The value will be correct for the specific ReflectionProbe processed during the impulse chains started from OnBeforeProbeBake and OnProbeBaked.


The CurrentProbeCount output provides the total number of ReflectionProbes which will be baked during the batch. This value is available during the impulse chains started from OnBeforeProbeBake, OnProbeBaked, and OnBakeBatchFinished.


Note that the node will not initate another baking batch if one is currently in progress.
}



FrooxEngine.LogiX.Rendering.RenderToTextureAsset:#######################################################
{
The <color=#00FF00>Render To Texture Asset</color> node will generate a texture using the provided camera when an impulse is received.
Usage

Upon receiving an impulse, the node will capture an image from the perspective of the provided camera, respecting the configuration of that camera. The output Uri can be written into the URL field of a StaticTexture2D component. This data is only available for the duration of the impulse chain fired from OnRendered.


The Format input refers to the file extension of the rendered image, by default this is 'webp'. Other commonly used formats include 'png', 'jpg', and 'tiff'.


The Resolution input refers to the width and height of the rendered image in pixels.


The Quality input currently only refers to the quality level of the webp format. This input ranges from 1 to 100, anything above 100 will result in a lossless image. 
}



FrooxEngine.LogiX.Rendering.SampleColor:################################################################
{
The <color=#00FF00>Sample Color</color> outputs the visible color sampled in a line along the input Direction vector from the input Origin when an impulse is received at Sample.
Usage

The color is sampled after applying all effects of lighting, shadows, emissives, alpha blending of materials etc. along the sampling direction.

The Reference input is the slot in whose local coordinate space the Origin and Direction vectors are interpreted. This is the root slot by default, meaning the global coordinate space is used.


The NearClip input sets a lower bound on the distance at which objects will be included in the sampling. Anything closer to the input Origin than the NearClip value will be ignored.


The FarClip input sets an upper bound on the distance at which objects will be included in the sampling. Anything further from the input Origin than the FarClip value will be ignored.


The OnSampleStart output fires an impulse when the sampling operation begins. This is the impulse passthrough output for the Sample input. Note that the Color output will not yet have the sampled color value!


The OnSampled output fires an impulse when the sampling operation completes. The sampled color will be available from the Color output for the duration of the impulse chain stared by OnSampled. Note that other transient values available during the impulse chain which arrives at Sample and continues from OnSampleStart may not be available during the impulse chain initiated from OnSampled.

}

FrooxEngine.LogiX.WorldModel.ChildrenCount:################################################################
{
The <color=#00FF00>Children Count</color> node outputs the number of slots which are direct children of the input Instance slot.
Usage

Slot indexing in Neos starts at 0. Child order can be specified by changing the OrderOffset field each slot in the inspector panel or using the Set Slot Order Offset node.
Examples

This node is extremely useful for iterating over all child slots of a parent without requiring foreknowledge of how many child slots there will be. Simply connect the output of this node to the Count input of a For node. An operation can then be run for each child slot by using a Get Child and providing the For node's Iteration output to the Get Child ChildIndex.

}


FrooxEngine.LogiX.WorldModel.DestroySlot:##################################################################
{
The <color=#00FF00>Destroy Slot</color> node deletes the Instance input slot (and all child slots) when an impulse is received at DoDestroy.
Usage

The PreserveAssets input determines whether any assets (audio, meshes, images etc.) saved under the Instance or child slots will be kept when the deletion occurs. If True, any assets in use by other parts of the world hierarchy will be moved to a child slot under the world's Assets slot. False by default.


The SendDestroyingEvent determines whether any On Destroying nodes under the Instance slot's hierarchy will be triggered before slots are deleted. True by default.


The OnDone output fires an impulse when the Instance slot has been successfully destroyed after an impulse was received at DoDestroy. No impulse is fired if there is no valid Instance input.
Examples

This node can be used to respawn users if their user root slot is destroyed. 
}


FrooxEngine.LogiX.WorldModel.DestroySlotChildren:##########################################################
{
The <color=#00FF00>Destroy Slot Children</color> node deletes all child slots of the Instance input slot when an impulse is received at DoDestroy.
Usage

The PreserveAssets input determines whether any assets (audio, meshes, images etc.) saved under the destroyed slots will be kept when the deletion occurs. If True, any assets in use by other parts of the world hierarchy will be moved to a child slot under the world's Assets slot. False by default.


The OnDone output fires an impulse when the Instance slot's children have been successfully destroyed after an impulse was received at DoDestroy. No impulse is be fired if there is no valid Instance input, however an impulse is still fired if a valid Instance slot has no children.

}


FrooxEngine.LogiX.WorldModel.DuplicateSlot:################################################################
{
The <color=#00FF00>Duplicate Slot</color> node creates a copy of the Template input slot when an impulse is received at DoDuplicate.

As usual, precautions related to the duplication and reparenting of dynamic variables apply, as described on the Dynamic Variables page.
Usage

The OnDuplicated output fires an impulse when the Template slot has been successfully duplicated. No impulse is fired if there is no valid Template.


The Duplicate output provides the newly created slot. This data is only available for the duration of the impulse chain started from OnDuplicated.


The Duplicate slot shares the same parent slot as the Template.
Examples

This node is commonly used when one wants to spawn an item when an event occurs. Place a template object under an inactive parent slot and duplicate the template. Often one needs to reparent the duplicate immediately using a Set Parent (LogiX node). If the Template slot is itself set as active, but it is inactive due to a parent slot being inactive, the duplicate will be active after reparenting under another active slot. 
}




FrooxEngine.LogiX.WorldModel.FindChildByName:##############################################################
{
The <color=#00FF00>Find Child By Name</color> node attempts to find a slot which is a child of the Instance input slot which has a name matching the input Name.
Usage

The default for Instance is null, which will not match anything.

The default for Name is null, which will not match anything.

The MatchSubstring input determines whether slots whose names contain the input Name will be considered valid matches. True by default.


The SearchDepth input determines how many levels of the slot hierarchy the node will search for child slots. A depth of 0 searches only the Instance slot's direct children. A positive depth searches only that many levels of children below the direct children. A negative depth searches through all children without limit. 0 by default.


The IgnoreCase input determines whether slot names which do not exactly match the upper/lower case of the Name input will be considered valid. True by default.


The FoundChild output is the first slot found whose name matches the input Name. Output is null if no valid match is found.


The search proceeds first from the Instance input slot's direct children (in increasing index order), then to the next level or children if allowed by the SearchDepth input, and so on. A SearchDepth of 0 (default) searches only the Instance input slot's direct children, a depth of 1 allows searching of the Instance slot's children's children etc. A SearchDepth value of -1 allows searching to unlimited depth.

Note: finding slots using this node is more demanding than simply getting a child slot via its index using Get Child (LogiX node), so consider whether it is absolutely required. 
}



FrooxEngine.LogiX.WorldModel.FindChildByTag:###############################################################
{

The <color=#00FF00>Find Child By Tag</color> node attempts to find a child slot of the Instance input slot with a tag matching the input Tag.
Usage

The SearchDepth input determines how many levels of the slot hierarchy the node will search for child slots. 0 by default (i.e. searches only the Instance slot's direct children).


The FoundChild is the first slot found whose tag exactly matches the input Tag. Output is null if no valid match is found.


The search proceeds from the Instance input slot's direct children (in increasing index order) to deeper levels if allowed by the SearchDepth input. A SearchDepth of 0 (default) searches only the Instance input slot's direct children, a depth of 1 allows searching of the Instance slot's children's children etc. A SearchDepth value of -1 allows searching to unlimited depth.

Note: finding slots using this node is more demanding than simply getting a child slot via its index using Get Child (LogiX node), so consider whether it is absolutely required.

}



FrooxEngine.LogiX.WorldModel.FindParentByName:############################################################
{
The <color=#00FF00>Find Parent By Name</color> node attempts to find a slot which is a parent of the Instance input slot which has a name matching the input Name.
Usage

The MatchSubstring input determines whether slots whose names contain the input Name will be considered valid matches. True by default.


The SearchDepth input determines how many levels of the slot hierarchy the node will search for parent slots. 0 by default (i.e. searches only the Instance slot's direct parent).


The IgnoreCase input determines whether slot names which do not exactly match the upper/lower case of the Name input will be considered valid. True by default.


The FoundParent output is the first slot found whose name matches the input Name. Output is null if no valid match is found.


The search proceeds from the Instance input slot's direct parent to higher levels if allowed by the SearchDepth input. A SearchDepth of 0 (default) searches only the Instance input slot's direct parent, a depth of 1 allows searching of the Instance slot's parent's parent etc. A SearchDepth value of -1 allows searching to unlimited depth. 
}



FrooxEngine.LogiX.WorldModel.FindParentByTag:#############################################################
{
The <color=#00FF00>Find Parent By Tag</color> node attempts to find a parent slot of the Instance input slot with a tag matching the input Tag.
Usage

The FoundParent is the first slot found whose tag exactly matches the input Tag. Output is null if no valid match is found.


The search proceeds from the Instance input slot's direct parent to higher levels if allowed by the SearchDepth input. A SearchDepth of 0 (default) searches only the Instance input slot's direct parent, a depth of 1 allows searching of the Instance slot's parent's parent etc. A SearchDepth value of -1 allows searching to unlimited depth. 
}


FrooxEngine.LogiX.WorldModel.GetActiveUser:###############################################################
{
The <color=#00FF00>Get Active User</color> node outputs the user whose root slot is a parent of the Instance input slot.

Usage

The default output value is null if no active user is present. This node only finds the closest active user to the Instance slot, i.e. if the Instance slot is parented under user A, but user A is parented under user B, the node will output user A.

This node is generally useful for detecting which user is e.g. equipping an avatar or grabbing an item since these result in the relevant object being parented under a user's slot hierarchy. 
}



FrooxEngine.LogiX.WorldModel.GetActiveUserRoot:###########################################################
{
The <color=#00FF00>Get Active User Root</color> node node outputs the UserRoot for the user whose root slot is a parent of the Instance input slot.
Usage

The default output value is null if no active user is present. This node only finds the closest active UserRoot to the Instance slot, i.e. if the Instance slot is parented under user A, but user A is parented under user B, the node will output user A's UserRoot.

For nodes which work with the UserRoot datatype see User Root category nodes.

}


FrooxEngine.LogiX.WorldModel.GetActiveUserSelf:###########################################################
{
The <color=#00FF00>Get Active User Self</color> node 
}



FrooxEngine.LogiX.WorldModel.GetChild:####################################################################
{
The <color=#00FF00>Get Child</color> node outputs the child slot under the input Instance slot with the input ChildIndex.
Usage

The default ChildIndex is 0, and the default Instance is null.

Slot indexing starts from 0. The output will be null if no child is found with the specified index, or if Instance is null.
Examples

This node can be used with Children Count and For to iterate over and perform some function for each child of the Instance slot. 
}


FrooxEngine.LogiX.WorldModel.GetObjectRoot:###############################################################
{
The <color=#00FF00>Get Object Root</color> node attempts to find a parent of the input Instance slot which has an ObjectRoot component.
Usage

The upward hierarchy search starts with the input Instance slot, i.e. if the input slot has an ObjectRoot component then the output will be the same as the input. The search stops when it finds the closest ObjectRoot to the Instance slot in its parent hierarchy. If no ObjectRoot components are found, the output is the Instance slot. 
}

FrooxEngine.LogiX.WorldModel.GetParentSlot:###############################################################
{
The <color=#00FF00>Get Parent Slot</color> node outputs the direct parent slot of the Instance input slot.
Usage

Note, attempting to get the parent of the world root slot will result in null output. 
}


FrooxEngine.LogiX.WorldModel.GetSlot:#####################################################################
{
The <color=#00FF00>Get Slot</color> node outputs the slot which holds the input Component. 
}


FrooxEngine.LogiX.WorldModel.GetSlotActive:###############################################################
{
The <color=#00FF00>Get Slot Active</color> node indicates whether the input Instance slot is active.
Usage

Slots are considered active if, and only if, they and all of their parent slots are active. If the Instance slot is inactive, or any of its parent slots are inactive, this node will output False. If it is only required to check a slot's own Active property, use the Get Slot Active Self node. 
}


FrooxEngine.LogiX.WorldModel.GetSlotActiveSelf:###########################################################
{
The <color=#00FF00>Get Slot Active Self</color> node reports the Active property of the input Instance slot.
Usage

This node only checks the Active property of the input Instance slot. As such, it will output True if the input Instance slot is set as active even if it is currently inactive due to a parent slot being set as inactive. If it is only required to check whether a slot is currently active in the world, use the Get Slot Active node. 
}

FrooxEngine.LogiX.WorldModel.GetSlotName:#################################################################
{
The <color=#00FF00>Get Slot Name</color> node outputs the name of the input Instance slot. 
}



FrooxEngine.LogiX.WorldModel.GetSlotOrderOffset:##########################################################
{
The <color=#00FF00>Get Slot Order Offset</color> node reports the OrderOffset value of the input Instance slot.
Usage

The OrderOffset property can be used to manually specify a slot's position in the list of slots under it's immediate parent slot. 
}


FrooxEngine.LogiX.WorldModel.GetSlotPersistent:###########################################################
{
The <color=#00FF00>Get Slot Persistent</color> node indicates whether the input Instance slot is persistent.
Usage

Slots are considered persistent if, and only if, they and all of their parent slots are persistent. If the Instance slot is non-persistent, or any of its parent slots are non-persistent, this node will output False. If it is only required to check a slot's own Persistent property, use the Get Slot Persistent Self node. 
}


FrooxEngine.LogiX.WorldModel.GetSlotPersistentSelf:#######################################################
{
The <color=#00FF00>Get Slot Persistent Self</color> node reports the Persistent property of the input Instance slot.
Usage

This node only checks the Persistent property of the input Instance slot. As such, it will output True if the input Instance slot is set as persistent even if it is currently non-persistent due to a parent slot being set as non-persistent. If it is only required to check whether a slot is currently persistent in the world, use the Get Slot Persistent node. 
}


FrooxEngine.LogiX.WorldModel.GetTag:######################################################################
{
The <color=#00FF00>Get Tag</color> node outputs the tag of the input Instance slot. 
}


FrooxEngine.LogiX.WorldModel.HasTag:######################################################################
{
The <color=#00FF00>Has Tag</color> node reports whether the input Instance slot's tag exactly matches the input Tag. 
}


FrooxEngine.LogiX.WorldModel.IndexOfChild:################################################################
{
The <color=#00FF00>Index Of Child</color> node outputs the index of the input Instance slot under its direct parent.
Usage

Default output is -1 if there is no valid input Instance slot. If the world root slot is provided as the input it will cause errors (node turns red) with any connected display nodes or displays from downstream calculations. 
}


FrooxEngine.LogiX.WorldModel.IsChildOf:###################################################################
{
The <color=#00FF00>Is Child Of</color> node reports whether the input Instance slot is a child under the input Other slot.
Usage

The IncludeSelf determines whether the output will be True if the Instance and Other inputs match. False by default (i.e. the Instance is not considered a child of itself).

The output will be True if the Instance input is a child anywhere (e.g. child of a child) under the Other input slot's hierarchy. 
}


FrooxEngine.LogiX.WorldModel.RootSlot:####################################################################
{
The <color=#00FF00>Root Slot</color> node outputs the world Root Slot.

In some worlds, users may be under the management of systems which parent a user to a slot which is other than the Root Slot. This is common with Spawn Areas which have the Parent User setting enabled or with World Management systems that create a new slot for each user. When such systems exist it is recommended that your systems respect them. This can be done by using Local User Space (LogiX node) instead. This can be useful for things like:

    Guns
    Rocket Launchers and other projectiles
    Gadgets and Tools which re-parent items

}


FrooxEngine.LogiX.WorldModel.SetChildIndex:###############################################################
{
The <color=#00FF00>Set Child Index</color> node sets the index of the input Instance slot under it's parent to the input Index when an impulse is received at Set.
Usage

The Index input value defaults to 0.


The OnSet output fires an impulse when the index of the Instance slot is successfully set. Impulses are not fired if there is no valid Instance input or the Index value is less than 0.


This node works by changing the OrderOffset values for the Instance slot and all others with indices less than or equal to the Index input value. Slot order will not change apart from moving the Instance input slot, however any previously set custom OrderOffset values for slots with indices less than or equal to the Index input value may be changed. OrderOffset values for slots with indices greater than the input Index will be unchanged.

For more precise control of slot OrderOffset values use Set Slot Order Offset 
}



FrooxEngine.LogiX.WorldModel.SetParent:###################################################################
{
The <color=#00FF00>Set Parent</color> node reparents the Instance input slot under the NewParent input slot.

As usual, precautions related to the duplication and reparenting of dynamic variables apply, as described on the Dynamic Variables page.
Usage

The NewParent input defaults to the world root slot.


The PreserveGlobalPosition input determines whether the Instance slot's global position will be kept constant during the reparenting event. If False, the Instance slot's local position is preserved instead. Defaults to True.


The OnDone output fires an impulse after any reparenting has been successfully performed. This happens regardless of whether the parent of the Instance slot was actually changed. No impulse is fired if there is no valid Instance input.


If the Instance has a non-zero OrderOffset value, this is maintained during reparenting. Otherwise the slot's index after reparenting is 1 greater than the highest index among children of the NewParent slot before reparenting, i.e. it is added at the bottom of the list in the slot inspector.

}


FrooxEngine.LogiX.WorldModel.SetSlotActiveSelf:###########################################################
{
The <color=#00FF00>Set Slot Active Self</color> node sets the Active property of the input Instance slot to the value of the Active input when an impulse is received at Set.
Usage

The OnDone output fires an impulse after an impulse is received at Set unless there is no valid Instance input. This occurs regardless of whether the Active property of the Instance slot was changed.


By default this node makes no change to the Active property of the Instance if the Active input value is unspecified. Note that setting the active property of a slot to True will not result in the slot actually becoming active if one of its parents is set as inactive.

}



FrooxEngine.LogiX.WorldModel.SetSlotName:#################################################################
{
The <color=#00FF00>Set Slot Name</color> node sets the name of the Instance input slot to the value of the Name input when an impulse is received at Set.
Usage

The Name input defaults to null.


The OnDone output fires an impulse after the name of the input Instance is successfully set. This occurs regardless of whether the Instance slot's name was changed as a result. No impulse is fired if there is no valid Instance input. 
}



FrooxEngine.LogiX.WorldModel.SetSlotOrderOffset:##########################################################
{
The <color=#00FF00>Set Slot Order Offset</color> node sets the OrderOffset value of the input Instance slot to the input OrderOffset value when an impulse is received at DoSetOrderOffset.
Usage

The OrderOffset input defaults to 0.


The OnDone output fires an impulse when the Instance slot's OrderOffset value has been successfully set. This occurs regardless of whether the Instance slot's OrderOffset value was actually changed. No impulse is fired if there is no valid Instance input.

}


FrooxEngine.LogiX.WorldModel.SetSlotPersistentSelf:#######################################################
{
The <color=#00FF00>Set Slot Persistent Self</color> node sets the Persistent property of the input Instance slot to the value of the Active input when an impulse is received at Set.
Usage

The OnDone output fires an impulse after the Instance input's Persistent property has been set. This occurs regardless of whether the Persistent property of the Instance slot was actually changed. No impulse is fired if there is no valid Instance input.


By default this node makes no change to the Persistent property of the Instance if the Active input value is unspecified. Note that setting the Persistent property of a slot to True will not result in the slot actually becoming persistent if one of its parents is set as non-persistent. 
}


FrooxEngine.LogiX.WorldModel.SetTag:######################################################################
{

The <color=#00FF00>Set Tag</color> node sets the tag of the Instance slot to the Tag input when an impulse is received at Set.
Usage

The Tag input defaults to null.


The OnSet output fires an impulse when the tag of the Instance slot has been successfully set. This occurs regardless of whether the Instance slot's tag was actually changed. No impulse is fired if there is no valid Instance input. 
}


FrooxEngine.LogiX.WorldModel.SlotChildrenEvents:##########################################################
{

The <color=#00FF00>Slot Children Events</color> node generates impulses when child slots are added or removed from the Instance slot.

Note that currently Slot Children Events does not support the value of the Instance slot changing. [1] 

Usage

The OnUser input can be used to specify which user will own the generated impulses. By default impulses are owned by the user who caused the change. Providing the Local User to this input will result in impulses being fired for all users in the session.


The OnChildAdded output fires impulses whenever a child slot is added under the Instance slot.


The OnChildRemoved output fires impulses whenever a child slot is removed from under the Instance slot.


The Child output provides the slot which was added / removed from under the Instance slot. This value is only available for the duration of the impulse chain started by OnChildAdded or OnChildRemoved. Note that the value will be null if a child slot is destroyed, rather than being reparented away from the Instance slot. 

}

FrooxEngine.LogiX.String.Capitalize:######################################################################
{
The <color=#00FF00>Capitalize</color> node outputs the input Str with the first character capitalized.
Usage

This node makes no change to the input Str unless the first character is lower-case and it has a valid upper-case variant. 
}

FrooxEngine.LogiX.String.Contains:#########################################################################
{
The <color=#00FF00>Contains</color> node outputs true if the input Str contains at least one exactly matching instance of the input Substring, otherwise false.
Usage

The output will be false if either (or both) of the inputs are empty strings or null. 
}



FrooxEngine.LogiX.String.EndsWith:#########################################################################
{
The <color=#00FF00>Ends With</color> node outputs true if the Str ends with a substring which exactly matches the input Substring, otherwise false.
Usage

The output will be false if either (or both) of the inputs are empty strings or null. 
}



FrooxEngine.LogiX.String.EscapeString:#####################################################################
{
The <color=#00FF00>Escape String</color> node escapes the provided text using the C# regex escape method.

Note: This implementation escapes whitespace. 
}


FrooxEngine.LogiX.String.FormatString:#####################################################################
{
The <color=#00FF00>Format</color> node generates the output Str by inserting the input parameters into specified points in the input Format string.
Usage

The node initially spawns with one parameter input. Use the + or - buttons on the node add or remove parameter inputs.

Parameter inputs are inserted into the Format string at positions specified by curly braces '{}'. For example, if the first parameter input Parameters.0 is a string with the value "World" and the Format string is "Hello {0}!", the output Str will be "Hello World!".

The output will be null if a pair of curly braces is present without a valid parameter value e.g. "{}" or "{1}" if there is only a Parameters.[0] input.

There are many additional options which can be used to control how parameter inputs are formatted. For these more advanced options, much of the C# documentation for the Format method is applicable. For example there are many options for formatting numeric data as detailed here. For standard time & date formatting, here For custom numeric formatting, here and custom date/time formatting, here.
}



FrooxEngine.LogiX.String.IndexOfString:####################################################################
{
The <color=#00FF00>Index Of String</color> node outputs the position index within the Str where a substring exactly matching the input Part is present.
Usage

The StartIndex defines the position within the input Str where searching for the Part begins. The default value is 0.


The SearchFromEnd input determines in which direction the search proceeds from the StartIndex. If false (the default) searching is left-to-right, otherwise it is right-to-left if true.


The default output is -1. This may occur in the event that the Str or Part is null or an empty string, or if the Part cannot be found given the current inputs.

Note that the StartIndex needs to be set to a larger value (generally the length of the Str - 1) since the reversed search still proceeds from this index! 
}


FrooxEngine.LogiX.String.IsStringEmpty:####################################################################
{
The <color=#00FF00>Is String Empty</color> node outputs true if the intput string A is either null or an empty string, otherwise false. 
}



FrooxEngine.LogiX.String.NewLine:##########################################################################
{
The <color=#00FF00>New Line</color> node outputs a newline correct for the current operating system environment.

}



FrooxEngine.LogiX.String.ReplaceFirstSubstring:############################################################
{
The <color=#00FF00>Replace First Substring</color> node outputs the input Str with the first instance of the SearchFor substring replaced with the ReplaceWith string.
Usage

The StartIndex determines which position in the input Str searching for the SearchFor substring should begin. Default is 0.


If no instance of the SearchFor substring is found after the input StartIndex, the output of this node is identical to the Str input.

If you need to replace every instance of a substring, use Replace Substring (LogiX node) instead. 
}


FrooxEngine.LogiX.String.ReplaceSubstring:#################################################################
{
The <color=#00FF00>Replace Substring</color> node outputs the input Str with every instance of the SearchFor substring replaced with the ReplaceWith string.
Usage

If no instance of the SearchFor substring is found, the output of this node is identical to the Str input. 
}


FrooxEngine.LogiX.String.ReverseString:####################################################################
{
The <color=#00FF00>Reverse String</color> node outputs the input A string with all character positions inverted.
}


FrooxEngine.LogiX.String.StartsWith:#######################################################################
{
The <color=#00FF00>Starts With</color> node outputs true if the Str starts with a substring which exactly matches the input Substring, otherwise false.
Usage

The output will be false if either (or both) of the inputs are empty strings or null. 
}



FrooxEngine.LogiX.String.StringInsert:#####################################################################
{
The <color=#00FF00>String Insert<color=#00FF00> node outputs the Str input with the Value string inserted at the StartIndex position.
Usage

If the StartIndex is out of the range of values possible for the input Str (i.e negative values or values greater than the length of Str - 1) the output is null. 
}



FrooxEngine.LogiX.String.StringJoin:#######################################################################
{
The <color=#00FF00>String Join</color> node outputs the input operand strings separated by the Separator input.

Usage

The default Separator is an empty string (i.e. no separation).


The node's default output is an empty string. 
}




FrooxEngine.LogiX.String.StringLength:#####################################################################
{
The <color=#00FF00>String Length</color> node outputs the number of characters in input string A. 
}



FrooxEngine.LogiX.String.StringRemove:#####################################################################
{
<color=#00FF00>String Remove</color>

Usage
Inputs

Str: The input string.

StartIndex: The zero-based starting character position of a substring in Str. Negative start indices are treated as if they were 0.

Length: The number of characters to remove in the string. If this input is not populated, the default is the length of Str. Negative lengths are treated as if they were 0.
Outputs

*: The input Str minus the Length that begins at StartIndex in Str. If StartIndex-Length exceeds the bounds of the input Str, the output of Str will be nulled. 

}



FrooxEngine.LogiX.String.Substring:########################################################################
{
<color=#00FF00>Substring</color>

Usage
Inputs

Str: The input string.

StartIndex: The zero-based starting character position of a substring in Str. Negative start indices are treated as if they were 0.

Length: The number of characters in the substring. If this input is not populated, the default is the length of Str. Negative lengths are treated as if they were 0.
Outputs

*: The substring of length Length that begins at StartIndex in Str. If StartIndex+Length exceeds the bounds of the input Str, the output is truncated to the end of Str. 
}



FrooxEngine.LogiX.String.TrimString:#######################################################################
{
The <color=#00FF00>Trim String</color> node outputs the input A string with any whitespace removed from the beginning and end of the input.
}


FrooxEngine.LogiX.String.UnescapeString:###################################################################
{
The <color=#00FF00>Unescape String</color> node replaces escaped characters in the input with their unescaped counterparts. This uses the C# regex unescape call.

Due to the permissiveness of the unescape method, this is valid for unescaping json string fields, and some forms of string literals in programing languages such as C, C#, and javascript.

Each language may have escape sequences (or may lack escape sequences) for this conversion to be safe, please check with your specific language specification. 
}







Math.Time.TimespanTicksNode
Math.Time.TimespanMillisecondsNode
Math.Time.TimespanSecondsNode
Math.Time.TimespanMinutesNode
Math.Time.TimespanHoursNode
Math.Time.TimespanDaysNode
Math.Time.TimespanTotalMillisecondsNode
Math.Time.TimespanTotalSecondsNode
Math.Time.TimespanTotalMinutesNode
Math.Time.TimespanTotalHoursNode
Math.Time.TimespanTotalDaysNode
{
Extracts a specific unit (such as days or seconds) from a TimeSpan.
}


Math.Time.TimeSpanFromDays
Math.Time.TimeSpanFromHours
Math.Time.TimeSpanFromMinutes
Math.Time.TimeSpanFromSeconds
Math.Time.TimeSpanFromMilliseconds
Math.Time.TimeSpanFromTicks
{
Converts a number (of seconds or days or whatever the node says) into a TimeSpan.
}

FrooxEngine.LogiX.Tools.DequipTooltip:#####################################################################
{

The <color=#00FF00>Dequip Tooltip</color> node dequips any equipped tooltip from the specified User's hand according to the Node enum input.


Usage

This dequips any tooltip, whether equipped by a simple grip or fully equipped (e.g. through the radial context menu Equip button), from the hand specified by the Node input ('Unknown' by default, which does nothing).

OnDequipped only fires and impulse if a tooltip is actually de-equipped as a result of an impulse at Dequip.

NOTE: The incoming impulse must originate from the user who you are requesting to de-equip the tooltip from. If another user fires the impulse it will not work.

}


FrooxEngine.LogiX.Tools.EquipTooltip:######################################################################
{
The <color=#00FF00>Equip Tooltip</color> node equips the input Tooltip on the input User's hand, specified by the Node input.

Usage

The Node input is 'Unknown' by default which does nothing. If DequipExisting is True (False by default) any equipped tooltip on the hand specified by Node will be deqipped before the input Tooltip is equipped. The OnEquipped output only fires an impulse if a tooltip is successfully equipped as a result of receiving an impulse at Equip.


}



FrooxEngine.LogiX.Tools.GetRawDataTooltipHit:##############################################################
{
Needs wiki page written
}


FrooxEngine.LogiX.Tools.GetTooltip:########################################################################
{
The <color=#00FF00>Get Tooltip</color> node outputs a reference to the tooltip equipped in the input User's hand (specified by Node).

Usage

The 'Unknown' Node input option does nothing and produces a null output.

}


FrooxEngine.LogiX.Tools.HasTooltip:########################################################################
{
The <color=#00FF00>Has Tooltip</color> node outputs a boolean value depending on whether the input User has a tooltip equipped in the hand specified by Node.

Usage

The 'Unknown' Node input option always results in a False output from HasEquippedTooltip.
}



FrooxEngine.LogiX.Tools.IsTooltipEquipped:#################################################################
{
The <color=#00FF00>Is Tooltip Equipped</color> node outputs a boolean value determined by whether the input tooltip is equipped by a user.
}



FrooxEngine.LogiX.Tools.IsTooltipInUse:####################################################################
{
The <color=#00FF00>Is Tooltip In Use</color> node reports the state of the InUse tooltip property.

Usage

The InUse tooltip property is True when the tooltip primary action is being used, though this is defined differently for different tooltips.
Examples

This node is intended to be used to block userspace interactions while the tooltip is currently doing something that shouldn't be interrupted (see GitHub issue #732). 

}


FrooxEngine.LogiX.Tools.RawDataTooltipEvents:##############################################################
{
The <color=#00FF00>Raw Data Tooltip Events</color> node fires impulses when various events (e.g. button presses) affecting the input RawDataTooltip occur.
Usage

The Equipped output fires an impulse whenever the referenced RawDataTooltip becomes equipped.

The Dequipped output fires an impulse whenever the referenced RawDataTooltip becomes dequipped.

The ToolUpdate output fires an impulse every frame while the referenced RawDataTooltip is equipped.

The PrimaryPressed output fires an impulse whenever the equipping user presses the primary fire button on the controller corresponding to the hand where the RawDataTooltip is equipped.

The PrimaryHeld output fires an impulse every frame while the equipping user holds the primary fire button pressed on the controller corresponding to the hand where the RawDataTooltip is equipped.

The PrimaryReleased output fires an impulse whenever the equipping user releases the primary fire button on the controller corresponding to the hand where the RawDataTooltip is equipped.

The SecondaryPressed output fires an impulse whenever the equipping user presses the secondary fire button on the controller corresponding to the hand where the RawDataTooltip is equipped.

The SecondaryHeld output fires an impulse every frame while the equipping user holds the secondary fire button pressed on the controller corresponding to the hand where the RawDataTooltip is equipped.

The SecondaryReleased output fires an impulse whenever the equipping user releases the secondary fire button on the controller corresponding to the hand where the RawDataTooltip is equipped.

This node is essential for making custom tooltips as LogiX can be made to run based on a user's interactions with the tool. Impulses fired from this node are owned by the user interacting with the RawDataTooltip. 
}




FrooxEngine.LogiX.Tools.TooltipEquippingSide:#############################################################
{
Needs wiki page
}


FrooxEngine.LogiX.Tools.TooltipEquippingSlot:#############################################################
{
The <color=#00FF00>Tooltip Equipping Slot</color> node outputs the slot of the CommonTool component for the input Tooltip.

}


FrooxEngine.LogiX.Tools.TooltipEvents:####################################################################
{
Needs Wiki Page
}


FrooxEngine.LogiX.Transactions.CurrencyConversion:#########################################################
{
The <color=#00FF00>CurrencyConversion</color> node converts the SourceAmount from the SourceCurrency to the TargetCurrency.
Usage

The TargetAmount output provides the converted currency value. The value is -1 if either the SourceCurrency or TargetCurrency inputs contain unrecognized strings.


The Converted output is True if both the input strings were recognized and conversion was performed successfully.


Currently SourceCurrency and TargetCurrency only accept the strings 'USD' and 'NCR'. If both are left as defaults, the node uses NCR as the SourceCurrency and USD as the TargetCurrency 
}


FrooxEngine.LogiX.Transactions.TokensEnabled:##############################################################
{
This is a LogiX node that produces a local bool output. It will locally output True if you are running the standalone build of Neos, which has token (NCR and KFC) functionality enabled. It will locally output False if you are running the Steam build of Neos, which has token functionality disabled. 
}



FrooxEngine.LogiX.WorldModel.GetBackward:##################################################################
{
The <color=#00FF00>Backward</color> node outputs the vector in global coordinate space which is parallel to the Instance slot's negative Z coordinate vector.
Usage

The output vector is normalized such that its magnitude is 1. 
}



FrooxEngine.LogiX.WorldModel.GetDown:######################################################################
{
The <color=#00FF00>Down/color> node outputs the vector in global coordinate space which is parallel to the Instance slot's negative Y coordinate vector.
Usage

The output vector is normalized such that its magnitude is 1. 
}



FrooxEngine.LogiX.WorldModel.GetForward:###################################################################
{
The <color=#00FF00>Forward</color> node outputs the vector in global coordinate space which is parallel to the Instance slot's positive Z coordinate vector.
Usage

The output vector is normalized such that its magnitude is 1.

}



FrooxEngine.LogiX.WorldModel.GlobalDirectionToLocal:#######################################################
{
The <color=#00FF00>Global Direction To Local</color> node takes the input GlobalDirection vector and outputs the equivalent LocalDirection vector relative to the Instance slot's local coordinate space.
Usage

Note that this node only takes into account the relative rotation between the global and local coordinate spaces when calculating the conversion, the scale of the Instance slot does not affect the output. If scale is important for a calculation use Global Vector To Local. 
}


FrooxEngine.LogiX.WorldModel.GlobalPointToLocal:###########################################################
{
The <color=#00FF00>Global Point To Local</color> node takes the input GlobalPoint position vector and outputs the equivalent LocalPoint position vector relative to the Instance slot's local coordinate space.
}



FrooxEngine.LogiX.WorldModel.GlobalRotationToLocal:########################################################
{
The <color=#00FF00>Global Rotation To Local</color> node takes an input GlobalRotation floatQ and outputs the equivalent LocalRotation floatQ rotation relative to the Instance slot's local coordinate space.
}



FrooxEngine.LogiX.WorldModel.GlobalScaleToLocal:###########################################################
{
The <color=#00FF00>Global Scale To Local</color> node takes the input GlobalScale vector and outputs the equivalent LocalScale vector relative to the Instance slot's local coordinate space. 
}


FrooxEngine.LogiX.WorldModel.GlobalTransform:###########################################################
{
The <color=#00FF00>Global Transform</color> node outputs the Instance slot's GlobalPosition, GlobalRotation, and GlobalScale.
Usage

Note that the values output by this node differ from those shown in the slot inspector panel because the inspector shows values in local coordinate space. Use Local Transform (LogiX node) to obtain values matching those displayed in the inspector. 
}


FrooxEngine.LogiX.WorldModel.GlobalVectorToLocal:##########################################################
{
The <color=#00FF00>Global Vector To Local</color> node takes the input GlobalVector vector and outputs the equivalent LocalVector relative to the Instance slot's local coordinate space.
Usage

Note that this node's output takes into account the scale of the Instance slot when calculating the conversion. If a calculation should be scale-invariant use Global Direction To Local.
}

FrooxEngine.LogiX.WorldModel.GetLeft:######################################################################
{
The <color=#00FF00>Left</color> node outputs the vector in global coordinate space which is parallel to the Instance slot's negative X coordinate vector.
Usage

The output vector is normalized such that its magnitude is 1. 
}


FrooxEngine.LogiX.WorldModel.LocalDirectionToGlobal:#######################################################
{
The <color=#00FF00>Local Direction To Global</color> node takes the input LocalDirection vector vector relative to the Instance slot's local coordinate space and outputs the equivalent GlobalDirection vector.
Usage

Note that this node only takes into account the relative rotation between the global and local coordinate spaces when calculating the conversion, the scale of the Instance slot does not affect the output. If scale is important for a calculation use Local Vector To Global. 
}


FrooxEngine.LogiX.WorldModel.LocalPointToGlobal:###########################################################
{
The <color=#00FF00>Local Point To Global</color> node takes the input LocalPoint position vector relative to the Instance slot's local coordinate space and outputs the equivalent GlobalPoint position vector. 
}


FrooxEngine.LogiX.WorldModel.LocalRotationToGlobal:#######################################################
{
The <color=#00FF00>Local Rotation To Global</color> node takes an input LocalRotation floatQ relative to the Instance slot's local coordinate space and outputs the equivalent GlobalRotation floatQ.
}


FrooxEngine.LogiX.WorldModel.LocalScaleToGlobal:##########################################################
{
The <color=#00FF00>Local Scale To Global</color> node takes the input LocalScale vector relative to the Instance slot's local coordinate space and outputs the equivalent GlobalScale vector.
}


FrooxEngine.LogiX.WorldModel.LocalTransform:##############################################################
{
The <color=#00FF00>Local Transform</color> node outputs the Instance slot's LocalPosition, LocalRotation, and LocalScale.
Usage

Note that the values output by this node match those shown in the slot inspector panel because the inspector shows values in local coordinate space. 
}


FrooxEngine.LogiX.WorldModel.LocalVectorToGlobal:#########################################################
{
The <color=#00FF00>Local Vector To Global</color> node takes the input LocalVector relative to the Instance slot's local coordinate space and outputs the equivalent GlobalVector .
Usage

Note that this node's output takes into account the scale of the Instance slot when calculating the conversion. If a calculation should be scale-invariant use Local Direction To Global. 
}


FrooxEngine.LogiX.WorldModel.GetRight:####################################################################
{
The <color=#00FF00>Right</color> node outputs the vector in global coordinate space which is parallel to the Instance slot's positive X coordinate vector.
Usage

The output vector is normalized such that its magnitude is 1. 
}


FrooxEngine.LogiX.WorldModel.SetBackward:#################################################################
{
The <color=#00FF00>Set Backward</color> node rotates the Instance slot such that its negative Z axis becomes parallel to the input global Backward direction vector when an impulse is received at Set.
Usage

An impulse is fired from OnDone when the Instance position is successfully changed. No impulse will be fired if there is no valid Instance when an impulse is received at Set. 
}


FrooxEngine.LogiX.WorldModel.SetDown:#####################################################################
{
The <color=#00FF00>Set Down</color> node rotates the Instance slot such that its negative Y axis becomes parallel to the input global Down direction vector when an impulse is received at Set.
Usage

An impulse is fired from OnDone when the Instance position is successfully changed. No impulse will be fired if there is no valid Instance when an impulse is received at Set. 
}


FrooxEngine.LogiX.WorldModel.SetForward:##################################################################
{
The <color=#00FF00>Set Forward</color> node rotates the Instance slot such that its positive Z axis becomes parallel to the input global Forward direction vector when an impulse is received at Set.
Usage

An impulse is fired from OnDone when the Instance position is successfully changed. No impulse will be fired if there is no valid Instance when an impulse is received at Set. 
}



FrooxEngine.LogiX.WorldModel.SetGlobalPosition:###########################################################
{
The <color=#00FF00>Set Global Position</color> node moves the Instance slot to the input global Position when an impulse is received at Set.
Usage

An impulse is fired from OnDone when the Instance position is successfully changed. No impulse will be fired if there is no valid Instance when an impulse is received at Set.

}


FrooxEngine.LogiX.WorldModel.SetGlobalPositionRotation:###################################################
{
The <color=#00FF00>Set Global Position Rotation</color> node moves and rotates the Instance slot to the input global Position and Rotationwhen an impulse is received at Set.
Usage

An impulse is fired from OnDone when the Instance position and rotation is successfully changed. No impulse will be fired if there is no valid Instance when an impulse is received at Set.

}



FrooxEngine.LogiX.WorldModel.SetGlobalRotation:###########################################################
{
The <color=#00FF00>Set Global Rotation</color> node rotates the Instance slot to the input global Rotation when an impulse is received at Set.
Usage

An impulse is fired from OnDone when the Instance rotation is successfully changed. No impulse will be fired if there is no valid Instance when an impulse is received at Set. 
}


FrooxEngine.LogiX.WorldModel.SetGlobalScale:##############################################################
{
The <color=#00FF00>Set Global Scale</color> node re-scales the Instance slot to the input global Scale when an impulse is received at Set.
Usage

The default Scale is 1. The default Instance is null.

An impulse is fired from OnDone when the Instance is successfully re-scaled. No impulse will be fired if Instance was null when an impulse is received at Set.
}

FrooxEngine.LogiX.WorldModel.SetGlobalTransform:##########################################################
{
The <color=#00FF00>Set Global Transform</color> node moves, rotates, and re-scales the Instance slot to the input global Position, Rotation and Scale when an impulse is received at Set.
Usage

An impulse is fired from OnDone when the Instance transform is successfully changed. No impulse will be fired if there is no valid Instance when an impulse is received at Set. 
}



FrooxEngine.LogiX.WorldModel.SetGlobalTransformMatrix:####################################################
{
The <color=#00FF00>Set Global Transform Matrix</color> node moves, rotates, and re-scales the Instance slot in global coordinate space according to the input TRS Matrix when an impulse is received at Set.
Usage

An impulse is fired from OnDone when the Instance transform is successfully changed. No impulse will be fired if there is no valid Instance when an impulse is received at Set. 
}


FrooxEngine.LogiX.WorldModel.SetLeft:#####################################################################
{
The <color=#00FF00>Set Left</color> node rotates the Instance slot such that its negative X axis becomes parallel to the input global Left direction vector when an impulse is received at Set.
Usage

An impulse is fired from OnDone when the Instance position is successfully changed. No impulse will be fired if there is no valid Instance when an impulse is received at Set. 
}



FrooxEngine.LogiX.WorldModel.SetLocalPosition:############################################################
{
The <color=#00FF00>Set Local Position</color> node moves the Instance slot to the input local Position when an impulse is received at Set.
Usage

An impulse is fired from OnDone when the Instance position is successfully changed. No impulse will be fired if there is no valid Instance when an impulse is received at Set. 
}


FrooxEngine.LogiX.WorldModel.SetLocalPositionRotation:####################################################
{
The <color=#00FF00>Set Local Position Rotation</color> node moves and rotates the Instance slot to the input local Position and Rotationwhen an impulse is received at Set.
Usage

An impulse is fired from OnDone when the Instance position and rotation is successfully changed. No impulse will be fired if there is no valid Instance when an impulse is received at Set. 
}


FrooxEngine.LogiX.WorldModel.SetLocalRotation:############################################################
{
The <color=#00FF00>Set Local Rotation</color> node rotates the Instance slot to the input local Rotation when an impulse is received at Set.
Usage

An impulse is fired from OnDone when the Instance rotation is successfully changed. No impulse will be fired if there is no valid Instance when an impulse is received at Set.

}



FrooxEngine.LogiX.WorldModel.SetLocalScale:###############################################################
{
The <color=#00FF00>Set Local Scale</color> node re-scales the Instance slot to the input local Scale when an impulse is received at Set.
Usage

An impulse is fired from OnDone when the Instance is successfully re-scaled. No impulse will be fired if there is no valid Instance when an impulse is received at Set. 
}



FrooxEngine.LogiX.WorldModel.SetLocalTransform:###########################################################
{
The <color=#00FF00>Set Local Transform</color> node moves, rotates, and re-scales the Instance slot to the input local Position, Rotation and Scale when an impulse is received at Set.
Usage

An impulse is fired from OnDone when the Instance transform is successfully changed. No impulse will be fired if there is no valid Instance when an impulse is received at Set. 
}

FrooxEngine.LogiX.WorldModel.SetRight:####################################################################
{
The <color=#00FF00>Set Right</color> node rotates the Instance slot such that its positive X axis becomes parallel to the input global Right direction vector when an impulse is received at Set.
Usage

An impulse is fired from OnDone when the Instance position is successfully changed. No impulse will be fired if there is no valid Instance when an impulse is received at Set.
}


FrooxEngine.LogiX.WorldModel.SetTRS:######################################################################
{
The <color=#00FF00>Set TRS</color> node moves, rotates, and re-scales the Instance slot in its local coordinate space according to the input TRS matrix when an impulse is received at Set.
Usage

An impulse is fired from OnDone when the Instance transform is successfully changed. No impulse will be fired if there is no valid Instance when an impulse is received at Set. 
}



FrooxEngine.LogiX.WorldModel.SetUp:#######################################################################
{
The <color=#00FF00>Set Up</color> node rotates the Instance slot such that its positive Y axis becomes parallel to the input global Up direction vector when an impulse is received at Set.
Usage

An impulse is fired from OnDone when the Instance position is successfully changed. No impulse will be fired if there is no valid Instance when an impulse is received at Set. 
}



FrooxEngine.LogiX.WorldModel.TransformDirection:##########################################################
{
The <color=#00FF00>Transform Direction</color> node takes the input SourceDirection vector in the local coordinate space of the FromSpace slot and outputs the equivalent TargetDirection vector in the ToSpace slot's local coordinate space.
Usage

Note that this node only takes into account the relative rotation between the two local coordinate spaces when calculating the conversion, the relative scale of the slots does not affect the output. If scale is important for a calculation use Transform Vector. 
}



FrooxEngine.LogiX.WorldModel.TransformPoint:##########################################################
{
The <color=#00FF00>Transform Point</color> node takes the SourcePoint position vector in the FromSpace slot's local coordinate space and outputs the equivalent TargetPoint position vector in the ToSpace slot's local coordinate space. 
}



FrooxEngine.LogiX.WorldModel.TransformRotation:###########################################################
{
The <color=#00FF00>Transform Rotation</color> node takes the input SourceRotation floatQ in the FromSpace slot's local coordinate space and outputs the equivalent TargetRotation floatQ in the ToSpace slot's local coordinate space.
}


FrooxEngine.LogiX.WorldModel.TransformScale:##############################################################
{
The <color=#00FF00>Transform Scale</color> node takes the input SourceScale vector in the FromSpace slot's local coordinate space and outputs the eqivalent TargetScale vector in the ToSpace slot's local coordinate space.
}


FrooxEngine.LogiX.WorldModel.TransformVector:#############################################################
{
The <color=#00FF00>Transform Vector</color> node takes the input SourceVector vector in the FromSpace slot's local coordinate space and and outputs the equivalent TargetVector in the ToSpace slot's local coordinate space.
Usage

Note that this node's output takes into account the relative scale of the FromSpace and ToSpace slots when calculating the conversion. If a calculation should be scale-invariant use Transform Direction. 
}


FrooxEngine.LogiX.WorldModel.GetUp:#######################################################################
{
The <color=#00FF00>Up</color> node outputs the vector in global coordinate space which is parallel to the Instance slot's positive Y coordinate vector.
Usage

The output vector is normalized such that its magnitude is 1. 
}


############## Bounds ############################
FrooxEngine.LogiX.Transform.BoundingBoxFromCenterSize:####################################################
{
The <color=#00FF00>Bounding Box From Center Size</color> node calculates a BoundingBox with the given xyz Center and xyz Size values.
Usage

The maximum or minimum value for any particular coordinate will be the Center minus or plus 0.5*Size respectively for that coordinate. 
}


FrooxEngine.LogiX.Transform.BoundingBoxProperties:########################################################
{
The <color=#00FF00>Bounding Box Properties</color> node provides several pieces of data about the input Bounds.
Usage

The Min and Max outputs provide the minimum and maximum extents for the input Bounds on xyz coordinates.


The Valid output will be False if Bounds has the special value EmptyBounds, any of the Center coordinates has the special float values NaN or Infinity, or the Size has negative, NaN, or Infinity values. Otherwise True.


The Empty output will be True if Bounds has the special value EmptyBounds. This may occur if Bounds is output from Empty Bounding Box (LogiX node) or it is the BoundingBox for a slot which has no elements which would cause it to have a volume (e.g. collider components). Note that calculating a bounding box with center [0,0,0] and size [0,0,0] does not produce an EmptyBounds value. 
}


FrooxEngine.LogiX.Transform.ComputeBoundingBox:###########################################################
{
The <color=#00FF00>Compute Bounding Box</color> node calculates a BoundingBox for the Instance slot hierarchy in the local coordinate space of the CoordinateSpace slot.
Usage

The IncludeInactive input determines whether inactive slots are used for BoundingBox calculation, default is False.


The OnlyWithTag input can be used to specify that only slots with a matching tag should be used for BoundingBox calculation, default is empty (i.e. not used).

}



FrooxEngine.LogiX.Transform.EmptyBoundingBox:#############################################################
{
The <color=#00FF00>Empty Bounding Box</color> outputs a BoundingBox with the special value EmptyBounds. 
}


FrooxEngine.LogiX.Transform.EncapsulateBounds:############################################################
{
The <color=#00FF00>Encapsulate Bounds</color> node returns calculated bounding box that includes bounding box of Bounds and OtherBounds.
Usage

Default value of Bounds and OtherBounds is bounding box which is center of [0,0,0], size of [0,0,0].

}



FrooxEngine.LogiX.Transform.EncapsulatePoint:#############################################################
{
The <color=#00FF00>Encapsulate Point</color> node returns calculated bounding box that includes bounding box of Bounds and float3 Point.
Usage

Default value of Bounds and OtherBounds is bounding box which is center of [0,0,0], size of [0,0,0], and default value of Point is [0,0,0].

}


FrooxEngine.LogiX.Transform.TransformBounds:##############################################################
{
The <color=#00FF00>Transform Bounding Box</color> node transforms the Bounds from being in to the SourceSpace local coordinate space to being relative to the TargetSpace local coordinate space.
Usage

The SourceSpace and TargetSpace inputs default to the world root slot, i.e. measuring relative to global coordinate space. 
}




FrooxEngine.LogiX.UI.ClearFocus:########################################################################
{
The <color=#00FF00>Clear Focus</color> node closes the Neos software keyboard and finishes editing of any TextEditor when an impulse is received at Focus
Usage

The OnDone output fires an impulse when any open editing has finished as a result of an impulse recieved at Focus. An impulse is fired regardless of whether any editing was in progress.


Focused TextEditors are only closed for the user who owns the impulse.
}

FrooxEngine.LogiX.UI.DefocusFocusable:##################################################################
{
The <color=#00FF00>Defocus</color> node closes the Neos software keyboard and stops editing the Target TextEditor.
Usage

The OnDone output fires an impulse when the Target has been successfully defocused as a result of an impulse received at Defocus. An impulse is still fired even if the Target was not focused. No impulse is fired if there is no valid input Target.


The TextEditor is only defocused for the user who owns the impulse. If a TextEditor other than the Target is focused it will not be defocused if this node receives an impulse. 
}


FrooxEngine.LogiX.UI.FocusFocusable:####################################################################
{
The <color=#00FF00>Focus</color> node opens the the Neos software keyboard for editing the Target TextEditor.
Usage

The OnDone fires an impulse when the Target has been successfully focused. An impulse will not be fired if there is no valid Target input.


The TextEditor is focused only for the user who owns the impulse. 
}




FrooxEngine.LogiX.UI.HasLocalFocus:#####################################################################
{
The <color=#00FF00>Has Local Focus</color> node reports whether the local user has the input Target TextEditor focused for editing.
Usage

The output value is local, i.e. different for each user. 
}





FrooxEngine.LogiX.Undo.BeginUndoBatch:#####################################################################
{
The <color=#00FF00>Begin Undo Batch</color> node starts recording a batch of undoable changes when an impulse is received at DoCreate.
Usage

The Description input determines the text which is displayed in a user's radial menu next to the Undo button for the relevant undo step. Default is null.


The OnBegin output continues the impulse chain which triggered DoCreate; any changes which should be included in the same batch undo step should be performed during the impulse chain started from OnBegin.


The Undo Manager entry is created for the owner of the impulse received at Create. Unless the Description input has a non-null value, the text displayed around the Undo button in the radial menu is "(batch action)".

If you wish to perform some undoable changes in the impulse chain started from OnBegin and then later some ones which should not be included in the batch, you can explicitly finish the creation of the batch with End Undo Batch (LogiX node). Note that simply including a node which makes a change (e.g. Set Local Position) downstream of a Begin Undo Batch node does not automatically make it an undoable change - you must still create undo save points in the batch using the other nodes in the Undo category.

}



FrooxEngine.LogiX.Undo.CreateFieldUndoStep:################################################################
{
The <color=#00FF00>Create Field Undo Step</color> node creates an Undo Manager entry save point for the Target value field when an impulse is received at Create.
Usage

The Target input can be set to any value typed slot or component field by connecting LogiX wires as normal. Note that the color of the input will not change from it's dark green color.


The ForceNew input determines whether a new Undo Manager entry will be created for the Target field even if another one was already created for the same field in the preceding impulse chain. Default is false.


The OnCreated output fires an impulse when the Undo Manager entry has been successfully created. No impulse will be fired if there is no valid Target set.


The Undo Manager entry is created for the owner of the impulse received at Create. If this node is placed before any other nodes which alter the Target field value in an impulse chain, then the effects of those nodes will be undone if the user performs the Undo action from their radial context menu. 
}


FrooxEngine.LogiX.Undo.CreateReferenceUndoStep:############################################################
{
The <color=#00FF00>Create Reference Undo Step</color> node creates an Undo Manager entry save point for the Target reference field when an impulse is received at Create.

     

Usage

The Target input can be set to any reference typed slot or component field by connecting LogiX wires as normal. Note that the color of the input will not change from it's olive green color.


The ForceNew input determines whether a new Undo Manager entry will be created for the Target field even if another one was already created for the same field in the preceding impulse chain. Default is false.


The OnCreated output fires an impulse when the Undo Manager entry has been successfully created. No impulse will be fired if there is no valid Target set.


The Undo Manager entry is created for the owner of the impulse received at Create. If this node is placed before any other nodes which alter the reference held by the Target field in an impulse chain, then the effects of those nodes will be undone if the user performs the Undo action from their radial context menu. 

}



FrooxEngine.LogiX.Undo.CreateSpawnUndoStep:################################################################
{
The <color=#00FF00>Create Spawn Undo Step</color> node creates an Undo Manager entry for the spawning of the Target slot when an impulse is received at Create.
Usage

The Description input determines the text which is displayed in a user's radial menu next to the Undo button. Default is null.


The OnCreated output fires an impulse when the Undo Manager entry has been successfully created. No impulse will be fired if there is no valid Target set.


The Undo Manager entry is created for the owner of the impulse received at Create. Unless the Description input has a non-null value, the text displayed around the Undo button in the radial menu is "Spawn" + the name of the Target slot. 
}




FrooxEngine.LogiX.Undo.CreateTransformUndoStep:############################################################
{
The <color=#00FF00>Create Transform Undo Step</color> node creates an Undo Manager entry save point for the Target spatial transform values when an impulse is received at Create.
Usage

The SaveParent input determines whether the Target slot parent is saved as part of the undo entry. Default is true.


The SavePosition input determines whether the Target position is saved as part of the undo entry. Default is true.


The SaveRotation input determines whether the Target rotation is saved as part of the undo entry. Default is true.


The SaveScale input determines whether the Target scale is saved as part of the undo entry. Default is true.


The OnCreated output fires an impulse when the Undo Manager entry has been successfully created. No impulse will be fired if there is no valid Target set.


The Undo Manager entry is created for the owner of the impulse received at Create. If this node is placed before any other nodes which alter the transform of the Target an impulse chain, then the effects of those nodes will be undone if the user performs the Undo action from their radial context menu. The text displayed around the Undo button in the radial menu is "Moved" + the name of the Target slot.

If SaveParent is true, the Target is returned to the same local transform as it held when the undo step was created. If instead SaveParent is false, the Target is returned to the global transform it held when the undo step was created. 
}



FrooxEngine.LogiX.Undo.CreateTypeFieldUndoStep:###########################################################
{
The <color=#00FF00>Create Type Field Undo Step</color> node creates an Undo Manager entry save point for the Target type field when an impulse is received at Create.
Usage

The ForceNew input determines whether a new Undo Manager entry will be created for the Target field even if another one was already created for the same field in the preceding impulse chain. Default is false.


The OnCreated output fires an impulse when the Undo Manager entry has been successfully created. No impulse will be fired if there is no valid Target set.


The Undo Manager entry is created for the owner of the impulse received at Create. If this node is placed before any other nodes which alter the Target field in an impulse chain, then the effects of those nodes will be undone if the user performs the Undo action from their radial context menu.

Type fields are extremely rare in Neos and, as such, users will almost never need to use this node. For any standard value typed fields use Create Field Undo Step (LogiX node) or for reference typed fields use Create Reference Undo Step (LogiX node). 
}



FrooxEngine.LogiX.Undo.CreateUndoBatch:###################################################################
{
The <color=#00FF00>Create Undo Batch</color> node can be used to create a batch of Undo Manager save points, before then making the relevant changes, when an impulse is received at DoCreate.
Usage

The Description input determines the text which is displayed in a user's radial menu next to the Undo button for the relevant undo step. Default is null.


The Create output fires an impulse immediately after one is received at DoCreate. This impulse chain should be used for creating all undo points which should be included in a batch undo step. This does not need to be explicitly finished using End Undo Batch (LogiX node).


The OnCreated output fires an impulse after the impulse chain from Create has finished and the relevant batch undo point created. This impulse chain can be used to make changes to the fields or object transforms for which undo steps were made during the Create impulse chain.


The Undo Manager entry is created for the owner of the impulse received at Create. Unless the Description input has a non-null value, the text displayed around the Undo button in the radial menu is "(batch action)".

The nodes which work best with this method of creating undoable batches are Create Field Undo Step (LogiX node), Create Reference Undo Step (LogiX node), Create Type Field Undo Step (LogiX node), and Create Transform Undo Step (LogiX node). If you need to include Create Spawn Undo Step (LogiX node) or Undoable Destroy (LogiX node) in a batch it is recommended to use Begin Undo Batch (LogiX node) instead. 
}



FrooxEngine.LogiX.Undo.EndUndoBatch:######################################################################
{
The <color=#00FF00>End Undo Batch</color> node is used to explicitly finish the creation of a batch of undoable changes started by a Begin Undo Batch (LogiX node). 
}


FrooxEngine.LogiX.Undo.UndoableDestroy:###################################################################
{
The <color=#00FF00>Undoable Destroy</color> node destroys the Target slot and creates an Undo Manager entry when an impulse is received at Create.
Usage

The PreserveAssets input determines whether assets held under the destroyed hierarchy which are in use by other slots in the world will be preserved under a new slot under the world Assets slot.


The OnCreated output fires an impulse when the Undo Manager entry has been successfully created and the Target destroyed. No impulse will be fired if there is no valid Target set.


The Undo Manager entry is created for the owner of the impulse received at Create. This allows that user to undo the destruction of the Target via their radial context menu. 
}




FrooxEngine.LogiX.WorldModel.ActiveUserRootUser:###########################################################
{
The <color=#00FF00>Active User Root User</color> node gets the User from the given User Root.
}

FrooxEngine.LogiX.WorldModel.HostUser:#####################################################################
{
The <color=#00FF00>Host User</color> node outputs a reference to the User who is hosting the current world session. 
}


FrooxEngine.LogiX.WorldModel.IsLocalUser:##################################################################
{
The <color=#00FF00>Is Local User</color> outputs True if the input User is the local user, otherwise False.
Usage
Examples

This can be used to locally enable / disable objects for a specific user by driving the Active property of the relevant slot(s). 
}



FrooxEngine.LogiX.WorldModel.IsNeosDashOpened:#############################################################
{
The <color=#00FF00>Is Neos Dash Opened</color> outputs True if the input User has their Neos Dash menu opened, otherwise False.
Usage
Examples

ProbablePrime has a tutorial for displaying a visual when a user has their Neos Dash menu open 
}


FrooxEngine.LogiX.WorldModel.IsPlatformDashOpened:#########################################################
{
The <color=#00FF00>Is Platform Dash Opened</color> outputs True if the input User has their Platform Dash menu opened (e.g. SteamVR menu), otherwise False.
Usage
Examples

ProbablePrime has a tutorial for displaying a visual when a user has their Platform Dash menu open 
}


FrooxEngine.LogiX.WorldModel.IsUserHost:###################################################################
{
The <color=#00FF00>Is User Host</color> node outputs a boolean value dependent on whether the input User is the host of the current world session. 
}


FrooxEngine.LogiX.WorldModel.IsUserInEditMode:#############################################################
{
The <color=#00FF00>Is User In Edit Mode</color> node outputs a boolean value dependent on whether the input User is currently in Edit Mode.
}


FrooxEngine.LogiX.WorldModel.IsUserInKioskMode:############################################################
{
The <color=#00FF00>Is User In Kiosk Mode</color> node outputs True if the input User is in kiosk mode, otherwise False. 
}


FrooxEngine.LogiX.WorldModel.IsUserPatron:#################################################################
{
The <color=#00FF00>Is User Patron</color> node outputs True if the input User supports NeosVR development on Patreon, otherwise False.
Usage

Note that for this node to correctly output 'True' if the input User is a patron, their Patreon and NeosVR accounts must be linked. 
}


FrooxEngine.LogiX.WorldModel.IsUserPresent:################################################################
{
The <color=#00FF00>Is User Present</color> node outputs True if the input User has the current world session focused and is wearing their headset, otherwise False. 
}


FrooxEngine.LogiX.WorldModel.IsUserPresentInHeadset:#######################################################
{
The <color=#00FF00>Is User Present In Headset</color> node outputs True if the input User has their headset on, otherwise False.
Usage

This node reports on data from proximity sensors which are only present in some headsets. If not supported by a user's hardware, or heuristics (e.g. detecting movement) cannot be used, the default output is True (this is the case for screen mode users). Note that this node will output False if the input User is not present at all in the current world session. The related Is User Present (LogiX node) reports whether a user both has their headset on and has the current world focused. 
}


FrooxEngine.LogiX.WorldModel.IsUserPresentInWorld:#########################################################
{
The <color=#00FF00>Is User Present In World</color> node outputs True if the input User has the current world session focused, otherwise False.

Usage

This node only checks whether a user has the current world focused, it does not report on whether the user has their headset on or not - that information is available from the Is User Present In Headset (LogiX node). The Is User Present (LogiX node) reports whether a user both has their headset on and has the current world focused.
}

FrooxEngine.LogiX.WorldModel.IsUserSilenced:###############################################################
{
Needs a wiki page
}


FrooxEngine.LogiX.WorldModel.LocalUser:###################################################################
{
The <color=#00FF00>Local User</color> node outputs a reference to the Local User.
Usage

The output of this node will necessarily be different dependent on which user owns the impulse chain under which the Local User node's output is checked.

Imagine world session hosted by Alice where Bob is also present.

    A button is connected via LogiX such that the Local User's Username at time of firing is written to a String variable.
    If either user presses the button, their username will be written to the variable.
    If Alice pushes the button Alice's name is written to the variable.
    If Bob pushes the button Bob's name is written to the variable.
}


FrooxEngine.LogiX.WorldModel.LocalUserRoot:###############################################################
{
The <color=#00FF00>Local User Root</color> node outputs the UserRoot reference for the Local User.
Usage

The UserRoot datatype output can be used with many nodes in the User Root node category. 
}


FrooxEngine.LogiX.WorldModel.LocalUserSlot:###############################################################
{
The <color=#00FF00>Local User Slot</color> node outputs the Local User's slot reference in the current world session's slot hierarchy. 
}


FrooxEngine.LogiX.WorldModel.LocalUserSpace:##############################################################
{
The <color=#00FF00>Local User Space</color> node outputs the slot that the local user is parented under.
Usage

In some worlds, users may be under the management of systems which parent a user to a slot which is other than the world Root Slot. This is common with Spawn Areas which have the Parent User setting enabled or with World Management systems that create a new slot for each user. When such systems exist it is recommended that your systems respect them.

In many setups this node can be used in place of Root Slot (LogiX node).

Examples include:

    Guns
    Rockets
    Projectiles
    Gadgets and Tools that parent things

Examples

If we have a world hierarchy that looks like this:

    Root
        Users
            User ProbablePrime - The actual User

If the user spawns an object from their inventory, let's say a Rocket Launcher, it will be parented to the "Users" slot:

    Root
        Users
            User ProbablePrime - The actual User
            Rocket Launcher

If the Rocket Launcher fires a rocket which needs re-parenting using "Local User Space" then it would be parented to the Users Slot:

    Root
        Users
            User ProbablePrime - The actual User
            Rocket Launcher
            Rocket

If the Root Slot Node is used instead it would be parented to the Root Slot:

    Root
        Rocket
        Users
            User ProbablePrime - The actual User
            Rocket Launcher

This can mess with world management systems or culling systems. 
}



FrooxEngine.LogiX.WorldModel.UserMachineID:###############################################################
{
The <color=#00FF00>MachineID</color> node outputs a string containing the machine ID of the input User.
Usage

A User's MachineID is a randomly generated string created on database (re)initialization for the installed copy of Neos. This is not a reliable way to persistently store an ID for each user since will change if a user performs a database reset. For a permanent ID for a specific user, use the UserID node.

However, even if the user is not registered at the same time, this ID can always be obtained, so it is effective for fallback when the user ID cannot be obtained. 
}

FrooxEngine.LogiX.WorldModel.UserActiveViewTargettingController:##########################################
{
The <color=#00FF00>User Active View Targetting Controller</color> node outputs the User's currently active desktop view targetting controller.
Usage

Possible output values are:

    FirstPersonTargettingController
    ThirdPersonTargettingController
    FreeformTargettingController
    UI_TargettingController

Default output is null if the input User is null or the relevant user is in VR mode. 
}



FrooxEngine.LogiX.WorldModel.UserDownloadSpeed:###########################################################
{
The <color=#00FF00>User Download Speed</color> node.
}


FrooxEngine.LogiX.WorldModel.UserFPS:#####################################################################
{
The <color=#00FF00>User FPS</color> node outputs the current frames per second (FPS), i.e. their framerate, for the input user.


Usage

Many people include text in a custom nametag which is driven by this node to advertise that their PC has low FPS (is a potato). 
}



FrooxEngine.LogiX.WorldModel.UserFromID:##################################################################
{
The <color=#00FF00>User From ID</color> node outputs a reference to the User in the current session corresponding to the input strings.
Usage

This will successfully output a user reference even if only one of the inputs is connected or valid. If both are provided, the UserID will be matched in preference over the MachineID. If an invalid UserID is provided, the node will attempt to find a valid match based on MachineID. Default output is null. 
}



FrooxEngine.LogiX.WorldModel.UserFromUsername:############################################################
{
The <color=#00FF00>User From Username</color> node outputs a reference to the User in the current session with matching Username.
Usage

The IgnoreCase input determines whether the input string must match the Username by case. Default is True, i.e. case matching is not important.


The AllowPartialMatch input determines whether partial matches will be accepted. Default is False.


The matching process tries to find usernames which start with an identical string to the Username input. If multiple users are possible matches, only one is provided as the User output. Priority is taken by users which joined the world earliest. 
}



FrooxEngine.LogiX.WorldModel.UserHeadOutputDevice:########################################################
{
The <color=#00FF00>User Head Output Device</color> node outputs which HMD platform the input User is using.
Usage

When supplied a User value via LogiX this node will output the HeadOutputDevice Enum value which corresponds to the headset or system that this User is using. Please see the HeadOutputDevice page for a full list of values. Note that not all headset systems have a value and in some cases there are overlaps. This is especially apparent within the SteamVR based systems such as HTC Vive, Cosmos and the Index.

When using this node within Neos, try to make sure that you're covering for as many potential values as possible. Using this value in a conditional for example could unintentionally lock out a User or prevent the LogiX from progressing if they are using an unusual headset. 
}


FrooxEngine.LogiX.WorldModel.UserJoined:##################################################################
{
The <color=#00FF00>User Joined</color> node fires an impulse from OnJoined when a user joins the current world session. It also outputs a reference to the user who joined.
Usage

The impulse fired from OnJoined is owned by the world host. For a similar node which will also fire when users are respawned see User Spawn. 
}


FrooxEngine.LogiX.WorldModel.UserLeft:####################################################################
{
The <color=#00FF00>User Left</color> node fires an impulse from OnLeft when a user leaves the current world session. It also outputs a reference to the user who left.
Usage

The impulse fired from OnLeft is owned by the session host.


The LeftUser reference will only be available for the duration of the impulse chain fired from OnLeft.
}



FrooxEngine.LogiX.WorldModel.UserPing:####################################################################
{
The <color=#00FF00>User Ping</color> node outputs the current ping time for the input user.

Usage

The ping time (in milliseconds) corresponds to the time taken between the user's PC sending a message to the world host server and receiving a response, also called the network latency. Lower values are better, higher values may result in noticeable lag. 

}

FrooxEngine.LogiX.WorldModel.UserPlatform:################################################################
{
The <color=#00FF00>User Platform</color> node outputs an Enum corresponding to the input User operating system platform. 

Usage

Possible options are:

    Windows
    OSX
    Linux
    Android
    Other

Default if User is null is -1. 
}



FrooxEngine.LogiX.WorldModel.UserPrimaryHand:#############################################################
{
The <color=#00FF00>User Primary Hand</color> node outputs the primary hand setting of the input User.
Usage

Output is either Right or Left if a valid User value is present. Otherwise -1. 
}


FrooxEngine.LogiX.WorldModel.UserQueuedMessages:##########################################################
{
Needs Wiki Page
}


FrooxEngine.LogiX.WorldModel.UserRecordingVoiceMessage:###################################################
{
The <color=#00FF00>User Recording Voice Message</color> node outputs True if the input User is recording a voice message to one of their Contacts, otherwise False. Default output is False. 
}


FrooxEngine.LogiX.WorldModel.UserRootSlot:################################################################
{
The <color=#00FF00>User Root Slot</color> node outputs the the input User's root slot in the current world session's slot hierarchy.
Usage

Default output is null unless a valid User is provided. 
}


FrooxEngine.LogiX.WorldModel.UserSpawn:###################################################################
{
The <color=#00FF00>User Spawn</color> fires an impulse from OnSpawn whenever a user is (re)spawned in a world.

Usage

The impulse from OnSpawn is owned by the host user. It fires both on user join and respawn events. The spawned user is available from the SpawnedUser output for the duration of the impulse chain started from OnSpawn. 
}


FrooxEngine.LogiX.WorldModel.UserUploadSpeed:#############################################################
{
The <color=#00FF00>User Upload Speed</color> node. 
}



FrooxEngine.LogiX.WorldModel.UserUploadSpeedMax:##########################################################
{
The <color=#00FF00>User Upload Speed</color> Max node.
}



FrooxEngine.LogiX.WorldModel.UserUploadedBytes:###########################################################
{
The <color=#00FF00>User Uploaded Bytes</color> node.
}


FrooxEngine.LogiX.WorldModel.UserUserRoot:################################################################
{
The <color=#00FF00>User User Root</color> node outputs a reference to the user root for the input User.
Usage

The output UserRoot datatype can be used with many nodes in the User Root category. To instead get a user's root slot in the world slot hierarchy use User Root Slot.
Examples

Avatar Anchor<<->->->-Anchored User->->->-User User Root->->->-Left Hand Position->->->-Float3 
}



FrooxEngine.LogiX.WorldModel.UserUsername:################################################################
{
The color=#00FF00>User Username</color> node outputs a string containing the input User username.
Usage

Note that a user's username can be changed under some circumstances (i.e. contacting the Neos team for support). Thus, usernames should not be used as permanent IDs. For that, use the UserID. Default output is null. 
}


FrooxEngine.LogiX.WorldModel.UserViewReferenceActive:#####################################################
{
The <color=#00FF00>User View Reference Active</color> node outputs True if the desktop view reference is active for the input User, otherwise False.
Usage

A user's view reference can be active when a user is in desktop mode and using either the UI aligned camera or the freeform camera. This also requires that the user's view reference is some distance from their main avatar. 
}


FrooxEngine.LogiX.WorldModel.UserViewVoiceActive:#########################################################
{
The <color=#00FF00>User View Voice Active</color> node outputs True if the input User's voice is being output from their view visual, otherwise False.
Usage

The view visual is the remote camera visual which may be active in the desktop UI aligned or freeform camera modes. The output for this node is local for each user since whether the input User's voice is output from the view visual or their avatar is determined locally. 
}


FrooxEngine.LogiX.WorldModel.UserVoiceMode:###############################################################
{
The <color=#00FF00>User Voice Mode</color> node returns an Enum value for the current VoiceMode of the input User.

Usage

Possible values are:

    Mute
    Whisper
    Normal
    Shout
    Broadcast

Default is Mute if the input User is null. 
}



FrooxEngine.LogiX.WorldModel.UserVR_Active:###############################################################
{
The <color=#00FF00>User VR Active</color> node outputs True if the User is in VR mode, otherwise False.
Usage

Note that this outputs False even if the user started in VR mode and then switched to desktop mode using the F8 keybind. Updates to this value may not automatically propagate to downstream nodes if the User switches between VR and desktop mode - it may need to be specifically evaluated during an impulse chain. 
}


FrooxEngine.LogiX.WorldModel.UserUserID:##################################################################
{
The <color=#00FF00>UserID</color> node outputs a string corresponding to the input User's UserID.
Usage

A user's UserID is a permanent ID linked to their user account. It commonly has the form U-Username. 
}


###############User Root############################
FrooxEngine.LogiX.WorldModel.ControllerSlot:########################################################
{
The <color=#00FF00>Controller Slot</color> node.
}


FrooxEngine.LogiX.WorldModel.FeetPosition:##########################################################
{
The <color=#00FF00>Feet Position</color> node. 
}


FrooxEngine.LogiX.WorldModel.FeetRotation:##########################################################
{
The <color=#00FF00>Feet Rotation</color> node. 
}


FrooxEngine.LogiX.WorldModel.HandSlot:##############################################################
{
The <color=#00FF00>Hand Slot</color> node.
}


FrooxEngine.LogiX.WorldModel.HeadFacingDirection:###################################################
{
The <color=#00FF00>Head Facing Direction</color> node.
}



FrooxEngine.LogiX.WorldModel.HeadFacingRotation:####################################################
{
The <color=#00FF00>Head Facing Rotation</color> node.
}


FrooxEngine.LogiX.WorldModel.HeadPosition:##########################################################
{
The <color=#00FF00>Head Position</color> node. 
}


FrooxEngine.LogiX.WorldModel.HeadRotation:##########################################################
{
The <color=#00FF00>Head Rotation</color> node. 
}

FrooxEngine.LogiX.WorldModel.HeadSlot:##############################################################
{
The <color=#00FF00>Head Slot</color> node.
}


FrooxEngine.LogiX.WorldModel.HipsPosition:##########################################################
{
The <color=#00FF00>Hips Position</color> node.
}


FrooxEngine.LogiX.WorldModel.HipsRotation:##########################################################
{
The <color=#00FF00>Hips Rotation</color> node.
}


FrooxEngine.LogiX.WorldModel.LeftHandPosition:######################################################
{
The <color=#00FF00>Left Hand Position</color> node.
}


FrooxEngine.LogiX.WorldModel.LeftHandRotation:######################################################
{
No wiki page yet... not like it needs one lol
}


FrooxEngine.LogiX.WorldModel.RightHandPosition:#####################################################
{
The <color=#00FF00>Right Hand Position</color> node.
}

FrooxEngine.LogiX.WorldModel.RightHandRotation:#####################################################
{
No wiki page yet... not like it needs one lol
}


FrooxEngine.LogiX.WorldModel.SetFeetPosition:#######################################################
{
The <color=#00FF00>Set Feet Position</color> node moves the input UserRoot such that the user's feet position is at the input global Position when an impulse is received at Set.
Usage

The Position input is interpreted in Global coordinate space with a default value of [0;0;0].


The OnSet output fires an impulse when the input UserRoot has been successfully moved as a result of an impulse received at Set (even if the user was already exactly at the target Position). An impulse will not be fired if there is no valid UserRoot input.


This node effectively teleports the user corresponding to the input UserRoot while preserving their rotation and scale. 
}



FrooxEngine.LogiX.WorldModel.SetFeetRotation:##########################################################
{
The <color=#00FF00>Set Feet Rotation</color> node rotates the input UserRoot such that the user's feet rotation is at the input global Rotation when an impulse is received at Set.
Usage

The Rotation input is interpreted in Global coordinate space with a default value (in Euler angles) of [0;0;0].


The OnSet output fires an impulse when the input UserRoot has been successfully rotated as a result of an impulse received at Set (even if the user was already exactly at the target Rotation). An impulse will not be fired if there is no valid UserRoot input.


This node rotates the user corresponding to the input UserRoot while preserving their position and scale. 
}


FrooxEngine.LogiX.WorldModel.SetHeadFacingDirection:#####################################################
{
No wiki page..
}


FrooxEngine.LogiX.WorldModel.SetHeadFacingRotation:######################################################
{
No wiki page..
}



FrooxEngine.LogiX.WorldModel.SetHeadPosition:#############################################################
{
The <color=#00FF00>Set Head Position</color> node moves the input UserRoot such that the user's head position is at the input global Position when an impulse is received at Set.
Usage

The Position input is interpreted in Global coordinate space with a default value of [0;0;0].


The OnSet output fires an impulse when the input UserRoot has been successfully moved as a result of an impulse received at Set (even if the user was already exactly at the target Position). An impulse will not be fired if there is no valid UserRoot input.


This node effectively teleports the user corresponding to the input UserRoot while preserving their rotation and scale. 
}


FrooxEngine.LogiX.WorldModel.SetHeadRotation:#############################################################
{
The <color=#00FF00>Set Head Rotation</color> node rotates the input UserRoot such that the user's head rotation is at the input global Rotation when an impulse is received at Set.
Usage

The Rotation input is interpreted in Global coordinate space with a default value (in Euler angles) of [0;0;0].


The OnSet output fires an impulse when the input UserRoot has been successfully rotated as a result of an impulse received at Set (even if the user was already exactly at the target Rotation). An impulse will not be fired if there is no valid UserRoot input.


This node rotates the user corresponding to the input UserRoot while preserving their position and scale. 
}


FrooxEngine.LogiX.WorldModel.SetHipsPosition:#############################################################
{
The <color=#00FF00>Set Hips Position</color> node moves the input UserRoot such that the user's hip position is at the input global Position when an impulse is received at Set.
Usage

The Position input is interpreted in Global coordinate space with a default value of [0;0;0].


The OnSet output fires an impulse when the input UserRoot has been successfully moved as a result of an impulse received at Set (even if the user was already exactly at the target Position). An impulse will not be fired if there is no valid UserRoot input.


This node effectively teleports the user corresponding to the input UserRoot while preserving their rotation and scale. 
}


FrooxEngine.LogiX.WorldModel.SetHipsRotation:#############################################################
{
The <color=#00FF00>Set Hips Rotation</color> node rotates the input UserRoot such that the user's hip rotation is at the input global Rotation when an impulse is received at Set.
Usage

The Rotation input is interpreted in Global coordinate space with a default value (in Euler angles) of [0;0;0].


The OnSet output fires an impulse when the input UserRoot has been successfully rotated as a result of an impulse received at Set (even if the user was already exactly at the target Rotation). An impulse will not be fired if there is no valid UserRoot input.


This node rotates the user corresponding to the input UserRoot while preserving their position and scale. 
}


FrooxEngine.LogiX.WorldModel.SetUserScale:################################################################
{
No Wiki Documentation
}


FrooxEngine.LogiX.WorldModel.UserRootGlobalScale:########################################################
{
The <color=#00FF00>User Root Global Scale</color> node.
}

FrooxEngine.LogiX.Data.ClearDynamicVariables:##############################################################
{
The <color=#00FF00>Clear Dynamic Variables</color> node will attempt to delete all DynamicField<T>, DynamicReference<T>, DynamicReferenceVariable<T>, and DynamicValueVariable<T> components bound to a DynamicVariableSpace with the input SpaceName when an impulse is received at Clear.
Usage

The Target input specifies where in the world hierarchy the node should start searching for a DynamicVariableSpace, by default this is the root slot. The node searches for a DynamicVariableSpace with the input SpaceName starting with the Target slot, if no exact match is found it will then perform an upward search of the world hierarchy.


The OnNotFound output will fire an impulse if an impulse is received at Clear but the node is unable to find a DynamicVariableSpace with the input SpaceName.


The OnCleared output will fire an impulse if a matching DynamicVariableSpace is found. Under this condition, this output will fire regardless of whether any dynamic variable components were deleted.


The ClearedCount output provides the number of components which were deleted. This data is only available for the duration of the impulse chain fired from OnCleared. 
}



FrooxEngine.LogiX.Data.ClearDynamicVariablesOfType`1[T]:###################################################
{
Clear <color=#00FF00>Dynamic Variables Of Type`1</color> (Logix node)

The Clear Dynamic Variables node will attempt to delete all DynamicField<T> and DynamicValueVariable<T> components (for value types) or DynamicReference<T> and DynamicReferenceVariable<T> components (for reference types) of the same type as the node which are bound to a DynamicVariableSpace with matching SpaceName in the Target slot's hierarchy.
Usage

The Target input specifies where in the world hierarchy the node should start searching for a DynamicVariableSpace, by default this is the root slot. The node searches for a DynamicVariableSpace with the input SpaceName starting with the Target slot, if no exact match is found it will then perform an upward search of the world hierarchy.


The OnNotFound output will fire an impulse if an impulse is received at Clear but the node is unable to find a DynamicVariableSpace with the input SpaceName.


The OnCleared output will fire an impulse if a matching DynamicVariableSpace is found. Under this condition, this output will fire regardless of whether any dynamic variable components were deleted.


The ClearedCount output provides the number of components which were deleted. This data is only available for the duration of the impulse chain fired from OnCleared.


When spawning this node from the node browser, it is possible to select one of a number of types for the node - only components of matching types will be deleted by this node when an impulse is received.

}




FrooxEngine.LogiX.Data.CreateDynamicVariable`1[T]:#########################################################
{
<color=#00FF00>Create Dynamic Variable`1</color> (LogiX node)

Introduction

The Create Dynamic Variable`1 node attempts to create a Dynamic Variable of the specified Type on the slot of the nearest DynamicVariableSpace to the Target Slot.

As usual, precautions related to the duplication and reparenting of dynamic variables apply, as described on the Dynamic Variables page.
Usage

Depending on the type of InitialValue, this component will attach a DynamicValueVariable`1 or DynamicReferenceVariable`1 component to the slot containing the nearest DynamicVariableSpace.

InitialValue is shown as being a T value for demonstration purposes, however it will be composed of the type selected in the LogiX browser, or specified in the Component Attacher.

When using the Component Attacher, you may specify any valid FrooxEngine or BaseX type by following the instructions on the Creating a custom LogiX Node page.

CreateDirectlyOnTarget overrides the default functionality of this node, and creates the Dynamic Variable directly on the Target slot, instead of the slot of the nearest DynamicVariableSpace.

CreateNonPersistent causes the resultant Dynamic Variable to be created as a non-persistent component, which will not be saved when the object or world is reloaded.

}




FrooxEngine.LogiX.Data.DeleteDynamicVariable`[T]:#########################################################
{
The <color=#00FF00>Delete Dynamic Variable`1</color> node will attempt to delete DynamicField<T> and DynamicValueVariable<T> components (for value types) or DynamicReference<T> and DynamicReferenceVariable<T> components (for reference types) of the same type as the node with an exactly matching VariableName.
Usage

The Target input specifies where in the world hierarchy the node should start searching for dynamic variables bound to a DynamicVariableSpace, by default this is the root slot. The node searches for a DynamicVariableSpace with matching variables starting with the Target slot, if no exact match is found it will then perform an upward search of the world hierarchy.


The OnCleared output will fire an impulse if a DynamicVariableSpace with a matching dynamic variable is found.


The OnNotFound output will fire an impulse if an impulse is received at Delete but the node is unable to find a DynamicVariableSpace with matching dynamic variable.


When spawning this node from the node browser, it is possible to select one of a number of types for the node - only components of matching types will be deleted by this node when an impulse is received. 
}



FrooxEngine.LogiX.Data.DynamicVariableInputWithEvents`1[T]:###############################################
{
Needs documented
}



FrooxEngine.LogiX.Data.DynamicVariableInput`1[T]:#########################################################
{

<color=#00FF00>Dynamic Variable Input`1</color>
'Dynamic Variable Input`1' LogiX node
Inputs
Outputs
  	Dummy 	Value
  	Bool 	FoundValue

The Dynamic Variable Input`1 node attempts to read the value of the given Dynamic Variable of the specified Type from the Slot that the node is packed into. The name of the dynamic variable is entered into the text field of the node. Value is shown as being a value for demonstration purposes, however it will be composed of the type selected in the LogiX browser, or specified in the component window.

When using the Components browser, you may specify any valid FrooxEngine or BaseX type by creating a component, and unpacking it to create a visual.

}



FrooxEngine.LogiX.Data.ReadCloudVariable`1[T]:############################################################
{

<color=#00FF00>Read Cloud Variable`1</color>
'Read Cloud Variable`1' LogiX node
Inputs
  	Impulse 	Read
  	String 	Path
  	String 	VariableOwnerId
Outputs
  	Impulse 	OnReadRequest
  	Impulse 	OnRead
  	Impulse 	OnFail
  	Float 	Value

The Read Cloud Variable`1 node is used to read a Value from an existing cloud variable specified by Path for the user specified in VariableOwnerId

}


FrooxEngine.LogiX.Data.ReadDynamicVariable`1[T]:##########################################################
{
The <color=#00FF00>Read Dynamic Variable`1</color> node attempts to read the value of a Dynamic Variable of the specified Type from the Source Slot. Value is shown as being a Dummy value for display purposes, however it will be composed of the type selected in the LogiX browser, or specified in the component window.

When using the Components browser, you may specify any valid FrooxEngine or BaseX type by creating a component, and unpacking it to create a visual.
Usage

Inputs:
Name 	Type 	Description

[Source] <color=#00FF00>Slot</color> The slot where the search for the variable begins. The default is the slot that this component is in.

[VariableName] <color=#00FF00>String</color> 	The name of the variable to read. If prefixed by a name with a slash, the string before the slash is the space name. The default is a blank name.


Outputs
Name 	Type 	Description

[Value] color=#00FF00>Dummy</color> 	The value of the variable. If the VariableName (excluding the space) is empty, or the Source is null then this will be the default value for variables of this type: null for reference types and strings, zero for numeric types, false for booleans, identity for quaternions and matrices.

[FoundValue] 	<color=#00FF00>Bool</color> 	Whether the variable was found. If the VariableName (excluding the space) is empty, or the Source is null then this will be false. 

}


FrooxEngine.LogiX.Data.WriteCloudVariable`1[T]:###########################################################
{
The <color=#00FF00>Write Cloud Variable`1</color> node is used to write the specified Value to an existing cloud variable specified by Path
}




FrooxEngine.LogiX.Data.WriteDynamicVariable`1[T]:########################################################
{
The <color=#00FF00>Write Dynamic Variable`1</color> node attempts to write the value of a Dynamic Variable of the specified Type in the Target Slot, or in the node itself if no slot is specified. Value is shown as being a Category:Types:Dummy value for demonstration purposes, however it will be composed of the type selected in the LogiX browser, or specified in the component window.

When using the Components browser, you may specify any valid FrooxEngine or BaseX type by creating a component, and unpacking it to create a visual.

Usage

Inputs:
Name 	Type 	Description
[Write] 	<color=#00FF00>Impulse</color> 	The impulse to start the write.

[Target] 	olor=#00FF00>Slot</color> The slot where the search for the variable begins. If not specified, the slot is that of the node itself.

[VariableName] 	<color=#00FF00>String</color> 	The name of the variable to write. If prefixed by a name with a slash, the string before the slash is the space name.

Outputs:
Name 	Type 	Description
[OnSuccess] 	<color=#00FF00>Impulse</color> 	An impulse output when the write is successful.

[OnFailed] 	<color=#00FF00>Impulse</color> 	An impulse output when the write is unsuccessful. This   
                                                happens when the variable could not be found.
}


FrooxEngine.LogiX.Data.WriteOrCreateDynamicVariable`1[T]:#################################################
{
Needs documented
}



#############./Storage######################













FrooxEngine.LogiX.Nodes.Visualization.FlashHighlightHierarchy:#############################################
{
The <color=#00FF00>Flash Highlight Hierarchy</color> node temporarily highlights objects under the target HierarchyRoot when an impulse is received at Flash.
Usage

The ExcludeColliders input determines whether collider components are excluded from being highlighted. Default is false (i.e colliders will be highlighted).


The ExcludeMeshes input determines whether meshes referenced by MeshRenderers or SkinnedMeshRenderers are excluded from being highlighted. Default is false (i.e. meshes will be highlighted).


The ExcludeDisabled input determines whether deactived collider or renderer components will be excluded from being highlighted. If this input is true, disabled components (or ones under inactive slot hierarches) will not be highlighted. Default is false (i.e. everything will be highlighted).


The Duration input controls how long the highlight visual will persist in seconds. Default is 0.5 seconds.


The Color input controls the color of the highlight visual. Default is white.


The OnDone output fires an impulse when the target hierarchy has been highlighted after an impulse was received at Flash. An impulse will be fired as long as a valid HierarchyRoot is available, regardless of whether any highlight visual was actually displayed.


The FlashRoot output provides the new slot on which the components required for the highlight visual are placed. This is only available for the duration of the impulse chain starting from OnDone


The highilght visual is produced by spawning a non-persistent slot under the world root called HighlightFlash. This contains an OverlapFresnelMaterial and several Tween<color> components. The material corresponds to the highlight color and the tweens control how the color changes over the duration of the effect. 
}



FrooxEngine.LogiX.WorldNodes.FocusWorld:###################################################################
{
The <color=#00FF00>Focus World</color> node focuses the world corresponding to the input URL if it is already open.

Usage

When an impulse is received at the Focus input, and a valid URL is provided, the user is swapped to the world linked to the URL. This requires that the user have the world open at the time. If the CloseCurrent value is True (False by default) the world that the user leaves is closed after the user changes focus. This can result in loss of unsaved changes! The form of URL required is that found in the URL field of a world orb WorldOrb component. 

}



FrooxEngine.LogiX.WorldNodes.OpenWorld:####################################################################
{
The <color=#00FF00>Open World</color> node starts a new session for the world corresponding to the URL input.

Usage

When an impulse is received at the Open input this node starts a new session of the world corresponding to the input URL. The correct form of URL is that found under the URL field of a world orb WorldOrb component. If successful, the opened world will be focused for the user unless AutoFocus is False (True by default). A new session will be started, even if the user is already present in a session of that world, if GetExisting is False (True by default). The usual loading indicator will show while the world loads unless LoadingIndicator is False (True by default). If MakePrivate is True the world access level is set to private (i.e. only invited users can join) (False by default). If the enum WorldRelation input is 'Replace' the newly opened world will be focused for the user and the old world will be closed without saving if they have the priviledges to do so - this will override AutoFocus = False.

When the OnWorldReady impulse fires, the SessionURL and SessionId outputs provide their respective values only for the duration of time taken for any impulse chain initiated by OnWorldReady to complete. 

}


FrooxEngine.LogiX.WorldNodes.WorldAccessLevel:#############################################################
{
The <color=#00FF00>World Access Level</color> node outputs the category of people (e.g. Friends) which are able to join the current world.

Usage

Output levels correspond to the radio setting under 'Who can join this world?' in the Session menu of the dash. Private = Nobody / Invited Users; LAN = LAN users; Friends = Friends; Registered Users = Registered Users; Anyone = Anyone.
}



FrooxEngine.LogiX.WorldNodes.WorldAwayKickEnabled:#########################################################
{
<color=#00FF00>World Away Kick Enabled</color> (LogiX node)

World Away Kick Enabled
'World Away Kick Enabled' LogiX node
Inputs
Outputs
  	Bool 	Enabled

The World Away Kick Enabled node returns whether the current session's auto-kick option is enabled. 
}


FrooxEngine.LogiX.WorldNodes.WorldAwayKickMinutes:#########################################################
{
The <color=#00FF00>World Away Kick</color> Minutes node returns the number of minutes required for the current session's auto-kick to trigger.
}



FrooxEngine.LogiX.WorldNodes.WorldDescription:#############################################################
{
The <color=#00FF00>World Description</color> node outputs the description metadata for the current world.
}



FrooxEngine.LogiX.WorldNodes.WorldHideFromListing:#########################################################
{
The <color=#00FF00>World Hide From Listing</color> node returns whether the current session is in hidden mode. 
}



FrooxEngine.LogiX.WorldNodes.WorldMaxUsers:################################################################
{
The <color=#00FF00>World Max Users</color> node outputs the maxiumum number of users able to join the world session. 
}


FrooxEngine.LogiX.WorldNodes.WorldMobileFriendly:##########################################################
{
The <color=#00FF00>World Mobile Friendly</color> node outputs whether the current world is tagged as 'Mobile Friendly'.

Usage

Note: the Mobile Friendly property is set voluntarily by users, so does not guarantee that the world will actually run well on weaker/mobile hardware. 
}



FrooxEngine.LogiX.WorldNodes.WorldName:####################################################################
{
The <color=#00FF00>World Name</color> node outputs the name of the current world.
}



FrooxEngine.LogiX.WorldNodes.WorldSaved:##################################################################
{
The <color=#00FF00>World Saved</color> node fires an impulse whenever the current world is saved.
}


FrooxEngine.LogiX.WorldNodes.WorldSessionID:##############################################################
{
The <color=#00FF00>World Session ID</color> node outputs the session ID for the current world session.
}



FrooxEngine.LogiX.WorldNodes.WorldSessionURL:#############################################################
{
The <color=#00FF00>World Session URL</color> node outputs the session URL for the current world session.
}


FrooxEngine.LogiX.WorldNodes.WorldSessionWebURL:##########################################################
{
The <color=#00FF00>World Session Web URL</color> node outputs the web session URL for the current world session. 

Usage

Attempting to open the provided URL in a web browser should attempt to open the target Neos session.
Examples

Sending a value from World Session Web URL to a web server to render on a web page, would allow users who browse the web page to auto-startup Neos with the Neos client attempting to connect to the target server. 
}



FrooxEngine.LogiX.WorldNodes.WorldURL:####################################################################
{
The <color=#00FF00>World URL</color> node outputs the world URL for the current world.
}



FrooxEngine.LogiX.WorldNodes.WorldUserCount:##############################################################
{
The <color=#00FF00>World User Count</color> node outputs the number of users currently in the world. 
}






FrooxEngine.LogiX.Math.Binary.AdderNode:#####################################################
{
The <color=#00FF00>Adder</color> node can be used to simulate the behavior of a hardware full adder circuit. It accepts two input bits plus a carry-in and returns the addition result plus a carry-out. 
}


FrooxEngine.LogiX.Math.Binary.BooleanCounter:#################################################
{
The <color=#00FF00>Boolean Counter</color> node counts the number of true/false values among the input boolean values. 
}

Math.Binary.ExtractBits_:#############################################################################
{
Converts an integer into its binary form by providing a boolean output for each bit.
}
Math.Binary.ComposeBits_:#############################################################################
{
Converts boolean values into an integer by providing a boolean input for each bit.
}
Math.Binary.HalfAsUShort:#############################################################################
Math.Binary.FloatAsUInt
Math.Binary.DoubleAsULong
{
Converts a floating point number into its binary representation by providing an integer output.

Can be combined with the extract bits node to read out the individual bits of a floating point number.

If you would like to know more about the binary representation of floating point numbers search IEEE 754 on the internet.
}
Math.Binary.UShortAsHalf:#############################################################################
Math.Binary.UIntAsFloat
Math.Binary.ULongAsDouble
{
Creates a floating point number from the binary representation of an integer.

If you would like to know more about the binary representation of floating point numbers search IEEE 754 on the internet.
}

FrooxEngine.LogiX.Input.DegToRadConstant:#####################################################
{

The <color=#00FF00>Deg -&gt; Rad</color> node 

outputs an approximation to the conversion factor used to convert angles in Degrees to angles in Radians.

Usage

To convert a value from Degrees to Radians simply multiply by this conversion factor. 

}


FrooxEngine.LogiX.Input.e_Node:#################################################################
{
The <color=#00FF00>e</color> node outputs an approximation to the mathematical constant e. 
}


FrooxEngine.LogiX.Input.RadToDegConstant:########################################################
{
The <color=#00FF00>Rad -&gt; Deg</color> node 

outputs an approximation to the conversion factor used to convert angles in Radians to angles in Degrees.

Usage

To convert a value from Radians to Degrees simply multiply by this conversion factor. 
}


FrooxEngine.LogiX.Input.PiNode:###################################################################
{
The <color=#00FF00></color> node outputs an approximation to the mathematical constant . 
}



FrooxEngine.LogiX.Input.HalfPiNode:################################################################
{
The <color=#00FF00>/2</color> node outputs an approximation to the mathematical constant  divided by 2. 
}



FrooxEngine.LogiX.Input.TauNode:#####################################################################
{
The <color=#00FF00></color> node outputs an approximation to the mathematical constant  which is equal to  multiplied by 2.
}



FrooxEngine.LogiX.Input.Phi_Node:#####################################################################
{
The  node outputs an approximation to the mathematical Golden Ratio. 
}






FrooxEngine.LogiX.Operators.EnumToInt`1:########################################################
{
The <color=#00FF00>Enum To Int`1</color> LogiX node converts an Enum to an integer. Typically such Enum values are properties on components.
Usage

Use this node to convert an Enum to an integer. In general, it is not a good idea to rely on the specific numeric value of an Enum. However, the integer can be used to encode the Enum for storage.
}



FrooxEngine.LogiX.Operators.IntToEnum`1:##########################################################
{
The <color=#00FF00>Int To Enum`1</color> LogiX node converts an integer into an Enum. Typically such enumerated values are properties on components.
Usage

Use this node to convert an integer to an Enum. In general, it is not a good idea to rely on the specific numeric value of an Enum. However, the integer can be used to encode the Enum for storage.

}

Root of Math folder:

FrooxEngine.LogiX.Math.Abs:######################################################
{
The <color=#00FF00>Abs</color> node takes a numeric input and outputs the non-negative value of that input. The outputted value is known as the absolute value.
Usage

When spawned from the node browser, this node accepts float data by default. However, this node can be overloaded to accept a wide variety of numeric datatypes if an appropriate wire is connected to the input. 
}



FrooxEngine.LogiX.Math.Acos:#################################################
{
The <color=#00FF00>Acos</color> node takes an input value in radians and outputs the inverse cosine of that value.

Usage

When spawned from the node browser, this node accepts float data by default. However, this node can be overloaded to accept a wide variety of numeric datatypes if an appropriate wire is connected to the input. The datatype must support decimal places due to the nature of the function. 
}


FrooxEngine.LogiX.Math.Asin:###########################################
{
The <color=#00FF00>Asin</color> node takes an input value in radians and outputs the inverse sin of that value.

Usage

When spawned from the node browser, this node accepts float data by default. However, this node can be overloaded to accept a wide variety of numeric datatypes if an appropriate wire is connected to the input. The datatype must support decimal places due to the nature of the function.
}


FrooxEngine.LogiX.Math.Atan:#####################################
{
The <color=#00FF00>Atan</color> node takes an input value as a tangent and outputs the arc tangent of that value.

Usage

When spawned from the node browser, this node accepts float data by default. However, this node can be overloaded to accept a wide variety of numeric datatypes if an appropriate wire is connected to the input. The datatype must support decimal places due to the nature of the function. 
}



FrooxEngine.LogiX.Math.Atan2:#####################################
{
The <color=#00FF00>Atan2</color> node takes inputs Y, and X, and outputs the result of the 2 input arctangent function.

Usage

When spawned from the node browser, this node accepts float data by default. However, this node can be overloaded to accept a wide variety of numeric datatypes if an appropriate wire is connected to the input. The datatype must support decimal places due to the nature of the function.

Atan2 can be used to calculate the radians that a direction is from the positive x axis on a 2d plane. Put simply, it tells you how far around a circle the point at [x, y] is.
}



FrooxEngine.LogiX.Math.Avg:#######################################
{
The <color=#00FF00>Avg</color> node takes an arbitrary number of input values and outputs the average (AKA the 'mean') of all of those values.

The average of the inputs is defined as the sum of the inputs, divided by the number of inputs.
Usage

When spawned from the node browser, this node accepts float data by default. However, this node can be overloaded to accept a wide variety of numeric datatypes if an appropriate wire is connected to the input. The datatype must support decimal places due to the nature of the function. 
}


FrooxEngine.LogiX.Math.Ceil:######################################
{
The <color=#00FF00>Ceil</color> node (short for 'ceiling') takes a numeric input and outputs that input rounded up to the next whole number.
Usage

When spawned from the node browser, this node accepts float data by default. However, this node can be overloaded to accept a wide variety of numeric datatypes if an appropriate wire is connected to the input. The datatype must support decimal places due to the nature of the function.

When providing this node with a whole number input, the output will remain unchanged. 
}


FrooxEngine.LogiX.Math.CeilToInt:##################################
{
The <color=#00FF00>Ceil To Int</color> node functions identically to Ceil_(LogiX_node), performing a ceiling function. this node takes a numeric input and outputs that input rounded up to the next whole number as an integer.
Usage

When spawned from the node browser, this node accepts float data by default. However, this node can be overloaded to accept a wide variety of numeric datatypes if an appropriate wire is connected to the input. The datatype must support decimal places due to the nature of the function.

When providing this node with a whole number input, the output will remain unchanged. 
}


FrooxEngine.LogiX.Math.Clamp:######################################
{
The <color=#00FF00>Clamp</color> node takes 3 numeric inputs and outputs the Value input clamped between the Min and Max inputs.
Usage

When spawned from the node browser, this node accepts float data by default. However, this node can be overloaded to accept a wide variety of numeric datatypes if an appropriate wire is connected to the input. 
}



FrooxEngine.LogiX.Math.Clamp01:#####################################
{
The <color=#00FF00>Clamp01</color> node functions identically to Clamp_(LogiX_node) with the exception of the Min and Max inputs being fixed at 0 and 1 respectively.

The output will be the Value input clamped between 0 and 1.
Usage

When spawned from the node browser, this node accepts float data by default. However, this node can be overloaded to accept a wide variety of numeric datatypes if an appropriate wire is connected to the input. The datatype must support decimal places due to the nature of the function. 
}



FrooxEngine.LogiX.Math.ConstantLerp:################################
{
The <color=#00FF00>Constant Lerp</color> node outputs a value that approaches the target input at a constant rate based on the speed input.
Usage

When spawned from the node browser, this node accepts float data by default. However, this node can be overloaded to accept a wide variety of numeric datatypes if an appropriate wire is connected to the input. The datatype must support decimal places due to the nature of the function.

The speed input refers to units per second. This means that if you have a target of 10, a speed of 2, and you start at 0, you will reach the target in 5 seconds.

When spawned, whether from the node browser or through duplication, the node's output is the value of its target. 
}




FrooxEngine.LogiX.Math.Quaternions.ConstantSlerp:###################
{
The <color=#00FF00>Constant Slerp</color> node functions identically to the Constant_Lerp_(LogiX_node) node but uses spherical interpolation, which is better suited for rotations.
Usage

When spawned from the node browser, this node accepts FloatQ data.

The speed input refers to degrees per second.

When spawned, whether from the node browser or through duplication, the node's output is the value of its target. 
}



FrooxEngine.LogiX.Math.Cos:##########################################
{
The <color=#00FF00>Cos</color> node takes an input value in radians and outputs the cosine of that value.

Usage

When spawned from the node browser, this node accepts float data by default. However, this node can be overloaded to accept a wide variety of numeric datatypes if an appropriate wire is connected to the input. The datatype must support decimal places due to the nature of the function. 
}



FrooxEngine.LogiX.Math.CosineLerp:###################################
{
The <color=#00FF00>Cosine Lerp</color> node outputs the value that is interpolated between A and B with the Lerp input mapped to a cosine curve. This results in a smoother interpolation than the Lerp node provides.
Usage

When spawned from the node browser, this node accepts float data by default. However, this node can be overloaded to accept a wide variety of numeric datatypes if an appropriate wire is connected to the input. The datatype must support decimal places due to the nature of the function.

}



FrooxEngine.LogiX.Math.CubicLerp:#####################################
{
The <color=#00FF00>Cubic Lerp</color> node outputs the value that is interpolated between From and To with the Lerp input mapped to a spline curve which can be contorted by paired tangent inputs (From Tangent and To Tangent). This results in a much more customizable interpolation than any other current interpolation method in LogiX, with the added work of having to define tangents.
Usage

When spawned from the node browser, this node accepts float data by default. However, this node can be overloaded to accept a wide variety of numeric datatypes if an appropriate wire is connected to the input. The datatype must support decimal places due to the nature of the function. This node does not officially support FloatQ datatype. Attempting to interpolate a FloatQ by first converting it to an Euler angle may yield unexpected results.

Each input point defined has an associated tangent, this tangent is used to define the 'velocity' at that point. This means that if you were interpolating from point A to point B the instantaneous velocity of a point at A (The start of the interpolation) would perfectly match the tangent input associated with A and would end up matching the associated tangent of B once it reaches it. 
}



FrooxEngine.LogiX.Math.Exp:###########################################
{
The <color=#00FF00>Exp</color> node takes a numeric input and outputs the result of the exponential function. The exponential function is defined as e where e is Euler's number.


Usage

When spawned from the node browser, this node accepts float data by default. However, this node can be overloaded to accept a wide variety of numeric datatypes if an appropriate wire is connected to the input. The datatype must support decimal places due to the nature of the function. 
}




FrooxEngine.LogiX.Math.Floor:##########################################
{
The <color=#00FF00>Floor</color> node takes a numeric input and outputs that input rounded down to the next whole number. More information can be found on the wiki page for Floor And Ceiling Functions.
Usage

When spawned from the node browser, this node accepts float data by default. However, this node can be overloaded to accept a wide variety of numeric datatypes if an appropriate wire is connected to the input. The datatype must support decimal places due to the nature of the function.

When providing this node with a whole number input, the output will remain unchanged.

}



FrooxEngine.LogiX.Math.FloorToInt:#####################################
{
The <color=#00FF00>Floor To Int</color> node functions identically to Floor_(LogiX_node), performing a floor function. This node takes a numeric input and outputs that input rounded down to the next whole number as an integer.
Usage

When spawned from the node browser, this node accepts float data by default. However, this node can be overloaded to accept a wide variety of numeric datatypes if an appropriate wire is connected to the input. The datatype must support decimal places due to the nature of the function.

When providing this node with a whole number input, the output will remain unchanged.

}


FrooxEngine.LogiX.Math.GreatestCommonDivisor:############################
{
The <color=#00FF00>Greatest Common Divisor</color> Int node
(the largest positive integer that divides each of the integers) --- Wikipedia
}


FrooxEngine.LogiX.Math.InverseLerp:#######################################
{
The <color=#00FF00>Inverse Lerp</color> node returns how far along the Value input is to getting to the To input from the From input. This can be quite difficult to intuitively grasp so here's a helpful tutorial!
Usage

When spawned from the node browser, this node accepts float data by default. However, this node can be overloaded to accept a wide variety of numeric datatypes if an appropriate wire is connected to the input. 
}


FrooxEngine.LogiX.Math.IsBetween:##########################################
{
The <color=#00FF00>Is Between</color> node takes 3 inputs and returns true if the 'Value' input is between the 'Min' and 'Max' inputs. It also returns true if the 'Value' input is equal to either the 'Min' or 'Max' inputs.
Usage

When spawned from the node browser, this node accepts float data by default. However, this node can be overloaded to accept a wide variety of numeric datatypes if an appropriate wire is connected to the input. 
}



FrooxEngine.LogiX.Math.LeastCommonMultiple:#################################
{
The <color=#00FF00>Least Common Multiple</color> Int node

(is the smallest positive integer that is divisible by both a and b.[1][2] Since division of integers by zero is undefined, this definition has meaning only if a and b are both different from zero.[3] However, some authors define lcm(a,0) as 0 for all a, since 0 is the only common multiple of a and 0. ) --- Wikipedia
}


FrooxEngine.LogiX.Math.Lerp:#################################################
{
The <color=#00FF00>Lerp</color> node takes 3 inputs and returns the linearly interpolated value between the 'From' and 'To' inputs by the 'Lerp' input.
Usage

When spawned from the node browser, this node accepts float data by default. However, this node can be overloaded to accept a wide variety of numeric datatypes if an appropriate wire is connected to the input. 
}


FrooxEngine.LogiX.Math.Log:###################################################
{
The <color=#00FF00>Log</color> node outputs the natural logarithm of N. 
}



FrooxEngine.LogiX.Math.LogN:###################################################
{
The <color=#00FF00>Log N</color> node outputs the logarithm of N according to a specified base. 
}



FrooxEngine.LogiX.Math.Log10:###################################################
{
The <color=#00FF00>Log10</color> node outputs the base-10 logarithm of N.
}


FrooxEngine.LogiX.Math.Max:######################################################
{
The <color=#00FF00>Max</color> node takes a series of numeric inputs and outputs the highest value in that series. When a multi-dimensional value is inputted the node will output the highest value in each dimension separately from the inputs.
Usage

When spawned from the node browser, this node accepts float data by default. However, this node can be overloaded to accept a wide variety of numeric datatypes if an appropriate wire is connected to the input. 
}

FrooxEngine.LogiX.Math.Min:#######################################################
{
The <color=#00FF00>Min</color> node takes a series of numeric inputs and outputs the lowest value in that series. When a multi-dimensional value is inputted the node will output the lowest value in each dimension separately from the inputs.
Usage

When spawned from the node browser, this node accepts float data by default. However, this node can be overloaded to accept a wide variety of numeric datatypes if an appropriate wire is connected to the input. 
}


FrooxEngine.LogiX.Math.MultiLerp:##################################################
{
The <color=#00FF00>Multi Lerp</color> node is the same as Lerp_(LogiX_node) but takes an arbitrary number of inputs.
Usage

When spawned from the node browser, this node accepts float data by default. However, this node can be overloaded to accept a wide variety of numeric datatypes if an appropriate wire is connected to the input.

The Lerp range is equal to the number of input points minus one. This means that if you have 5 input points then you will reach the final value once the Lerp input is 4. This is because the node functions by interpolating between the individual inputs 2 at a time, essentially working like a regular Lerp_(LogiX_node) in the process.

Suppose you have 3 inputs now, to interpolate between the first 2 inputs, you would need to supply a Lerp value which is between 0 and 1. Similarly, to interpolate between the second and third input, you will need to supply a Lerp value which is between 1 and 2. 
}


FrooxEngine.LogiX.Math.MultiSlerp:################################################
{
The <color=#00FF00>Multi Slerp</color> node behaves identically to the Slerp_(LogiX_node) but accepts an arbitrary number of inputs. 
}



FrooxEngine.LogiX.Math.NthRoot:####################################################
{
The <color=#00FF00>Nth</color> Root node outputs the Nth root of the input value. 
}



FrooxEngine.LogiX.Math.PingPong:###################################################
{
The <color=#00FF00>Ping Pong</color> Float node

(Smooth transition incrementation and decrementation between 2 states forming a triangle waveform as the input value increases.

(Basically the output value "Ping Pongs" up and down in value as the input value increases))
}


FrooxEngine.LogiX.Math.Pow:#########################################################
{
The <color=#00FF00>Pow</color> node outputs a number N raised to a specified power.
}


FrooxEngine.LogiX.Math.Remap:#######################################################
{
The <color=#00FF00>Remap</color> node linearly maps one numerical interval to another interval.
Usage
Examples

An input interval of [-1, 1], an output interval of [0, 1], and an input value of -0.5 would result in the output 0.25. This is because -0.5 represents a fourth of the difference between -1 and 1 and is thus remapped to a fourth of the difference between 0 and 1. 
}



FrooxEngine.LogiX.Math.Remap11_01:##################################################
{
The <color=#00FF00>Remap -1..1 to 0..1</color> node linearly maps the numerical interval [-1, 1] to the interval [0, 1]. This is commonly used for remapping trigonometric functions onto an exclusively positive interval. This node behaves similarly to the Remap node but includes the aforementioned intervals by default. 
}


FrooxEngine.LogiX.Math.Repeat:#######################################################
{
The <color=#00FF00>Repeat</color> node in the Math category takes two arguments, N and Length and outputs the result of the following calculation

    N - floor(N/Length) * Length

so that the output goes between 0 and Length in a repeating fashion, as described in Usage. 

Usage

This node repeats values between 0 and Length, as N is increased. When N is 0, the output is 0, and then the output increases with N, until N reaches the value Length, and it goes to 0, and repeats this pattern for ever. This pattern looks like a positive-valued sawtooth wave as shown below, for a value of Length=2.2 


Note: This node behaves in the same way as Modulus operator (denotes %) in other programming languages, like Python. LogiX uses the different definition of % which C# uses, and therefore offers the Repeat node when the above behaviour is desired.

The Repeat01 (LogiX node) is equivalent to this node, where Length is set to 1. 

}


FrooxEngine.LogiX.Math.Repeat01:#######################################################
{
The <color=#00FF00>Repeat01</color> node in the Math category takes one argument Value, and does the same operation as the Repeat (LogiX node) where N is set to Value and Length is set to 1, that is it outputs

    Value - floor(Value)

This means that the output goes between 0 and 1 in a repeating fashion, as described in Usage.

Usage

This node repeats values between 0 and 1, as N is increased. When N is 0, the output is 0, and then the output equals N as N increases, until N reaches the value 1, and the output goes to 0, and repeats this pattern for ever. This pattern looks like a positive-valued sawtooth wave as shown below, 
}



FrooxEngine.LogiX.Math.Round:##########################################################
{
The <color=#00FF00>Round</color> node outputs the value N rounded to the nearest integer. Note that this node returns an float instead of an integer. Because floating-point errors can occur when using floats, this node may offer less precision and reliability than would otherwise be attainable with the Round To Int node. 
}


FrooxEngine.LogiX.Math.RoundToInt:#####################################################
{
The <color=#00FF00>Round To Int</color> node outputs the value N rounded to the nearest integer. Note that this node returns an integer instead of a rounded float. Because floating-point errors can occur when using floats, this node can offer greater precision and reliability than would otherwise be attainable with the Round node. 
}



FrooxEngine.LogiX.Math.SigmoidNode:#####################################################
{
The <color=#00FF00>Sigmoid</color> node returns the output of the Sigmoid function according to E[Clarification needed] and a specified power.

(The sigmoid function forms an S shaped graph, which means as x approaches infinity, the probability becomes 1, and as x approaches negative infinity, the probability becomes 0. The model sets a threshold that decides what range of probability is mapped to which binary variable.) --- educative.io

}

FrooxEngine.LogiX.Math.Sign:############################################################
{
The <color=#00FF00>Sign</color> Float node 
}


FrooxEngine.LogiX.Math.SimplexNoise:#####################################################
{
The <color=#00FF00>Simplex Noise</color> node outputs simplex noise according to a specified 1D input coordinate. 
}


FrooxEngine.LogiX.Math.Sin:###############################################################
{
The <color=#00FF00>Sin</color> node takes an input value in radians and outputs the sine of that value.
Usage

When spawned from the node browser, this node accepts float data by default. However, this node can be overloaded to accept a wide variety of numeric datatypes if an appropriate wire is connected to the input. The datatype must support decimal places due to the nature of the function. 
}


FrooxEngine.LogiX.Math.Slerp:##############################################################
{
The <color=#00FF00>Slerp</color> node performs a spherical linear interpolation between two floatQs. This is useful for interpolating rotation accurately using quaternions. 
}


FrooxEngine.LogiX.Math.SmoothLerp:#########################################################
{
The <color=#00FF00>Smooth Lerp</color> node smoothly interpolates from it's current value to a specified target value at a given speed. 

Usage

When spawned, the Smooth Lerp node's default data type is float. This can be overloaded to accept the float2, float3, float4, and Color data types by plugging the desired data types into the Target input.

Using a floatQ data type will automatically change the node into a Smooth Slerp logix node, which cannot normally be accessed inside of the Node Browser.

When spawned, whether from the node browser or through duplication, the node's output is the value of its target.

Common uses of this node include:

    Smooth translations of an object's Position or Scale over time.
    Smooth transitions of one color to another over time.
}



FrooxEngine.LogiX.Math.Sqrt:###############################################################
{
The <color=#00FF00>Sqrt</color> node takes a Float input and then outputs the calculated square root.
}



FrooxEngine.LogiX.Math.Tan:################################################################
{
The <color=#00FF00>Tan</color> node returns the output of the tangent function according to an input in radians. 
}



FrooxEngine.LogiX.Math.Delta:##############################################################
{
The  node takes an input and will output the delta or difference in value per frame of the given input.
Usage

When spawned from the node browser, this node accepts float data by default. However, this node can be overloaded to accept a wide variety of numeric datatypes if an appropriate wire is connected to the input. 
}

FrooxEngine.LogiX.Math.TorqueEstimateNode:###########################################################
{
The <color=#00FF00>Torque Estimate</color> node 
}


FrooxEngine.LogiX.Math.TrajectoryNode:#################################################################
{
The <color=#00FF00>Trajectory</color> node solves for the positional displacement of a projectile according to a set of parameters. This node can be used to help simulate the parabolic motion of a projectile.
Usage

The output of the node (Float3 position) is the position the object will be at relative to the origin at the time that is input at the Time input (Float time), which takes an input of where in time during the trajectory arc you want to have the position of

The gravity input (Float3 gravity) will be how fast the position will move in the direction input at a constant acceleration, generally the standard being a Float3 of (0, -9.81, 0), which results in normal earth gravity on the y axis

Initial Velocity (Float3 intialvelocity) will be your velocity you want it to have at time 0, or when the movement should start

Drag (Float drag) is needed if you want air resistance over time. This can usually be disregarded by setting the value to near zero, however a value of 0 will break the calculations so a value greater than 0 has to be put in 
}FrooxEngine.LogiX.Math.Quaternions.ToAxisAngle_:######################################################
{
The <color=#00FF00>Axis Angle</color> LogiX node converts a rotation represented as an axis-angle to the native quaternion representation. The first input is the axis about which to rotate, and the second input is the angle in degrees to rotate clockwise (positive) or counterclockwise (negative) about the axis by.
Usage

Use this node to convert rotation about an arbitrary axis into a quaternion which can then be used in further computations or used as an object's rotation input.
Examples

Here we have a door with a Door Pivot child placed on the hinge side of the door. We can drive the Door Pivot object's Rotation property (a quaternion) with the Axis Angle node's output (also a quaternion). We specify rotation about the Y axis (the green axis), and 0 degrees of rotation: 

By changing the rotation amount to -60 degrees, we rotate the object 60 degrees counterclockwise. 

}



FrooxEngine.LogiX.Math.Quaternions.EulerAngles_:#####################################################
{
The <color=#00FF00>Euler Angles</color> LogiX node converts a a rotation represented as a native quaternion to an ZYX-ordered Euler angle representation. That is, the object is first rotated about its Z axis, then rotated about its Y axis, then rotated about its X axis.
Usage

Use this node to convert a quaternion into ZYX Euler rotation.
Examples

Here we specify -60 degrees of rotation about the Y axis using an Axis Angle node, then feed the result to the Euler Angles node: 

In the above example, the output representation is -60 degrees of rotation about the Y axis. 
}



FrooxEngine.LogiX.Math.Quaternions.FromEuler_:#######################################################
{
The <color=#00FF00>From Euler</color> node converts a float3 representing the three Euler angles into a floatQ.
}


FrooxEngine.LogiX.Math.Quaternions.FromToRotation_:##################################################
{
The <color=#00FF00>From To Rotation</color> LogiX node creates a rotation represented as a native quaternion which rotates the first (From) vector to the second (To) vector.
Usage

This node can be used to apply a rotation so that the From vector, e.g. a vector along the Y axis, follows a target direction (the To vector).
Examples

Here we want a rotation that rotates a vector along the X axis to a point along a vector halfway between the X and Y axes, or in other words, points the X vector in that direction. 

The resulting rotation is 45 degrees about the Z axis. 

}



FrooxEngine.LogiX.Math.Quaternions.InverseRotation_:##################################################
{
The <color=#00FF00>Inverse Rotation</color> LogiX node creates a rotation represented as a native quaternion which is the opposite of the rotation represented by its input quaternion.
Usage

This node can be used to apply an inverse rotation.
Examples

Here we want a rotation that that is the opposite of a 45 degree rotation about the X axis.

Inverse Rotation Example.jpg 

The resulting rotation is 45 degrees about the -X axis, which is equivalent to a rotation -45 degrees about the X axis. 
}



FrooxEngine.LogiX.Math.Quaternions.LookRotation_:####################################################
{
The <color=#00FF00>Look Rotation</color> LogiX node creates a rotation represented as a native quaternion which will rotate an object such that its Z axis points in the direction of the Forward vector, and its Y axis points in the direction of the component of the Up vector that doesn't point in the direction Forward vector. More technically, the object's X axis will point in the direction of the cross-product of the Forward and Up vectors.
Usage

This node can be used to turn an object to face another object, while keeping its "top" generally facing in the same direction.
Examples

The Z axis of an object is generally considered its "forward" axis and its Y axis is its "up" axis. For example, suppose we had an avatar whose nose was pointing in the Z axis ("forward"), with the top of its head in the Y axis ("up"). However, now we want the avatar to rotate its head so that its nose was pointing along the X axis while still remaining with the top of its head pointing up.

Look Rotation example.jpg

The required head rotation is 90 degrees about the Y axis. 
}




FrooxEngine.LogiX.Math.Quaternions.ToAxisAngle_:######################################################
{
The <color=#00FF00>To Axis Angle</color> LogiX node converts a rotation represented as a native quaternion to an axis-angle representation. The first output is the axis about which to rotate, and the second output is the angle in degrees to rotate clockwise (positive) or counterclockwise (negative) about the axis by.

Note that there are two valid axis-angle representations of a rotation: positive rotation about an axis, and negative rotation about the opposite axis. Which is chosen by To Axis Angle is effectively random.
Usage

Use this node to convert a quaternion into rotation about a specific axis.
Examples

Here we specify -60 degrees of rotation about the Y axis using an Axis Angle node, then feed the result to the To Axis Angle node:

To Axis Angle and Euler Angles example.jpeg

In the above example, the output representation is 60 degrees of rotation about the -Y axis, which is equivalent to -60 degrees of rotation about the +Y axis. 
}


